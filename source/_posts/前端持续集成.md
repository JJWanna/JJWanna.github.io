---
title: 前端持续集成
date: 2017-03-30 09:05:37
tags: 前端架构构建
---

* 什么是集成
* 什么是统一代码仓库
* 什么是前端工程化
* 什么是自动化构建
* 更多得自动化

### 持续集成需求
1.持续集成是通过平台串联各个开发环节，实现和沉淀工作自动化的方法。
2.线上代码和代码仓库不同步，影响迭代和团队协作。
3.静态资源发布依赖人工，浪费开发人力。
4.缺少自动化测试，产品质量得不到保障。
5.文案简单修改上线，需要技术介入。
<!--more-->
![](/images/170330-1.png)
### 统一代码仓库
1.统一代码仓库通过分支管理合并主干svn。
2.自动化构建工具，编译、部署、测试、监控、本级开发上线环境。**FIS3/Webpack/jdists/package.json/chai/supertest/mocha/selenium-webdriver**
3.持续集成平台。**Jenkins、Travis CI**
4.部署工具。**rsync、shelljs、yargs**
5.运营同学有权限操作运营页面保存即可上线。
### 统一代码仓库多分支开发
![](/images/170330-2.png)                     
### 合成步骤
1.svn checkout svn地址 --username用户名
2.svn branch 分支名（add/commit）
3.svn merge 主干svn地址  分支svn地址
4.Beyond Compare -> svn resolved
5.svn copy 主干svn地址 /tags/2017
![](/images/170330-3.png)    
### 前端工程化目标
* 自动化编译
* 前端模块化
* 定位静态资源
* 前端开发组件化
* 自动化部署测试配合版本库
* 自动化性能优化（前端架构开发下）

### 自动化编译
![](/images/170330-4.png)  
### 自动化编译流程
* 读入foo.es的文件内容，编译成js内容
* 分析js内容，找到资源定位标记'foo.scss'
* 对foo.scss进行编译：
    * 读入foo.scss的文件内容，编译成css内容
    * 分析css内容，找到资源定位标记'url(foo.png)'
    * 对foo.png进行编译：
        * 读入foo.png的内容
        * 图片压缩
        * 返回图片内容
    * 根据foo.png的最终内容计算md5戳，替换url(foo.png)为url(/static/img/foo_2afob.png)
    * 替换完毕所有资源定位标记，对css内容进行压缩
    * 返回css内容 
* 根据foo.css的最终内容计算md5戳，替换'foo.scss'为'/static/scss/foo_bae39.css'
* 替换完毕所有资源定位标记，对js内容进行压缩
* 返回js内容
* 根据最终的js内容计算mds戳，得到foo.coffee的资源url为'/static/scripts/foo_3fc20.js'
### 前端模块化
1.前端模块化框架肩负着**模块管理**、**资源加载**两项重要的功能。这两项功能与**工具**、**性能**、**业务**、**部署**等工程环节都有着非常紧密的联系。
  因此，模块化框架的设计应该最高优先级考虑工程需要。
2.commonjs API定义很多普通应用程序（主要指非浏览器的应用）使用的API,从而填补了这个空白。它的终极目标是提供一个类似 Python,Ruby和Java标准库。
3.根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里定义的变量、函数、类，都有私有的，对其他文件不可见。
4.CMD和AMD都是CommonJS的一种规范的实现定义，RequireJS和SeaJS是对应的实践。

* AMD


    define(['dep1','dep2'],function(dep1,dep2){    
        // 内部只能使用执行的模块
        return function(){};
    });
    
* CMD


    define(function(require,exports,module){     
        //此处如果需要加载某xx模块，可引入
        var xx=require('xx');
    })
    
#### 优缺点：
1.CMD依赖是就近声明，通过内部require方法进行声明。但是因为是异步模块，加载需要提前加载这些模块，所以模块真正使用前需要提取模块里面所有的依赖。
2.不能直接压缩，require局部变量如果替换无法加载资源。
3.CMD路径参数不能进行字符串运算。
4.AMD的依赖是提前声明。这种优势的好处就是依赖无需通过静态分析，无论是加载器还是自动化工具都可以直接的获取到依赖。
5.AMD依赖提前声明在代码书写上不是很友好。
6.AMD模块内部与NodeJS的Modules有一定的差异。

### 依赖后置
1.requirejs和seajs而知在加载上都有缺陷，就是模块的依赖要等到模块加载完成后，通过静态分析（seajs）或者deps参数（requirejs）来获取，这就为合并请求和按需加载带来了实现上的矛盾：
  要么放弃按需加载，把所有j合成一个文件。要么放弃请求合并，请求独立的模块文件，从而满足按需加载。
2.AMD规范在执行callback的时候，要初始化所有依赖的模块，而CMD只有执行到require的时候才初始化模块。所以用AMD实现某种if-else逻辑分支家在不同的模块时候，就会比较麻烦了。

    reqquire(['page/index','page/detail'],function(index,detail){
        switch(location.hash){
            case'index':
                index();
            break;
        }
    }});
    
3.以上纯前端方式实现模块化框架不能同时满足 按需加载、请求合并和依赖管理 三个需求。

![](/images/170330-5.png)  

### 为什么用webpack
1.webpack执行commonJs标准，解决了依赖配置和请求流量。
2.对于webpack来讲万物都可以是模块，所有的文件都被合并到js中，最终在浏览器。
3.兼容AMD和CMD
4.js模块化不仅仅为了提高代码复用性，更是为了让资源文件更合理的进行缓存。

    function(moudle,exportss._webpack_require_){
        exports=module.exports=_webpack_require_(3)();
        //imports
        
        //module
        
        exports.push([module.id,"body{\r\n background-color:yellow;\r\n}\r\n",""]);
        
        //exports
        
    },
    
    new webpack.optimize.UglifyJsPlugin({
        mangle:{
            except:['$super','$','exports','require']
        }
    })
    
    
    var path = require("path");
    var CommonsChunkPlugin = require("../../node_modules/webpack/lib/optimize/CommonsChunkPlugin");
    module.exports={
        entry:{
            m1:'./m1.js',
            m2:'./m2.js'
        },
        output:{
            path:"build",
            filename:'[name].bundle.js'
        },
        plugins:[
            new CommonsChunkPlugin('common.js');
        ]
    };


### 资源定位
1.配置超长时间的本地缓存--节省宽带，提高性能
2.采用内容摘要作为缓存更新依据--精确的缓存控制
3.静态资源CDN部署--优化网络请求
4.更资源发布路径实现非覆盖式发布--平滑升级
 
* FIS3根据分析好的文件包，利用HOOK插件 分析下FIS生成的配置文件
* webpack阿紫开发阶段打包，利用插件分析直接提取。FileLoader&&extract-text-webpack-plugin
* 配置publicpath分发到CDN


### 前端开发组件化
1.每个前端模块都是一个小项目，配合mock.js可以进行本地的开发测试，package.json是标配产物。经过webpack的环境配置统一进行本地环境、上线环境的变异过程。
2.由page组装widget，由widget组装webComponents(X-TAG)
3.能够根据路由快速选择配置SPA或者直出。

### web components
1.Custom Elements
2.HTML Imports
3.HTML Templates
4.Shadow DOM

* Custom Elements 提供一种方式让开发者可以自定义HTML元素，包括特定的组成，样式和行为。
    
     
     class ButtonHelloElement extends HTMLButtonElement{
        constructor(){
            super()
            this.addEventListener('click',()=>{
                alert('hello world');
            })
        }
     }
     customElements.define('button-hello',ButtonHelloElement,{extends:'button'})
     <button is="button-hello">hello world</button>

* HTML Imports 是一种在HTML中引用以及服用其他的HTML文档的方式。这个Import很漂亮，可以简单理解为我们常见的末班中的include之类的作用。


    <link rel="import" href="/components/header.html">
    const link=document.querySelector('link[rel=import]')
    const header=link.import;
    
    const pulse=header.querySelector('div.logo');
    //获取import的HTMl的document
    const d=document.currentScript.ownerDocument

用过handlebars的人都知道有这么一个东西：

    <script id="template" type="text/x-handlebars-template"></script>
那么HTML Templates是把这个东西官方标准化，提供了一个template 标签来存放以后需要但是暂时不渲染的HTML代码。

    <template id="template"><p>Smile</p></template>
    <script>
    let num=3;
    const fragment=document.getElementById('template').content.cloneNode(true);
    while(num -->1 ){
        fragment.firstChild.before(fragment.firstChild.cloneNode(true));
        fragment.firstChild.textContent+=fragment.lastChild.textContent;
    }
    document.body.appendChild(fragment);
    </script>


* Shadow DOM  最本质的需求是需要一个隔离组件代码作用域的东西，例如我组件代码的css不能影响其他组件之类的，而iframe又太重并且可能有各种奇怪问题。旨在提供一种更好的组织页面元素的方式，来为日趋复杂的页面应用提供强大支持，避免代码间的相互影响。


     const div=document.getElementById('id')
     const shadowRoot=div.createShadowRoot()
     const span=document.creatElement('span')
     
     span.textContent='hello world'
     shadowRoot.appendChild(span)
     
     <x-foo>
        <"shadow tree">
            <div>
                <span id="not-top">...</span>
            </div>
            <span id="top">...</span>
        </>
     </x-foo>
     
     x-foo::shadow > span 可以匹配到#top元素
     x-foo /deep/span 可以匹配到 #not-top和 #top元素
     :host(.foo) 匹配<x-foo>元素
     
* Web Components


     <template id="">
     <style>
     ::content li{
        display:inline-block;
        padding:20px 10px;
     }
     </style>
     <content select="ul"></content>
     </template>
     
     
     <link rel="import" href="components/header.html">
     </head>
     <body>
        <test-header>
            <ul>
                <li>Home</li>
                <li>About</li>
            </ul>
        </test-header>
     </body>
     
### 自动化部署
1.自动化运营平台
2.自动化雪碧图
3.自动化离线打包
4.自动化控制缓存级别
5.自动化处理inline
6.自动化根据网速分发版本资源
7.自动化运维平台
