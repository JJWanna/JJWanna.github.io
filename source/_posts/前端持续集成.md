---
title: 前端持续集成
date: 2017-03-30 09:05:37
tags: 前端架构构建
---

* 什么是集成
* 什么是统一代码仓库
* 什么是前端工程化
* 什么是自动化构建
* 更多得自动化

### 持续集成需求
1.持续集成是通过平台串联各个开发环节，实现和沉淀工作自动化的方法。
2.线上代码和代码仓库不同步，影响迭代和团队协作。
3.静态资源发布依赖人工，浪费开发人力。
<!--more-->
4.缺少自动化测试，产品质量得不到保障。
5.文案简单修改上线，需要技术介入。
![](images/170330-1.png)
### 统一代码仓库
1.统一代码仓库通过分支管理合并主干svn。
2.自动化构建工具，编译、部署、测试、监控、本级开发上线环境。**FIS3/Webpack/jdists/package.json/chai/supertest/mocha/selenium-webdriver**
3.持续集成平台。**Jenkins、Travis CI**
4.部署工具。**rsync、shelljs、yargs**
5.运营同学有权限操作运营页面保存即可上线。
### 统一代码仓库多分支开发
![](images/170330-2.png)                     
### 合成步骤
1.svn checkout svn地址 --username用户名
2.svn branch 分支名（add/commit）
3.svn merge 主干svn地址  分支svn地址
4.Beyond Compare -> svn resolved
5.svn copy 主干svn地址 /tags/2017
![](images/170330-3.png)    
### 前端工程化目标
* 自动化编译
* 前端模块化
* 定位静态资源
* 前端开发组件化
* 自动化部署测试配合版本库
* 自动化性能优化（前端架构开发下）
### 自动化编译
![](images/170330-4.png)  
**自动化编译流程：**
* 读入foo.es的文件内容，编译成js内容
* 分析js内容，找到资源定位标记'foo.scss'
* 对foo.scss进行编译：
    * 读入foo.scss的文件内容，编译成css内容
    * 分析css内容，找到资源定位标记'url(foo.png)'
    * 对foo.png进行编译：
        * 读入foo.png的内容
        * 图片压缩
        * 返回图片内容
    * 根据foo.png的最终内容计算md5戳，替换url(foo.png)为url(/static/img/foo_2afob.png)
    * 替换完毕所有资源定位标记，对css内容进行压缩
    * 返回css内容 
* 根据foo.css的最终内容计算md5戳，替换'foo.scss'为'/static/scss/foo_bae39.css'
* 替换完毕所有资源定位标记，对js内容进行压缩
* 返回js内容
* 根据最终的js内容计算mds戳，得到foo.coffee的资源url为'/static/scripts/foo_3fc20.js'
### 前端模块化
1.前端模块化框架肩负着**模块管理**、**资源加载**两项重要的功能。这两项功能与**工具**、**性能**、**业务**、**部署**等工程环节都有着非常紧密的联系。
  因此，模块化框架的设计应该最高优先级考虑工程需要。
2.commonjs API定义很多普通应用程序（主要指非浏览器的应用）使用的API,从而填补了这个空白。它的终极目标是提供一个类似 Python,Ruby和Java标准库。
3.根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里定义的变量、函数、类，都有私有的，对其他文件不可见。
4.CMD和AMD都是CommonJS的一种规范的实现定义，RequireJS和SeaJS是对应的实践。
      
    //AMD
    define(['dep1','dep2'],function(dep1,dep2){
        //内部只能使用执行的模块
        return function(){};
    });
    //CMD
    define(function(require,exports,module){
        //此处如果需要加载某xx模块，可引入
        var xx=require('xx');
    })
优缺点：
1.CMD依赖是就近声明，通过内部require方法进行声明。但是因为是异步模块，加载需要提前加载这些模块，所以模块真正使用前需要提取模块里面所有的依赖。
2.不能直接压缩，require局部变量如果替换无法加载资源。
3.CMD路径参数不能进行字符串运算。
4.AMD的依赖是提前声明。这种优势的好处就是依赖无需通过静态分析，无论是加载器还是自动化工具都可以直接的获取到依赖。
5.AMD依赖提前声明在代码书写上不是很友好。
6.AMD模块内部与NodeJS的Modules有一定的差异。