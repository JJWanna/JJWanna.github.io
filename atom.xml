<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WJJ@博客</title>
  <subtitle>真正的才智是刚毅的志向</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-27T02:35:47.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>W.JJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入贯彻闭包思想，全面理解JS闭包形成过程</title>
    <link href="http://yoursite.com/2018/02/27/%E6%B7%B1%E5%85%A5%E8%B4%AF%E5%BD%BB%E9%97%AD%E5%8C%85%E6%80%9D%E6%83%B3%EF%BC%8C%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3JS%E9%97%AD%E5%8C%85%E5%BD%A2%E6%88%90%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/02/27/深入贯彻闭包思想，全面理解JS闭包形成过程/</id>
    <published>2018-02-27T02:32:39.000Z</published>
    <updated>2018-02-27T02:35:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>谈起闭包，它可是JavaScript两个核心技术之一(异步和闭包),在面试以及实际应用当中，我们都离不开它们，甚至可以说它们是衡量js工程师实力的一个重要指标。下面我们就罗列闭包的几个常见问题，从回答问题的角度来理解和定义你们心中的闭包。</p>
<p>问题如下:</p>
<p>1.什么是闭包?<br>2.闭包的原理可不可以说一下？<br>3.你是怎样使用闭包的？</p>
<a id="more"></a>
<h3 id="闭包的介绍"><a href="#闭包的介绍" class="headerlink" title="闭包的介绍"></a>闭包的介绍</h3><p>我们先看看几本书中的大致介绍:</p>
<p>1.闭包是指有权访问另一个函数作用域中的变量的函数</p>
<p>2.函数对象可以通过作用域关联起来，函数体内的变量都可以保存在函数作用域内，这在计算机科学文献中称为“闭包”,所有的javascirpt函数都是闭包</p>
<p>3.闭包是基于词法作用域书写代码时所产生的必然结果。</p>
<p>4.函数可以通过作用域链相互关联起来，函数内部的变量可以保存在其他函数作用域内，这种特性在计算机科学文献中称为闭包。</p>
<p>可见，它们各有各自的定义，但要说明的意思大同小异。笔者在这之前对它是知其然而不知其所以然，最后用了一天的时间从词法作用域到作用域链的概念再到闭包的形成做了一次总的梳理，发现做人好清晰了…。</p>
<p>下面让我们抛开这些抽象而又晦涩难懂的表述，从头开始理解，内化最后总结出自己的一段关于闭包的句子。我想这对面试以及充实开发者自身的理论知识非常有帮助。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;谈起闭包，它可是JavaScript两个核心技术之一(异步和闭包),在面试以及实际应用当中，我们都离不开它们，甚至可以说它们是衡量js工程师实力的一个重要指标。下面我们就罗列闭包的几个常见问题，从回答问题的角度来理解和定义你们心中的闭包。&lt;/p&gt;
&lt;p&gt;问题如下:&lt;/p&gt;
&lt;p&gt;1.什么是闭包?&lt;br&gt;2.闭包的原理可不可以说一下？&lt;br&gt;3.你是怎样使用闭包的？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>10个JavaScript难点</title>
    <link href="http://yoursite.com/2018/02/27/10%E4%B8%AAJavaScript%E9%9A%BE%E7%82%B9/"/>
    <id>http://yoursite.com/2018/02/27/10个JavaScript难点/</id>
    <published>2018-02-27T01:22:57.000Z</published>
    <updated>2018-02-27T02:35:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-立即执行函数"><a href="#1-立即执行函数" class="headerlink" title="1. 立即执行函数"></a>1. 立即执行函数</h3><p>立即执行函数，即Immediately Invoked Function Expression (IIFE)，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;     <span class="comment">// 代码</span></div><div class="line">     <span class="comment">// ...&#125;)();</span></div></pre></td></tr></table></figure>
</code></pre><p>function(){…}是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。立即执行函数也可以理解为立即调用一个匿名函数。立即执行函数最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。</p>
<a id="more"></a>
<h3 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2. 闭包"></a>2. 闭包</h3><p>对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;    <span class="keyword">var</span> N = <span class="number">0</span>; <span class="comment">// N是f1函数的局部变量</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) // <span class="title">f2</span>是<span class="title">f1</span>函数的内部函数，是闭包    </span>&#123;</div><div class="line">        N += <span class="number">1</span>; <span class="comment">// 内部函数f2中使用了外部函数f1中的变量N</span></div><div class="line">        <span class="built_in">console</span>.log(N);</div><div class="line">    &#125;    <span class="keyword">return</span> f2;</div><div class="line">&#125;<span class="keyword">var</span> result = f1();</div><div class="line"></div><div class="line">result(); <span class="comment">// 输出1result(); // 输出2result(); // 输出3</span></div></pre></td></tr></table></figure>
<p>代码中，外部函数f1只执行了一次，变量N设为0，并将内部函数f2赋值给了变量result。由于外部函数f1已经执行完毕，其内部变量N应该在内存中被清除，然而事实并不是这样：我们每次调用result的时候，发现变量N一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！</p>
<h3 id="3-使用闭包定义私有变量"><a href="#3-使用闭包定义私有变量" class="headerlink" title="3. 使用闭包定义私有变量"></a>3. 使用闭包定义私有变量</h3><p>通常，JavaScript开发者使用下划线作为私有变量的前缀。但是实际上，这些变量依然可以被访问和修改，并非真正的私有变量。这时，使用闭包可以定义真正的私有变量：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">var</span> name;    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        name = value;</div><div class="line">    &#125;;    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        <span class="keyword">return</span> name;</div><div class="line">    &#125;;</div><div class="line">&#125;<span class="keyword">var</span> p = <span class="keyword">new</span> Product();</div><div class="line">p.setName(<span class="string">"Fundebug"</span>);<span class="built_in">console</span>.log(p.name); <span class="comment">// 输出undefinedconsole.log(p.getName()); // 输出Fundebug</span></div></pre></td></tr></table></figure></p>
<p>代码中，对象p的name属性为私有属性，使用p.name不能直接访问。</p>
<h3 id="4-prototype"><a href="#4-prototype" class="headerlink" title="4. prototype"></a>4. prototype</h3><p>每个JavaScript构造函数都有一个prototype属性，用于设置所有实例对象需要共享的属性和方法。prototype属性不能列举。JavaScript仅支持通过prototype属性进行继承属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">x, y</span>)</span>&#123;    <span class="keyword">this</span>._length = x;    <span class="keyword">this</span>._breadth = y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Rectangle.prototype.getDimensions = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">length</span>: <span class="keyword">this</span>._length,</div><div class="line">        <span class="attr">breadth</span>: <span class="keyword">this</span>._breadth</div><div class="line">    &#125;;</div><div class="line">&#125;;<span class="keyword">var</span> x = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);<span class="keyword">var</span> y = <span class="keyword">new</span> Rectangle(<span class="number">4</span>, <span class="number">3</span>);<span class="built_in">console</span>.log(x.getDimensions()); <span class="comment">// &#123; length: 3, breadth: 4 &#125;console.log(y.getDimensions()); // &#123; length: 4, breadth: 3 &#125;</span></div></pre></td></tr></table></figure>
<p>代码中，x和y都是构造函数Rectangle创建的对象实例，它们通过prototype继承了getDimensions方法。</p>
<h3 id="5-模块化"><a href="#5-模块化" class="headerlink" title="5. 模块化"></a>5. 模块化</h3><p>JavaScript并非模块化编程语言，至少ES6落地之前都不是。然而对于一个复杂的Web应用，模块化编程是一个最基本的要求。这时，可以使用立即执行函数来实现模块化，正如很多JS库比如jQuery以及我们Fundebug都是这样实现的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">var</span> N = <span class="number">5</span>;    <span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">x</span>) </span>&#123;        <span class="built_in">console</span>.log(<span class="string">"The result is: "</span> + x);</div><div class="line">    &#125;    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;        <span class="keyword">var</span> x = a + N;</div><div class="line">        print(x);</div><div class="line">    &#125;    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">description</span>: <span class="string">"This is description"</span>,</div><div class="line">        <span class="attr">add</span>: add</div><div class="line">    &#125;;</div><div class="line">&#125;)();<span class="built_in">console</span>.log(<span class="built_in">module</span>.description); <span class="comment">// 输出"this is description" module.add(5); // 输出“The result is: 10”</span></div></pre></td></tr></table></figure></p>
<p>所谓模块化，就是根据需要控制模块内属性与方法的可访问性，即私有或者公开。在代码中，module为一个独立的模块，N为其私有属性，print为其私有方法，decription为其公有属性，add为其共有方法。</p>
<h3 id="6-变量提升"><a href="#6-变量提升" class="headerlink" title="6. 变量提升"></a>6. 变量提升</h3><p>JavaScript会将所有变量和函数声明移动到它的作用域的最前面，这就是所谓的变量提升(Hoisting)。也就是说，无论你在什么地方声明变量和函数，解释器都会将它们移动到作用域的最前面。因此我们可以先使用变量和函数，而后声明它们。</p>
<p>但是，仅仅是变量声明被提升了，而变量赋值不会被提升。如果你不明白这一点，有时则会出错：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(y);  <span class="comment">// 输出undefinedy = 2; // 初始化y</span></div></pre></td></tr></table></figure></p>
<p>上面的代码等价于下面的代码：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var y;  <span class="regexp">//</span> 声明yconsole.log(y);  <span class="regexp">//</span> 输出undefinedy = <span class="number">2</span>; <span class="regexp">//</span> 初始化y</div></pre></td></tr></table></figure></p>
<p>为了避免BUG，开发者应该在每个作用域开始时声明变量和函数。</p>
<h3 id="7-柯里化"><a href="#7-柯里化" class="headerlink" title="7. 柯里化"></a>7. 柯里化</h3><p>柯里化，即Currying，可以是函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;        <span class="keyword">return</span> x + y;</div><div class="line">    &#125;;</div><div class="line">&#125;;<span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">1</span>)); <span class="comment">// 输出2var add1 = add(1);console.log(add1(1)); // 输出2var add10 = add(10);console.log(add10(1)); // 输出11</span></div></pre></td></tr></table></figure>
<p>代码中，我们可以一次性传入2个1作为参数add(1)(1)，也可以传入1个参数之后获取add1与add10函数，这样使用起来非常灵活。</p>
<h3 id="8-apply-call与bind方法"><a href="#8-apply-call与bind方法" class="headerlink" title="8. apply, call与bind方法"></a>8. apply, call与bind方法</h3><p>JavaScript开发者有必要理解apply、call与bind方法的不同点。它们的共同点是第一个参数都是this，即函数运行时依赖的上下文。</p>
<p>三者之中，call方法是最简单的，它等价于指定this值调用函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> user = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">"Rahul Mhatre"</span>,</div><div class="line">    <span class="attr">whatIsYourName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">user.whatIsYourName(); <span class="comment">// 输出"Rahul Mhatre",var user2 = &#123;</span></div><div class="line">    name: <span class="string">"Neha Sampat"</span>&#125;;</div><div class="line"></div><div class="line">user.whatIsYourName.call(user2); <span class="comment">// 输出"Neha Sampat"</span></div></pre></td></tr></table></figure>
<p>apply方法与call方法类似。两者唯一的不同点在于，apply方法使用数组指定参数，而call方法每个参数单独需要指定：</p>
<ul>
<li>apply(thisArg, [argsArray])</li>
<li>call(thisArg, arg1, arg2, …)</li>
</ul>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var <span class="keyword">user</span> = &#123;</div><div class="line">    greet: <span class="string">"Hello!"</span>,</div><div class="line">    greetUser: function(<span class="keyword">user</span>Name) &#123;        console.<span class="keyword">log</span>(this.greet + <span class="string">" "</span> + <span class="keyword">user</span>Name);</div><div class="line">    &#125;</div><div class="line">&#125;;var greet1 = &#123;</div><div class="line">    greet: <span class="string">"Hola"</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">user</span>.greetUser.call(greet1, <span class="string">"Rahul"</span>); // 输出<span class="string">"Hola Rahul"</span><span class="keyword">user</span>.greetUser.apply(greet1, [<span class="string">"Rahul"</span>]); // 输出<span class="string">"Hola Rahul"</span></div></pre></td></tr></table></figure>
<p>使用bind方法，可以为函数绑定this值，然后作为一个新的函数返回：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> user = &#123;</div><div class="line">     <span class="attr">greet</span>: <span class="string">"Hello!"</span>,</div><div class="line">     <span class="attr">greetUser</span>: <span class="function"><span class="keyword">function</span>(<span class="params">userName</span>) </span>&#123;     <span class="built_in">console</span>.log(<span class="keyword">this</span>.greet + <span class="string">" "</span> + userName);</div><div class="line">     &#125;</div><div class="line">&#125;;<span class="keyword">var</span> greetHola = user.greetUser.bind(&#123;<span class="attr">greet</span>: <span class="string">"Hola"</span>&#125;);<span class="keyword">var</span> greetBonjour = user.greetUser.bind(&#123;<span class="attr">greet</span>: <span class="string">"Bonjour"</span>&#125;);</div><div class="line"></div><div class="line">greetHola(<span class="string">"Rahul"</span>) <span class="comment">// 输出"Hola Rahul"greetBonjour("Rahul") // 输出"Bonjour Rahul"</span></div></pre></td></tr></table></figure></p>
<h3 id="9-Memoization"><a href="#9-Memoization" class="headerlink" title="9. Memoization"></a>9. Memoization</h3><p>Memoization用于优化比较耗时的计算，通过将计算结果缓存到内存中，这样对于同样的输入值，下次只需要中内存中读取结果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoizeFunction</span>(<span class="params">func</span>)</span>&#123;    <span class="keyword">var</span> cache = &#123;&#125;;    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)    </span>&#123;        <span class="keyword">var</span> key = <span class="built_in">arguments</span>[<span class="number">0</span>];        <span class="keyword">if</span> (cache[key])</div><div class="line">        &#123;            <span class="keyword">return</span> cache[key];</div><div class="line">        &#125;        <span class="keyword">else</span></div><div class="line">        &#123;            <span class="keyword">var</span> val = func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">            cache[key] = val;            <span class="keyword">return</span> val;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;<span class="keyword">var</span> fibonacci = memoizeFunction(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;    <span class="keyword">return</span> (n === <span class="number">0</span> || n === <span class="number">1</span>) ? n : fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</div><div class="line">&#125;);<span class="built_in">console</span>.log(fibonacci(<span class="number">100</span>)); <span class="comment">// 输出354224848179262000000console.log(fibonacci(100)); // 输出354224848179262000000</span></div></pre></td></tr></table></figure></p>
<p>代码中，第2次计算fibonacci(100)则只需要在内存中直接读取结果。</p>
<h3 id="10-函数重载"><a href="#10-函数重载" class="headerlink" title="10. 函数重载"></a>10. 函数重载</h3><p>所谓函数重载(method overloading)，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉，函数重载可以通过if…else或者switch实现，这就不去管它了。jQuery之父John Resig提出了一个非常巧(bian)妙(tai)的方法，利用了闭包。</p>
<p>从效果上来说，people对象的find方法允许3种不同的输入: 0个参数时，返回所有人名；1个参数时，根据firstName查找人名并返回；2个参数时，根据完整的名称查找人名并返回。</p>
<p>难点在于，people.find只能绑定一个函数，那它为何可以处理3种不同的输入呢？它不可能同时绑定3个函数find0,find1与find2啊！这里的关键在于old属性。</p>
<p>由addMethod函数的调用顺序可知，people.find最终绑定的是find2函数。然而，在绑定find2时，old为find1；同理，绑定find1时，old为find0。3个函数find0,find1与find2就这样通过闭包链接起来了。</p>
<p>根据addMethod的逻辑，当f.length与arguments.length不匹配时，就会去调用old，直到匹配为止。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">function addMethod(object, name, f)&#123;　　    <span class="built_in">var</span> old = object[name];　　</div><div class="line">    object[name] = function()    &#123;        // f.<span class="built_in">length</span>为函数定义时的参数个数</div><div class="line">        // arguments.<span class="built_in">length</span>为函数调用时的参数个数　　　　</div><div class="line">        <span class="keyword">if</span> (f.<span class="built_in">length</span> === arguments.<span class="built_in">length</span>)</div><div class="line">        &#123;　　            <span class="built_in">return</span> f.<span class="built_in">apply</span>(this, arguments);　　　　</div><div class="line">        &#125;        <span class="keyword">else</span> <span class="keyword">if</span> (typeof old === <span class="string">"function"</span>)</div><div class="line">        &#123;            <span class="built_in">return</span> old.<span class="built_in">apply</span>(this, arguments);　　　　</div><div class="line">        &#125;　　</div><div class="line">    &#125;;</div><div class="line">&#125;// 不传参数时，返回所有namefunction find0()&#123;　　    <span class="built_in">return</span> this.names;</div><div class="line">&#125;// 传一个参数时，返回firstName匹配的namefunction find1(firstName)&#123;　　    <span class="built_in">var</span> result = [];　　    <span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">0</span>; i &lt; this.names.<span class="built_in">length</span>; i++)</div><div class="line">    &#123;　　　　        <span class="keyword">if</span> (this.names[i].indexOf(firstName) === <span class="number">0</span>)</div><div class="line">        &#123;　　　　　　</div><div class="line">            result.<span class="built_in">push</span>(this.names[i]);　　　　</div><div class="line">        &#125;　　</div><div class="line">    &#125;　　    <span class="built_in">return</span> result;</div><div class="line">&#125;// 传两个参数时，返回firstName和lastName都匹配的namefunction find2(firstName, lastName)&#123;　    <span class="built_in">var</span> result = [];　　    <span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">0</span>; i &lt; this.names.<span class="built_in">length</span>; i++)</div><div class="line">    &#123;　　　　        <span class="keyword">if</span> (this.names[i] === (firstName + <span class="string">" "</span> + lastName))</div><div class="line">        &#123;　　　　　　</div><div class="line">            result.<span class="built_in">push</span>(this.names[i]);　　　　</div><div class="line">        &#125;　　</div><div class="line">    &#125;　　    <span class="built_in">return</span> result;</div><div class="line">&#125;<span class="built_in">var</span> people = &#123;　　</div><div class="line">    names: [<span class="string">"Dean Edwards"</span>, <span class="string">"Alex Russell"</span>, <span class="string">"Dean Tom"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">addMethod(people, <span class="string">"find"</span>, find0);</div><div class="line">addMethod(people, <span class="string">"find"</span>, find1);</div><div class="line">addMethod(people, <span class="string">"find"</span>, find2);console.<span class="built_in">log</span>(people.find()); // 输出[<span class="string">"Dean Edwards"</span>, <span class="string">"Alex Russell"</span>, <span class="string">"Dean Tom"</span>]console.<span class="built_in">log</span>(people.find(<span class="string">"Dean"</span>)); // 输出[<span class="string">"Dean Edwards"</span>, <span class="string">"Dean Tom"</span>]console.<span class="built_in">log</span>(people.find(<span class="string">"Dean"</span>, <span class="string">"Edwards"</span>)); // 输出[<span class="string">"Dean Edwards"</span>]</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-立即执行函数&quot;&gt;&lt;a href=&quot;#1-立即执行函数&quot; class=&quot;headerlink&quot; title=&quot;1. 立即执行函数&quot;&gt;&lt;/a&gt;1. 立即执行函数&lt;/h3&gt;&lt;p&gt;立即执行函数，即Immediately Invoked Function Expression (IIFE)，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;     &lt;span class=&quot;comment&quot;&gt;// 代码&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// ...&amp;#125;)();&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;function(){…}是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。立即执行函数也可以理解为立即调用一个匿名函数。立即执行函数最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>promise-then</title>
    <link href="http://yoursite.com/2017/09/04/promise-then/"/>
    <id>http://yoursite.com/2017/09/04/promise-then/</id>
    <published>2017-09-04T07:54:26.000Z</published>
    <updated>2018-02-27T01:10:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Promise可以写成方法链的形式"><a href="#Promise可以写成方法链的形式" class="headerlink" title="Promise可以写成方法链的形式"></a>Promise可以写成方法链的形式</h4><p>在promise里可以将任意个方法连在一起作为一个方法链（method chain）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">aPromise.then(function taskA(value)&#123;</div><div class="line">    //task A</div><div class="line">&#125;).then(function taskB(value)&#123;</div><div class="line">    //taskB</div><div class="line">&#125;).catch(function onRejected(error)&#123;</div><div class="line">    console.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>如果把在then中注册的每个回调函数成为task的话，那么我们就可以通过Promise方法链方式来编写能以taskA-&gt;taskB这种流程进行处理的逻辑了。<br>Promise方法链这种叫法有点长，因此简化为promise chain。<br>Promise之所以适合编写异步处理较多的应用，promise chain可以算得上是其中一个原因。</p>
<h4 id="Promise-chain"><a href="#Promise-chain" class="headerlink" title="Promise chain"></a>Promise chain</h4><p>promise-then-catch-flow.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function taskA()&#123;</div><div class="line">    console.log(&apos;taskA&apos;);</div><div class="line">&#125;</div><div class="line">function taskB()&#123;</div><div class="line">    console.log(&apos;taskB&apos;);</div><div class="line">&#125;</div><div class="line">function onRejected(error)&#123;</div><div class="line">    console.log(&apos;Catch Error A or B&apos;,error);</div><div class="line">&#125;</div><div class="line">function finalTask()&#123;</div><div class="line">    console.log(&apos;Final Task&apos;);</div><div class="line">&#125;</div><div class="line">var promise=Promisr resolve();</div><div class="line">promise</div><div class="line">    .then(taskA)</div><div class="line">    .then(taskB)</div><div class="line">    .catch(onRejected)</div><div class="line">    .then(finalTask);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Promise可以写成方法链的形式&quot;&gt;&lt;a href=&quot;#Promise可以写成方法链的形式&quot; class=&quot;headerlink&quot; title=&quot;Promise可以写成方法链的形式&quot;&gt;&lt;/a&gt;Promise可以写成方法链的形式&lt;/h4&gt;&lt;p&gt;在promise里可
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>实战promise</title>
    <link href="http://yoursite.com/2017/09/04/%E5%AE%9E%E6%88%98promise/"/>
    <id>http://yoursite.com/2017/09/04/实战promise/</id>
    <published>2017-09-04T06:13:33.000Z</published>
    <updated>2017-09-04T07:40:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h3><p>一般情况我们会使用new Promise()来创建promise对象，但除此之外我们也可使用其他方法。<br>在这里，我们将会学习如何使用 Promise.resolve和Promise.reject这两个方法。</p>
<h3 id="new-Promise的快捷方式"><a href="#new-Promise的快捷方式" class="headerlink" title="new Promise的快捷方式"></a>new Promise的快捷方式</h3><p>静态方法Promise.resolve(value)可以认为是new Promise()方法的快捷方式。<br>比如Promise.resolve(42);可以认为是以下代码的语法糖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new Promise(function(resolve)&#123;</div><div class="line">    resolve(42);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>在这段代码中的resolve(42)；会让这个promise对象立即进入确定(即resolved）状态，并将42传递给后面then里所指定的onFulfilled函数。</p>
<p>方法Promise.resolve(value);的返回值也是一个promise对象，所以我们可以像下面那样接着对其返回值进行.then调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Promise.resolve(42).then(function(value)&#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Promise.resolve作为new Promise()的快捷方式，在进行promise对象的初始化或者编写测试代码的时候都非常方便。</p>
<h3 id="Thenable"><a href="#Thenable" class="headerlink" title="Thenable"></a>Thenable</h3><p>Promise.resolve方法另一个作用就是将thenable对象转换为promise对象。<br>ES6 Promise里提到了Thenable这个概念，简单来说它就是一个非常类似promise的东西。<br>就像我们有时称具有.length方法的非数组对象为Array like一样，thenable指的是一个具有.then方法的对象。</p>
<p>这种将thenable对象转换为promise对象的机制要求thenable对象所拥有的then方法应该和Promise所拥有的then方法具有同样的功能<br>和处理过程，在将thenable对象转换为promise对象的时候，还会巧妙利用thenable对象原来具有的then方法。</p>
<p>到底什么样的对象能算是thenable的呢，最简单的例子就是JQuery.ajax()，它的返回值就是thenable的。</p>
<p>因为JQuery.ajax()的返回值是jqXHR Object对象，这个对象具有.then方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$.ajax(&apos;/json/comment.json&apos;); //=&gt;拥有&apos;.then&apos;方法的对象</div></pre></td></tr></table></figure>
<p>这个thenable的对象可以使用Promise.resolve来转换为一个promise对象。<br>编程了promise对象的话，就能直接使用then或者catch等这些在ES6 Promise里定义的方法了。</p>
<h3 id="将-thenable对象转换promise对象"><a href="#将-thenable对象转换promise对象" class="headerlink" title="将 thenable对象转换promise对象"></a>将 thenable对象转换promise对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var promise = Promise.resolve($ajax(&apos;/json/comment.json&apos;)); //=&gt;peomise对象</div><div class="line">promise.then(function(value)&#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h4 id="jQuery-和-thenable"><a href="#jQuery-和-thenable" class="headerlink" title="jQuery 和 thenable"></a>jQuery 和 thenable</h4><p>jquery.ajax()返回的值是一个具有.then方法的jqXHR Object对象，这个对象继承了来自Deferred Object的方法和属性。</p>
<p>但是Deferred Object并没有遵循Promises/A+或 ES6 Promise标准，所以即使看上去这个对象转换成了一个Promise对象，<br>但是会出现缺失部分信息的问题。</p>
<p>这个问题的根源在于jquery的Deferred Object的then方法机制与promise不同。</p>
<p>所以我们应该注意，即使一个对象具有.then方法，也不一定就能作为ES6 Promise对象使用。</p>
<p>Promise.resolve只使用了共同的方法then,提供了在不同的类库之间进行promise对象互相转换的功能。</p>
<p>这种转换为thenable的功能在之前是通过使用Promise.cast来完成的，从它的名字我们也不难想象它的功能是什么。<br>除了在编写使用Promise的类库等软件时需要对Thenable有所了解之外，通常作为end-user使用的时候，我们可能不会用到此功能。</p>
<p>总结：<br>Promise.resolve方法，可以认为它的作用就是将传递给它的参数填充(Fulfilled)到Promise对象后并返回这个promise对象。<br>此外，promise的很多处理内部也是使用了Promise.resolve算法将值转换为promise对象后再进行处理的。</p>
<h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h3><p>Promise.reject(error)是何Promise.resolve(value)类似的静态方法，是new Promise()方法的快捷方式。<br>比如Promise.reject(new Error(‘出错了’))就是下面代码的语法糖形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new Promise(function(resolve,reject)&#123;</div><div class="line">    reject(new Error(&apos;出错了&apos;));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这段代码的功能是调用该promise对象通过then指定的onRejected函数，并将错误（Error）对象传递给这个onRejected函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Promise.reject(new Error(&apos;BOOM&apos;)).catch(function(error)&#123;</div><div class="line">    console.log(error);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>它和Promise.resolve(value)的不同之处在于promise内调用的函数时候reject而不是resolve,这在编写测试代码或者进行debug时，说不定会用的上。</p>
<h3 id="Promise只能进行异步操作吗"><a href="#Promise只能进行异步操作吗" class="headerlink" title="Promise只能进行异步操作吗"></a>Promise只能进行异步操作吗</h3><p>在使用Promise.resolve(value)等方法的时候，如果promise对象立刻就能进入resolve状态的话，那么你是不是觉得.then里面指定的方法就是同步调用的呢？</p>
<p>实际上，.then中指定的方法调用异步进行的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var promise = new Promise(function(resolve)&#123;</div><div class="line">    console.log(&apos;inner promise&apos;); //1</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div><div class="line">promise.then(function(value)&#123;</div><div class="line">    console.log(value); //3</div><div class="line">&#125;);</div><div class="line">console.log(&apos;outer promise&apos;); //2</div></pre></td></tr></table></figure></p>
<p>执行上面的代码会输出下面的log,从这些log我们清楚地知道了上面的代码的执行顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">inner promise //1</div><div class="line">outer promise //2</div><div class="line">42            //3</div></pre></td></tr></table></figure></p>
<p>由于JavaScript代码会按照文件的从上到下的顺序执行,所以最开始 <1> 会执行,然 后是 被执行。这时候 promise 对象的已经变为确定状态,FulFilled被设置 为了 。<br>下面的代码 promise.then 注册了 <3> 这个回调函数,这是本专栏的焦点问题。<br>由于 promise.then 执行的时候promise对象已经是确定状态,从程序上说对回调函数进<br>行同步调用也是行得通的。<br>但是即使在调用 promise.then 注册回调函数的时候promise对象已经是确定的状 态,Promise也会以异步的方式调用该回调函数,这是在Promise设计上的规定方针。<br>因此 <2> 会最先被调用,最后才会调用回调函数 <3> 。 为什么要对明明可以以同步方式进行调用的函数,非要使用异步的调用方式呢?</3></2></3></1></p>
<h3 id="同步调用和异步调用同事存在导致的混乱"><a href="#同步调用和异步调用同事存在导致的混乱" class="headerlink" title="同步调用和异步调用同事存在导致的混乱"></a>同步调用和异步调用同事存在导致的混乱</h3><p>其实在Promise之外也存在这个问题，这里我们以一般的使用情况来考虑此问题。<br>这个问题的本质是接收回调函数的函数，会根据具体的执行情况，可以选择是以同步还是异步的方式对回调函数进行调用。<br>下面我们以onReady(fn）为例进行说明，这个函数会接收一个回调函数进行处理。</p>
<p>mixed-onready.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function onReady(fn)&#123;</div><div class="line">    var readyState=document.readyStaye;</div><div class="line">    if(readyState===&apos;interactive&apos; || readyStaye===&apos;complete&apos;)&#123;</div><div class="line">        fn();</div><div class="line">    &#125;else&#123;</div><div class="line">        window.addEventListener(&apos;DOMContentLoaded&apos;,fn);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">onReady(function()&#123;</div><div class="line">    console.log(&apos;DOM fully loaded and parsed&apos;);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;==Starting==&apos;);</div></pre></td></tr></table></figure></p>
<p>mixed-onready.js会根据执行时DOM是否已经装载完毕来决定是对回调函数进行同步调用还是异步调用。<br>如果在调用onReady之前DOM已经载入的话，对回调函数进行同步调用<br>如果在调用onReady之前DOM还没有载入的话，通过注册DOMContentLoaded事件监听器来对回调函数进行异步调用<br>因此，如果这段代码在原文件中出现的位置不同，在控制台上打印的log消息顺序也会不同。<br>为了解决这个问题，我们可以选择统一使用异步调用的方式。</p>
<p>async-onready.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function onReady(fn)&#123;</div><div class="line">    var readyState=document.readyState;</div><div class="line">    if(readyState===&apos;interactive&apos;||readyState===&apos;complete&apos;)&#123;</div><div class="line">        setTimeout(fn,0);</div><div class="line">    &#125;else&#123;</div><div class="line">        window.addEventListener(&apos;DOMContentLoaded&apos;,fn);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">onReady(function()&#123;</div><div class="line">    console.log(&apos;DOM fully loaded parsed&apos;);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;==Starting==&apos;);</div></pre></td></tr></table></figure></p>
<h4 id="不要对异步回调函数进行同步调用"><a href="#不要对异步回调函数进行同步调用" class="headerlink" title="不要对异步回调函数进行同步调用"></a>不要对异步回调函数进行同步调用</h4><ul>
<li>绝对不能对异步回调函数（即使在数据已经就绪）进行同步调用。</li>
<li>如果对异步回调函数进行同步调用的话，处理顺序可能会与预期不符，可能带来意料之外的后果。</li>
<li>对异步毁掉函数进行同步调用，还可能导致栈溢出或异常处理错误等问题</li>
<li>如果想在将来某时刻调用异步回调函数的话，可以使用setTimeout等一部API。</li>
</ul>
<p>前面我们看到的promise.then也属于此类，为了避免上述中同时使用同步、异步调用可能引起的混乱问题，Promise在规范上规定Promise只能使用异步调用方式。<br>最后，如果将上面的onReady函数用Promise重写的话，代码如下：</p>
<p>onready-as-promise.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function onReadyPromise()&#123;</div><div class="line">    return new Promise(function(resolve,reject)&#123;</div><div class="line">        var readyState= document.readyState;</div><div class="line">        if(readyState===&apos;interactive&apos;||readyState===&apos;complete&apos;)&#123;</div><div class="line">            resolve();</div><div class="line">        &#125;else&#123;</div><div class="line">            window.addEventListener(&apos;DOMContentLoaded&apos;,resolve);</div><div class="line">        &#125;</div><div class="line">     &#125;);</div><div class="line">&#125;</div><div class="line">onReadyPromise().then(function()&#123;</div><div class="line">    console.log(&apos;DOM fully loaded and parsed&apos;);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;==Starting==&apos;);</div></pre></td></tr></table></figure></p>
<p>由于Promise保证了每次调用都以异步方式进行，所以我们在实际编码中不需要调用setTimeout 来自己实现异步调用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Promise-resolve&quot;&gt;&lt;a href=&quot;#Promise-resolve&quot; class=&quot;headerlink&quot; title=&quot;Promise.resolve&quot;&gt;&lt;/a&gt;Promise.resolve&lt;/h3&gt;&lt;p&gt;一般情况我们会使用new Promise()来创建promise对象，但除此之外我们也可使用其他方法。&lt;br&gt;在这里，我们将会学习如何使用 Promise.resolve和Promise.reject这两个方法。&lt;/p&gt;
&lt;h3 id=&quot;new-Promise的快捷方式&quot;&gt;&lt;a href=&quot;#new-Promise的快捷方式&quot; class=&quot;headerlink&quot; title=&quot;new Promise的快捷方式&quot;&gt;&lt;/a&gt;new Promise的快捷方式&lt;/h3&gt;&lt;p&gt;静态方法Promise.resolve(value)可以认为是new Promise()方法的快捷方式。&lt;br&gt;比如Promise.resolve(42);可以认为是以下代码的语法糖。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;new Promise(function(resolve)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    resolve(42);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>promise详解</title>
    <link href="http://yoursite.com/2017/09/04/promise%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/09/04/promise详解/</id>
    <published>2017-09-04T02:00:00.000Z</published>
    <updated>2017-09-04T06:08:11.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是promise"><a href="#什么是promise" class="headerlink" title="什么是promise?"></a>什么是promise?</h3><p>Promise是抽象异步处理对象以及对其进行各种操作的组件。<br>Promise最初被提出是在E语言中，它是基于并列/并行处理设计的一种编程语言。<br>现在Javascript也拥有了这种特性，这就是要介绍的javascript Promise。<br>如果说到基于javascript的异步处理，大多数都会想到利用回调函数。<br>使用了回调函数的异步处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">getAsync(&quot;fileA.txt&quot;,function(error,result)&#123;</div><div class="line">    if(error)&#123; //取得失败时的处理</div><div class="line">        throw error;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //取得成功时的处理</div><div class="line">    </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>传给回调函数的参数为（error对象，执行结果）组合。<br>Node.js等则规定在javascript的回调函数的第一个参数为Error的对象，这也是它的一个惯例。</p>
<p>像上面这样基于回调函数的异步处理如果统一参数使用规则的话，写法也会很明了。<br>但是，这也仅是编码规约而已，即使采用不同的写法依然不会出错。</p>
<p>而promise则是把类似的异步处理对象和处理规则进行规范化，并按照采用统一的接口来编写，<br>而采取规定方法之外的写法都会出错。</p>
<p>下面使用了Promise进行异步处理的一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var promise = getAsyncPromise(&quot;fileA.txt&quot;);</div><div class="line">promise.then(function(result)&#123;</div><div class="line">    //获取文件内容成功时的处理</div><div class="line">&#125;).catch(function(error)&#123;</div><div class="line">    //获取文件内容失败时的处理</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>返回promise对象</p>
<p>我们可以向这个预设了抽象化异步处理的promise对象，注册这个promise对象执行成功时和失败时相应的回调函数。</p>
<p>这和回调函数方式相比有哪些不同之处呢? 在使用promise进行一步处理的时候,我们 必须按照接口规定的方法编写处理代码。</p>
<p>也就是说,除promise对象规定的方法(这里的 then 或 catch )以外的方法都是不可以使 用的, 而不会像回调函数方式那样可以自己自由的定义回调函数的参数,而必须严格 遵守固定、统一的编程方式来编写代码。</p>
<p>这样,基于Promise的统一接口的做法, 就可以形成基于接口的各种各样的异步处理模式。<br>所以,promise的功能是可以将复杂的异步处理轻松地进行模式化, 这也可以说得上是 使用promise的理由之一。</p>
<h3 id="Promise简介"><a href="#Promise简介" class="headerlink" title="Promise简介"></a>Promise简介</h3><p>在es6 Promise标准中定义的API还不是很多。<br>目前大致有以下三种类型</p>
<h4 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h4><p>Promise类似于XMLHttpRequest，从构造函数Promise来创建一个新promise对象作为接口。<br>要想创建一个promise对象，可以使用new来调用Promise的构造器来进行实例化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise =<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">    <span class="comment">//异步处理</span></div><div class="line">    <span class="comment">//处理结束后、调用resolve或reject</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h4 id="Instance-Method"><a href="#Instance-Method" class="headerlink" title="Instance Method"></a>Instance Method</h4><p>对通过new生成的promise对象为了设置其值在resolve(成功)/reject（失败）时调用的回调函数可以使用<br>promise.then()实例方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise.then(onFulfilled,onRejected)</div></pre></td></tr></table></figure>
<p>resolve(成功)时<br>    onFulfilled会被调用<br>reject(失败)时<br>    onRejected会被调用<br>onFulfilled、onRejected两个都为可选参数。</p>
<p>promise.then成功和失败时都可以使用。另外在想对异常进行处理时可以采用<br>promise.then(undefined,onRejected)这种方式，只指定reject时的回调函数即可。<br>不过这种情况下promise.catch(onRejected)应该是个更好的选择。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise.catch(onRejected)</div></pre></td></tr></table></figure>
<h4 id="Static-Method"><a href="#Static-Method" class="headerlink" title="Static Method"></a>Static Method</h4><p>像promise这样全局对象还拥有一些静态方法。<br>包括promise.all()还有Promise.resolve()等在内，主要都是一些对Promise进行操作的辅助方法。</p>
<h3 id="Promise-workflow"><a href="#Promise-workflow" class="headerlink" title="Promise workflow"></a>Promise workflow</h3><p>promise-workflow.js</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span><span class="params">()</span>&#123;</span></div><div class="line">    <span class="keyword">return</span> new Promise(<span class="function"><span class="keyword">function</span><span class="params">(resolve,reject)</span>&#123;</span></div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></div><div class="line">            resolve(<span class="string">'Async Hello world'</span>);</div><div class="line">        &#125;,<span class="number">16</span>);</div><div class="line">    &#125;)   </div><div class="line">&#125;</div><div class="line"></div><div class="line">asyncFunction().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(value)</span>&#123;</span></div><div class="line">    console.<span class="built_in">log</span>(value);  <span class="comment">//=&gt; 'Async Hello world'</span></div><div class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(error)</span>&#123;</span></div><div class="line">    console.<span class="built_in">log</span>(<span class="built_in">error</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>new Promise构造器之后，会返回一个promise对象<br>为Promise对象用设置 .then调用返回值时的回调函数。<br>asyncFunction 这个函数会返回promise对象，对于这个promised对象，我们调用它的then方法<br>来设置resolve的回调函数，catch方法来设置发生错误时的回调函数。</p>
<p>该promise对象会在setTimeout之后的16ms时被resolve，这时then的回调函数会被调用，并输出’Async Hello world’。<br>在这种情况下catch的回调函数并不会被执行（因为promise返回了resolve）,不过如果运行环境<br>没用提供setTimeout函数的话，那么上面代码在执行中就会产生异常，在catch中设置的回调函数就会被执行。</p>
<p>像promise.then(onFulFilled,onRejected)的方法声明一样，如果不使用catch方法的话，如下所示的代码也能完成相同的工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">asyncFunction().then(function(value)&#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;,function(error)&#123;</div><div class="line">    console.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Promise的状态"><a href="#Promise的状态" class="headerlink" title="Promise的状态"></a>Promise的状态</h3><p>用new Promise实例化的promise对象有以下三个状态。</p>
<p>“has-resolution”-Fulfilled<br>    resolve(成功)时。此时会调用onFulfilled</p>
<p>“has-rejection”-Rejected<br>    reject(失败)时。此时会调用onRejected</p>
<p>“unresolved”-Pending<br>    既不是resolve也不是reject状态。也就是promise对象刚被创建后的初始化状态等</p>
<p>Promise对象的状态，从pending转换为Fulfilled或Rejected之后，这个promise对象的状态就不会再发生任何变化。</p>
<p>promise与event等不同，在.then后执行的函数可以肯定地说只会被调用一次。<br>另外，Fulfilled和Rejected这两个中的任一状态都可以表示为settled(不变的)。</p>
<p>Settled<br>    resolve(成功)或 reject(失败)</p>
<pre><code>从Pending和Settled的对称关系来看,Promise状态的种类/迁移是非常简单易懂的。 当promise的对象状态发生变化时,用 .then 来定义只会被调用一次的函数。
</code></pre><h3 id="编写Promise代码"><a href="#编写Promise代码" class="headerlink" title="编写Promise代码"></a>编写Promise代码</h3><h4 id="创建promise对象"><a href="#创建promise对象" class="headerlink" title="创建promise对象"></a>创建promise对象</h4><p>创建promise对象的流程如下所示。</p>
<ol>
<li>new Promise(fn)返回一个promise对象</li>
<li><p>在fn 中指定异步等处理</p>
<ul>
<li>处理结果正常的话，调用resolve(处理结果值)</li>
<li>处理结果错误的话，调用reject(error对象)</li>
</ul>
</li>
</ol>
<p>我们的任务是用Promise来通过异步处理方式来获取XMLHttpRequest(XHR)的数据。</p>
<h4 id="创建XHR的promise对象"><a href="#创建XHR的promise对象" class="headerlink" title="创建XHR的promise对象"></a>创建XHR的promise对象</h4><p>首先，创建一个用Promise把XHR处理包装起来的名为getURL的函数。</p>
<p>xhr-promise.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function getURL(URL)&#123;</div><div class="line">    return new Promise(function(resolve,reject)&#123;</div><div class="line">        var req=new XMLHttpRequest();</div><div class="line">        req.open(&apos;GET&apos;,URL,true);</div><div class="line">        req.onload=function()&#123;</div><div class="line">            if(req.status===200)&#123;</div><div class="line">                resolve(req.responseText);</div><div class="line">            &#125;else&#123;</div><div class="line">                reject(new Error(req.statusText));</div><div class="line">            &#125;</div><div class="line">         &#125;;</div><div class="line">         req.onerror=function()&#123;</div><div class="line">            reject(new Error(req.statusText));</div><div class="line">         &#125;;</div><div class="line">         req.send();</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">//运行示例</div><div class="line">var URL=&quot;http://httpbin.org/get&quot;;</div><div class="line">getURL(URL).then(function onFulfilled(value)&#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;).catch(function onRejected(error)&#123;</div><div class="line">    console.error(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>getURL只有在通过XHR取得结果状态为200时才会调用resolve-也就是只有数据取得成功时，而其他情况（取得失败）<br>时则会调用reject方法。<br>resolve(req.responseText)在response的内容中加入了参数。<br>resolve方法的参数并内有特别的规则。基本上把要传给回调函数参数放进去就可以了。（then方法可以接收到这个参数值）<br>熟悉nondejs的人，经常会在写回调函数时将callback(error,response)的第一个参数设为error对象，而在Promise中resolve/reject则担当了这个职责（处理正常和异常的情况)，<br>所以在resolve方法中只传一个response参数是没有问题的。</p>
<h4 id="reject函数"><a href="#reject函数" class="headerlink" title="reject函数"></a>reject函数</h4><p>XHR中onerror事件触发的时候就是发生错误时，所以理所当然调用reject。<br>发生错误时要像这样reject(new Error(req.statusText));,创建一个Error对象后再将具体的值传进去。<br>传给reject的参数也没有什么特殊的限制，一般只要是error对象(获取继承自error对象)就可以。</p>
<p>传给reject的参数，其中一般是包含了reject原因的error对象。本次因为状态值不等于200而被reject,<br>所以reject中放入的是statusText。（这个参数的值可以被then方法的第二个参数或者catch方法中使用）</p>
<h3 id="编写promise对象处理方法"><a href="#编写promise对象处理方法" class="headerlink" title="编写promise对象处理方法"></a>编写promise对象处理方法</h3><p>让我们在实际中使用以下刚才创建的返回promise对象的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getURL(&apos;http://example.com/&apos;); =&gt;返回promise对象</div></pre></td></tr></table></figure>
<p>如果promises overview中做的简单介绍一样，promise对象拥有几个实例方法，我们使用这些<br>实例方法来为promise对象创建依赖于promise的具体状态，并且只会被执行一次的回调函数。</p>
<p>为promise对象添加处理方法主要有以下两种：</p>
<ul>
<li>promise对象被resolve时的处理 （onFulfilled）</li>
<li>promise对象被reject时的处理（onRejected）</li>
</ul>
<h3 id="promise-value-flow"><a href="#promise-value-flow" class="headerlink" title="promise value flow"></a>promise value flow</h3><p>首页，我们来尝试一下为getURL通信成功并取到值时添加的处理函数。<br>此时所谓的通信成功，指的就是在被resolve后，promise对象变为Fulfilled状态。<br>被resolve后的处理，可以在.then方法中传入想要的调用的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var URL=&quot;http://httpbin.org/get&quot;;</div><div class="line">getURL(URL).then(function onFulfilled(value)&#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>为了方便理解我们把函数命名为onFulfilled<br>getURL函数中的resolve(req.responseText);会将promise对象变为resolve(Fulfilled)状态，同时使用其<br>值调用onFulfilled函数。<br>不过目前我们还没有对其中可能发生的错误做任何处理，接下来，我们就来为getURL函数添加发生错误时的异常处理。<br>此时，发生错误，指的也就是reject后promise对象变为Rejected状态。</p>
<p>被reject后的处理，可以在 .then 的第二个参数 或者是在 .catch 方法中设置想要调用的 函数。</p>
<p>把下面reject时的处理加入到刚才的代码，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var URL=&quot;http://httpbin.org/status/500&quot;;</div><div class="line">getURL(URL).then(function onFulfilled(value)&#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;).catch(function onRejected(error)&#123;</div><div class="line">  console.error(error);  </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>服务端返回的状态码为500<br>为了方便理解函数被命名为onRejected<br>在getURL的处理中发生任何异常，或者被明确reject的情况下，该异常原因（Error对象）会作为<br>.catch方法的参数被调用。<br>其实.catch只是promise.then(undefined,onRejected)的别名而已。如下代码也可以完成同样的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getURL(URL).then(onFulfilled,onRejected);</div></pre></td></tr></table></figure>
<p>onFulfilled,onRejected是和刚才相同的函数<br>一般来说，使用.catch来将resolve和reject处理分开来写是比较推荐的做法,这两者的区别会在then<br>和 catch的区别中再做详细介绍。</p>
<p>总结：</p>
<ul>
<li><p>用new Promise方法创建promise对象</p>
</li>
<li><p>用 .then 或 .catch添加promise对象的处理函数</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是promise&quot;&gt;&lt;a href=&quot;#什么是promise&quot; class=&quot;headerlink&quot; title=&quot;什么是promise?&quot;&gt;&lt;/a&gt;什么是promise?&lt;/h3&gt;&lt;p&gt;Promise是抽象异步处理对象以及对其进行各种操作的组件。&lt;br&gt;Promise最初被提出是在E语言中，它是基于并列/并行处理设计的一种编程语言。&lt;br&gt;现在Javascript也拥有了这种特性，这就是要介绍的javascript Promise。&lt;br&gt;如果说到基于javascript的异步处理，大多数都会想到利用回调函数。&lt;br&gt;使用了回调函数的异步处理：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;getAsync(&amp;quot;fileA.txt&amp;quot;,function(error,result)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    if(error)&amp;#123; //取得失败时的处理&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        throw error;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //取得成功时的处理&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>KOA实战</title>
    <link href="http://yoursite.com/2017/08/16/koa%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2017/08/16/koa实战/</id>
    <published>2017-08-15T16:00:00.000Z</published>
    <updated>2017-09-04T08:11:43.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><ul>
<li>yarn官网：<a href="https://yarnpkg.com/" target="_blank" rel="external">https://yarnpkg.com/</a></li>
<li>安装yarn: npm install yarn -g</li>
</ul>
<h3 id="先搭整体页面结构"><a href="#先搭整体页面结构" class="headerlink" title="先搭整体页面结构"></a>先搭整体页面结构</h3><h4 id="1、搭建整体结构"><a href="#1、搭建整体结构" class="headerlink" title="1、搭建整体结构"></a>1、搭建整体结构</h4><p>备注：【简述各个目录下的作用】</p>
<ol>
<li>conf 是放置相关配置；</li>
<li>controllers放置路由模块；</li>
<li>midware 是放置中间件；</li>
<li>node_modules是放置下载的模块；</li>
<li>public下是放置静态资源；</li>
<li>views是放置模板；</li>
<li>models放置与数据打交道的模块；</li>
<li>添加启动文件 app.js；</li>
</ol>
<a id="more"></a>
<h4 id="2、创建配置文件-yarn-init"><a href="#2、创建配置文件-yarn-init" class="headerlink" title="2、创建配置文件 yarn init"></a>2、创建配置文件 yarn init</h4><p>（1）执行命令如下所示：<br><img src="http://note.youdao.com/favicon.ico" alt="image"></p>
<p>（2）页面结构如下所示:</p>
<p>（3）这是创建的package.json文件里的内容：</p>
<h4 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h4><p>npm init 创建的配置文件与 yarn init 创建的配置文件唯一的差别就是 npm init创建的配置文件 里多了个scripts；<br>scripts用来集成自定义命令；<br>所以在这里，为yarn init创建的配置文件添加 scripts一项；如下图所示：</p>
<h4 id="3、安装koa2，命令：yarn-add-koa-next，如下图所示："><a href="#3、安装koa2，命令：yarn-add-koa-next，如下图所示：" class="headerlink" title="3、安装koa2，命令：yarn add koa@next，如下图所示："></a>3、安装koa2，命令：yarn add koa@next，如下图所示：</h4><p>（1）执行命令：</p>
<p>（2）下载完后，可以看到在根目录里有这个yarn.lock文件，如下所示：</p>
<h4 id="备注：yarn-lock就是保存了下载的插件的所有信息；当我们删除了模块时，再去下载，那么yarn就会根据这个文件进行下载，这时速度会快很多；因为有缓存；"><a href="#备注：yarn-lock就是保存了下载的插件的所有信息；当我们删除了模块时，再去下载，那么yarn就会根据这个文件进行下载，这时速度会快很多；因为有缓存；" class="headerlink" title="备注：yarn.lock就是保存了下载的插件的所有信息；当我们删除了模块时，再去下载，那么yarn就会根据这个文件进行下载，这时速度会快很多；因为有缓存；"></a>备注：yarn.lock就是保存了下载的插件的所有信息；当我们删除了模块时，再去下载，那么yarn就会根据这个文件进行下载，这时速度会快很多；因为有缓存；</h4><h4 id="4、编写conf目录下的config-js-配置端口，如下图所示："><a href="#4、编写conf目录下的config-js-配置端口，如下图所示：" class="headerlink" title="4、编写conf目录下的config.js,配置端口，如下图所示："></a>4、编写conf目录下的config.js,配置端口，如下图所示：</h4><h4 id="备注：将配置的信息，导出去；"><a href="#备注：将配置的信息，导出去；" class="headerlink" title="备注：将配置的信息，导出去；"></a>备注：将配置的信息，导出去；</h4><h4 id="5、编写app-js，如下图所示："><a href="#5、编写app-js，如下图所示：" class="headerlink" title="5、编写app.js，如下图所示："></a>5、编写app.js，如下图所示：</h4><h4 id="6、此时启动app-js，报错；是因为node不支持es6-所以此时要下载babel去转码，如下图所示："><a href="#6、此时启动app-js，报错；是因为node不支持es6-所以此时要下载babel去转码，如下图所示：" class="headerlink" title="6、此时启动app.js，报错；是因为node不支持es6,所以此时要下载babel去转码，如下图所示："></a>6、此时启动app.js，报错；是因为node不支持es6,所以此时要下载babel去转码，如下图所示：</h4><h3 id="二：配置babel"><a href="#二：配置babel" class="headerlink" title="二：配置babel"></a>二：配置babel</h3><h4 id="1、创建并配置-babelrc文件，如下图所示："><a href="#1、创建并配置-babelrc文件，如下图所示：" class="headerlink" title="1、创建并配置.babelrc文件，如下图所示："></a>1、创建并配置.babelrc文件，如下图所示：</h4><h4 id="2、通过yarn下载-babel-preset-es2015-和-babel-preset-stage-3，命令如下所示："><a href="#2、通过yarn下载-babel-preset-es2015-和-babel-preset-stage-3，命令如下所示：" class="headerlink" title="2、通过yarn下载 babel-preset-es2015 和 babel-preset-stage-3，命令如下所示："></a>2、通过yarn下载 babel-preset-es2015 和 babel-preset-stage-3，命令如下所示：</h4><ul>
<li>yarn add babel-preset-es2015</li>
<li>yarn add babel-preset-stage</li>
<li>安装 babel-cli, 如下图所示：</li>
</ul>
<h4 id="5、windows下局部安装babel模块以后，无法直接使用babel命令，如何解决？"><a href="#5、windows下局部安装babel模块以后，无法直接使用babel命令，如何解决？" class="headerlink" title="5、windows下局部安装babel模块以后，无法直接使用babel命令，如何解决？"></a>5、windows下局部安装babel模块以后，无法直接使用babel命令，如何解决？</h4><p>==备注：创建babel.cmd，并将node .\node_modules\babel-cli\bin\babel.js %*粘贴到该文件里去。==</p>
<h4 id="6、可以在package-json里配置文件，如下图所示："><a href="#6、可以在package-json里配置文件，如下图所示：" class="headerlink" title="6、可以在package.json里配置文件，如下图所示："></a>6、可以在package.json里配置文件，如下图所示：</h4><h4 id="7、输入npm-run-build-编译成功，如下图所示："><a href="#7、输入npm-run-build-编译成功，如下图所示：" class="headerlink" title="7、输入npm run build,编译成功，如下图所示："></a>7、输入npm run build,编译成功，如下图所示：</h4><p>（1）输入命令：</p>
<p>（2）编译后的效果：</p>
<p>备注：此时说明babel可以进行编译文件了；</p>
<h4 id="三：关于路由这块的处理："><a href="#三：关于路由这块的处理：" class="headerlink" title="三：关于路由这块的处理："></a>三：关于路由这块的处理：</h4><h4 id="1、下载第三方路由插件-koa-simple-router-如下图所示："><a href="#1、下载第三方路由插件-koa-simple-router-如下图所示：" class="headerlink" title="1、下载第三方路由插件 koa-simple-router, 如下图所示："></a>1、下载第三方路由插件 koa-simple-router, 如下图所示：</h4><h4 id="2、在controller目录里开始编写路由模块，如下所示："><a href="#2、在controller目录里开始编写路由模块，如下所示：" class="headerlink" title="2、在controller目录里开始编写路由模块，如下所示："></a>2、在controller目录里开始编写路由模块，如下所示：</h4><ol>
<li>这是目录结构：</li>
<li>备注：创建了两个文件，第一个文件是controllerinit.js；第二个文件是indexcontroller.js;</li>
<li>编写文件controllerinit.js里的内容，如下图所示：</li>
<li>编写文件indexcontroller.js里的内容，如下图所示：</li>
</ol>
<h4 id="四：下载插件-koa-swig-和-co模块，如下图所示："><a href="#四：下载插件-koa-swig-和-co模块，如下图所示：" class="headerlink" title="四：下载插件 koa-swig 和 co模块，如下图所示："></a>四：下载插件 koa-swig 和 co模块，如下图所示：</h4><p>1、下载koa-swig, koa-swig的作用是渲染模板, 下载过程如下所示：</p>
<p>2、下载co模块 , co的作用是将generator包一层，替它执行next()，下载过程如下所示:</p>
<p>3、在config文件里配置模板路径，如下所示：</p>
<p>4、在app.js里面koa-swig的模板渲染配置参数，如下所示：</p>
<h4 id="五：接着下载第三方插件-koa-static-指定静态资源路径，配置渲染静态资源，如下图所示："><a href="#五：接着下载第三方插件-koa-static-指定静态资源路径，配置渲染静态资源，如下图所示：" class="headerlink" title="五：接着下载第三方插件 koa-static,  指定静态资源路径，配置渲染静态资源，如下图所示："></a>五：接着下载第三方插件 koa-static,  指定静态资源路径，配置渲染静态资源，如下图所示：</h4><h5 id="1、下载第三方模块-koa-static-如下所示："><a href="#1、下载第三方模块-koa-static-如下所示：" class="headerlink" title="1、下载第三方模块 koa-static,如下所示："></a>1、下载第三方模块 koa-static,如下所示：</h5><h5 id="2、在配置文件config-js里-配置-静态资源的路径，如下所示："><a href="#2、在配置文件config-js里-配置-静态资源的路径，如下所示：" class="headerlink" title="2、在配置文件config.js里 配置 静态资源的路径，如下所示："></a>2、在配置文件config.js里 配置 静态资源的路径，如下所示：</h5><h5 id="3、在启动文件里指明-静态资源所在位置-如下所示："><a href="#3、在启动文件里指明-静态资源所在位置-如下所示：" class="headerlink" title="3、在启动文件里指明 静态资源所在位置,如下所示："></a>3、在启动文件里指明 静态资源所在位置,如下所示：</h5><h5 id="4、第3步，用到了convert，koa-convert是koa1转换器，可以将koa1转换为koa2"><a href="#4、第3步，用到了convert，koa-convert是koa1转换器，可以将koa1转换为koa2" class="headerlink" title="4、第3步，用到了convert，koa-convert是koa1转换器，可以将koa1转换为koa2;"></a>4、第3步，用到了convert，koa-convert是koa1转换器，可以将koa1转换为koa2;</h5><h6 id="（1）-安装-koa-convert-第三方插件，如下所示："><a href="#（1）-安装-koa-convert-第三方插件，如下所示：" class="headerlink" title="（1） 安装 koa-convert 第三方插件，如下所示："></a>（1） 安装 koa-convert 第三方插件，如下所示：</h6><h6 id="（2）在启动文件里引入-koa-convert-如下所示："><a href="#（2）在启动文件里引入-koa-convert-如下所示：" class="headerlink" title="（2）在启动文件里引入 koa-convert,如下所示："></a>（2）在启动文件里引入 koa-convert,如下所示：</h6><h4 id="六：处理模板"><a href="#六：处理模板" class="headerlink" title="六：处理模板"></a>六：处理模板</h4><h4 id="1、在views里创建了两个模板index-html、layout-html"><a href="#1、在views里创建了两个模板index-html、layout-html" class="headerlink" title="1、在views里创建了两个模板index.html、layout.html;"></a>1、在views里创建了两个模板index.html、layout.html;</h4><h4 id="2、layout-html为基本模板，如下图所示："><a href="#2、layout-html为基本模板，如下图所示：" class="headerlink" title="2、layout.html为基本模板，如下图所示："></a>2、layout.html为基本模板，如下图所示：</h4><p>备注：node-swig的api地址：<a href="http://www.cnblogs.com/elementstorm/p/3142644.html" target="_blank" rel="external">http://www.cnblogs.com/elementstorm/p/3142644.html</a></p>
<h3 id="3、index-html去继承layout-html，如下图所示："><a href="#3、index-html去继承layout-html，如下图所示：" class="headerlink" title="3、index.html去继承layout.html，如下图所示："></a>3、index.html去继承layout.html，如下图所示：</h3><h4 id="4、将配置文件下的config-js改为config-es-将启动文件app-es改为app-js，如下图所示："><a href="#4、将配置文件下的config-js改为config-es-将启动文件app-es改为app-js，如下图所示：" class="headerlink" title="4、将配置文件下的config.js改为config.es; 将启动文件app.es改为app.js，如下图所示："></a>4、将配置文件下的config.js改为config.es; 将启动文件app.es改为app.js，如下图所示：</h4><p>备注：因为node不支持es6的某些语法；所以需要编译；然后用编译后的文件；所以这里把源文件都用es格式；</p>
<h4 id="5、在package-json里配置多任务，如下图所示："><a href="#5、在package-json里配置多任务，如下图所示：" class="headerlink" title="5、在package.json里配置多任务，如下图所示："></a>5、在package.json里配置多任务，如下图所示：</h4><p>备注：配置多个任务，就如同本例所示，babel里配置了多个任务，npm run 命令1 &amp;&amp; npm run 命令2</p>
<h4 id="6、执行npm-run-babel命令以后，成功编译文件，如下图所示："><a href="#6、执行npm-run-babel命令以后，成功编译文件，如下图所示：" class="headerlink" title="6、执行npm run babel命令以后，成功编译文件，如下图所示："></a>6、执行npm run babel命令以后，成功编译文件，如下图所示：</h4><p>（1）执行命令：</p>
<p>（2）页面结构图：</p>
<h4 id="7、启动编译后的文件，此时服务已启动，如下图所示："><a href="#7、启动编译后的文件，此时服务已启动，如下图所示：" class="headerlink" title="7、启动编译后的文件，此时服务已启动，如下图所示："></a>7、启动编译后的文件，此时服务已启动，如下图所示：</h4><h4 id="8、客户端去访问服务端，如下图所示："><a href="#8、客户端去访问服务端，如下图所示：" class="headerlink" title="8、客户端去访问服务端，如下图所示："></a>8、客户端去访问服务端，如下图所示：</h4><p>备注：此时说明已访问成功</p>
<h4 id="9、此时来渲染模板，和静态资源，那么就需要把编写路由的模块，进行编译："><a href="#9、此时来渲染模板，和静态资源，那么就需要把编写路由的模块，进行编译：" class="headerlink" title="9、此时来渲染模板，和静态资源，那么就需要把编写路由的模块，进行编译："></a>9、此时来渲染模板，和静态资源，那么就需要把编写路由的模块，进行编译：</h4><p>（1）配置文件里配置编译路由模块的任务，如下图所示：</p>
<p>（2）将路由controllers目录下的文件改为es格式，如下图所示：</p>
<p>（3）此时我们需要在启动文件里去调用编写路由模块的方法所示：</p>
<p>（4）执行 npm run babel ,进行编译，出现错误，如下图所示：</p>
<p>备注：<br>对于本步骤出现的错误，解决方案是：<br>第一步：下载 babel-polyfill 的方法： yarn add babel-polyfill<br>第二步：在启动文件里引入 这个编译插件，如下所示：</p>
<p>备注：babel-polyfill主要解决编写的路由模块进行编译时的报错；<br>第三步：此时再去编译文件， npm run babel，就不会再报错；<br>（5）启动app.js文件，启动服务，如下图所示：</p>
<p>（6）客户端进行访问，如下图所示：</p>
<p>备注: 此时说明，后端的路由已配置成功，后端可以成功渲染模板；<br>七：将页面放置模板内，将js和css资源放置public下<br>1、public的scripts目录下放置js, stylesheet目录下放置css,如下图所示：</p>
<p>备注：</p>
<ul>
<li>（1）scripts下的jquery.min.js是jquery库，用来把导出来的方法挂载到jquery插件下；</li>
<li>（2）scripts下的system.js 是万能模块加载器，可以将模块加载进来，将方法导出来；</li>
<li>（3）scripts下的main.js是我们编写自己的业务逻辑；</li>
<li>（4）stylesheet下的animate.css和index.css 是页面响应的样式；<h4 id="2、将第一步所示的要编译的文件main-js改为main-es格式，如下图所示："><a href="#2、将第一步所示的要编译的文件main-js改为main-es格式，如下图所示：" class="headerlink" title="2、将第一步所示的要编译的文件main.js改为main.es格式，如下图所示："></a>2、将第一步所示的要编译的文件main.js改为main.es格式，如下图所示：</h4><h4 id="3、模板里引入这些文件，如下图所示："><a href="#3、模板里引入这些文件，如下图所示：" class="headerlink" title="3、模板里引入这些文件，如下图所示："></a>3、模板里引入这些文件，如下图所示：</h4></li>
</ul>
<h4 id="4、在配置文件package-json里配置相关任务，关于scripts下的main-es的编译，如下图所示："><a href="#4、在配置文件package-json里配置相关任务，关于scripts下的main-es的编译，如下图所示：" class="headerlink" title="4、在配置文件package.json里配置相关任务，关于scripts下的main.es的编译，如下图所示："></a>4、在配置文件package.json里配置相关任务，关于scripts下的main.es的编译，如下图所示：</h4><h5 id="5、输入编译命令-npm-run-babel-进行编译，如下图所示："><a href="#5、输入编译命令-npm-run-babel-进行编译，如下图所示：" class="headerlink" title="5、输入编译命令 npm run babel 进行编译，如下图所示："></a>5、输入编译命令 npm run babel 进行编译，如下图所示：</h5><h4 id="6、启动app-js，启动服务，客户端进行访问，如下图所示："><a href="#6、启动app-js，启动服务，客户端进行访问，如下图所示：" class="headerlink" title="6、启动app.js，启动服务，客户端进行访问，如下图所示："></a>6、启动app.js，启动服务，客户端进行访问，如下图所示：</h4><p>（1）启动服务：</p>
<p>（2）客户端访问：</p>
<h4 id="八：编写路由接收数据，将数据存储数据库操作"><a href="#八：编写路由接收数据，将数据存储数据库操作" class="headerlink" title="八：编写路由接收数据，将数据存储数据库操作"></a>八：编写路由接收数据，将数据存储数据库操作</h4><h4 id="1、在controllerinit-es文件里添加数据交互的路由，在indexcontroller-es文件里添加该路由的相关处理逻辑方法，如下图所示："><a href="#1、在controllerinit-es文件里添加数据交互的路由，在indexcontroller-es文件里添加该路由的相关处理逻辑方法，如下图所示：" class="headerlink" title="1、在controllerinit.es文件里添加数据交互的路由，在indexcontroller.es文件里添加该路由的相关处理逻辑方法，如下图所示："></a>1、在controllerinit.es文件里添加数据交互的路由，在indexcontroller.es文件里添加该路由的相关处理逻辑方法，如下图所示：</h4><h5 id="1-在controllerinit-es文件里添加数据交互的路由"><a href="#1-在controllerinit-es文件里添加数据交互的路由" class="headerlink" title="(1)在controllerinit.es文件里添加数据交互的路由"></a>(1)在controllerinit.es文件里添加数据交互的路由</h5><h5 id="2-在indexcontroller-es文件里添加该路由的相关处理逻辑方法"><a href="#2-在indexcontroller-es文件里添加该路由的相关处理逻辑方法" class="headerlink" title="(2)在indexcontroller.es文件里添加该路由的相关处理逻辑方法"></a>(2)在indexcontroller.es文件里添加该路由的相关处理逻辑方法</h5><h4 id="2、下载-mysql-promise-插件，命令：yarn-add-mysql-promise，如下图所示："><a href="#2、下载-mysql-promise-插件，命令：yarn-add-mysql-promise，如下图所示：" class="headerlink" title="2、下载 mysql-promise 插件，命令：yarn add mysql-promise，如下图所示："></a>2、下载 mysql-promise 插件，命令：yarn add mysql-promise，如下图所示：</h4><h4 id="3、启动数据库，建表，如下图所示："><a href="#3、启动数据库，建表，如下图所示：" class="headerlink" title="3、启动数据库，建表，如下图所示："></a>3、启动数据库，建表，如下图所示：</h4><p>备注：<br>（1）我在这里用了warmpserver里的phpadmin来建数据库；<br>（2）我建了数据库 db_yideng; 表zan; 表有两个字段，一个字段为id，int类型，主键; 一个字段为num,int类型；</p>
<h4 id="4、在-model目录里-创建indexModel-es-文件，处理数据逻辑，如下图所示："><a href="#4、在-model目录里-创建indexModel-es-文件，处理数据逻辑，如下图所示：" class="headerlink" title="4、在 model目录里 创建indexModel.es 文件，处理数据逻辑，如下图所示："></a>4、在 model目录里 创建indexModel.es 文件，处理数据逻辑，如下图所示：</h4><p>备注：</p>
<ul>
<li>（1）model目录里是专门来处理数据的；controllers目录里就是专门来处理路由的；二者不要混淆一起，各自做各自的事情；</li>
<li>（2）如本例所示：引入数据库模块 mysql-promise</li>
<li>（3）如本例所示：连接数据库</li>
<li>（4）如本例所示，编写模块indexModel, 在该模块里添加方法: data()，data里编写操作数据库部分；这里理下思路：<pre><code>第一：koa2支持async,所以async是同步的；所以在koa2里面不能出现任何异步东西，需要将异步的统统转化为同步；
第二：async里的await 后面跟promise时，它会自动取回调函数里的值；这就相当于把异步变为同步；
第三：在本例当中，我们计算值的时候，用到了定时器，而定时器也是异步，在第一节课的试卷分析里第二道题已详细讲述过；所以这里要把定时器写在promise里，通过await变为同步；
第四：在本例当中，我用了async的自执行，并且return出去，这样，外面接到的这个async自执行实际上就是个promise,所以我们需要在路由模块 indexcontroller里引入此模块的方法时，需要用async包一层，然后用await来执行这个自执行的asnyc,这样我们才能拿到值；
</code></pre>（5）操作数据库：<br>第一：先去查询表，看表里有没有数据；<br>第二：若表里没有数据，那么我们此时要向表里插入一条数据；<br>第三：若表里有数据，那么此时我们要去更新表里的数据；<br>第四：用mysql-promise操作数据库时，如本例所示，回调函数里，我用了affectedRows来判断，API里没有详细说明，需要我们自己去打印找出来这个字段来供我们作为判断的依据；<br>5、在配置文件package.json里添加编译任务，如下图所示：</li>
</ul>
<h4 id="6、启动-npm-run-babel，进行编译文件，如下图所示："><a href="#6、启动-npm-run-babel，进行编译文件，如下图所示：" class="headerlink" title="6、启动 npm run babel，进行编译文件，如下图所示："></a>6、启动 npm run babel，进行编译文件，如下图所示：</h4><h4 id="7、启动服务app-js，客户端进行访问，如下图所示："><a href="#7、启动服务app-js，客户端进行访问，如下图所示：" class="headerlink" title="7、启动服务app.js，客户端进行访问，如下图所示："></a>7、启动服务app.js，客户端进行访问，如下图所示：</h4><p>（1）启动服务，如下图所示：</p>
<p>（2）客户端进行访问，如下图所示：</p>
<p>（3）查看数据库的变化，如下图所示：</p>
<p>备注：<br>第一：此时说明我们已做完后端的接口；<br>第二：本步骤中的第一步打印的值中的截图部分就是第四条最后的部分提示到的，判断数据库到底有没有数据的依据；<br>九：编写前端的数据交互<br>1、做事件稀释，防止不停地点赞，前一次还没操作完，后一次又触发了，如下所示：</p>
<p>备注：<br>在main.es里做事件稀释；<br>本例当中定时器虽然设置为0，但实际上也是由一定的时间的；<br>在这个一定的时间内，如果点了n次，那么前n-1次被取消了；只有第n次才执行；<br>2、编写数据交互，使用axios库，如下所示：<br>（1）在views下的index.html模板里引入此资源：</p>
<p>（2）在public下的scripts目录下的main.es里添加向后端提交数据，如下所示：</p>
<p>（3）由于点赞的数目由后端计算，所以当后端操作数据库成功时，应该给前端返回该数据，如下图所示：</p>
<p>3、此时编译文件，启动服务，客户端访问，如下所示：<br>（1）编译文件 npm run babel，如下所示：</p>
<p>备注：太长，我只截取了一部分；<br>（2）启动服务 node app.js，如下所示：</p>
<p>（3）客户端访问，如下所示：</p>
<p>（4）点击按钮，查看后端数据库是否变化？如下所示：<br>第一步：点击按钮，提交数据，如下所示：</p>
<p>第二步：查看数据库里的数据变化，如下所示：</p>
<p>备注：<br>此时所有流程走通；接下来该做测试；<br>十：测试<br>1、前端测试【UI测试】：<br>（1）安装<br>第一步：全局安装karma,这样可以让karma在任何地方运行：npm install -g karma-cli<br>第二步 本地安装karma：yarn add karma<br>备注：本地安装karma<br>第三步 安装断言库和chrome启动器：yarn add karma-jasmine karma-chrome-launcher<br>备注： karma-jasmine是个断言库； karma-chrome-launcher是个chrome的启动器；<br>第四步：安装 jasmine-core 库：yarn add jasmine-core<br>备注：jasmine-core      断言库核心<br>第五步：安装 karma-phantomjs-launcher 和 phantomjs ：yarn add karma-phantomjs-launcher phantomjs<br>备注：<br>karma-phantomjs-launcher：   phantomjs的启动器<br>phantomjs：                              无界面浏览器，但是它包含了所有浏览器的功能；<br>如果要使用phantomjs，那么就没必要再去下载 chrome的启动器了；我们使用这个便可；<br>删除某个库  yarn remove;<br>在这里，我本打算下载phantomjs，下载中发生错误，下载不下来，所以我还是用chrome的启动器；<br>（2）配置<br>第一步：输入karma init，进行配置，如下所示，去选择相应的：</p>
<p>第二步：此时生成 karma.conf.js,如下所示：</p>
<p>第三步：我去修改配置文件 karma.conf.js,如下所示：</p>
<p>备注：图中所圈的部分<br>basePath：表示 基本的路径配置；<br>frameworks：表示测试所依赖的库；<br>files：表示测试哪些文件；<br>exclude：表示排除哪些文件不测试；<br>browsers：表示karma选择哪个浏览器，由于我无法下载phantomjs,所以我这里用了chrome;<br>singleRun: 设置为true, 默认是false; true表示，如果我们用的是Chrome启动器，如果没有报错，那么当我们karma start时，自动打开谷歌浏览器，然后关闭；<br>第三步：创建目录 test , 去测试相应的文件，如下所示：<br>test目录下的文件，如下所示：</p>
<p>public目录下的scripts下的index.js文件如下所示：</p>
<p>（3）开始进行测试<br>输入karma start  , 测试如下所示：</p>
<p>备注：这种情况表示无错误；若有错误提示，那就是我们写的东西有问题；<br>（4）public目录下的scripts下的index.js文件, 我主要用在这里：如下所示：</p>
<p>2、后端单测(端对端)测试【unit测试】：<br>(1)安装 yarn add selenium-webdriver  如下图所示：</p>
<p>备注：<br>此时说明node版本过于低下，需要下载大于6.9.0版本的node<br>更新node版本以后，继续下载，下载成功。</p>
<p>（2）在test目录里创建e2e.js文件，如下所示：</p>
<p>（3）进入test目录，输入node e2e.js 进行测试，如下所示：</p>
<p>备注：<br>在第二步的forBrowser里设置的是firefox, 那么此处提示错误就该图所示，要去图中所示的网址去下载启动firefox的插件；<br>若在第二步的forBrowser里设置的是firefox, 那么此处提示要下载的网址就是：<a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="external">http://chromedriver.storage.googleapis.com/index.html</a><br>我这里选择了chrome;<br>（4）根据提示，去该网站上下载东西，如下所示：</p>
<p>备注：<br>我选择的最新的版本 2.9，点击进去以后，选择图中所标志的选择 chromedriver_win32.zip 进行下载， 解压以后，将此文件放在 test目录下，与e2e平级，如下所示：</p>
<p>（5）启动 app.js，启动服务，如下所示：</p>
<p>（6）进入test目录，启动测试文件，如下所示：</p>
<p>备注：<br>如果没有出错，那么完成测试以后，自动退出；<br>当我们启动node e2e.js时，它会自动去打开谷歌浏览器，模仿人的一系列操作；如果结果匹配成功，那么会自动关闭浏览器，回到这里来；然后退出e2e.js的测试；<br>3、后端 服务测试：<br>（1）全局安装mocha, 如下所示：</p>
<p>（2）安装第三方模块 supertest, 如下所示：</p>
<p>（3）在test目录下创建 service.js 文件，该文件里的内容，如下所示：</p>
<p>（4）用mocha 进行测试，如下所示：</p>
<p>备注：此时已完成。<br>4、在配置文件里，编写UI测试 、服务端测试、unit测试命令，并将三个命令合并在一起，进行测试，如下所示；</p>
<p>备注：<br>（1）只有 UI测试 和 服务端测试命令可以合并在一起，同时测试；<br>        因为服务端测试时，不能启动app.js否则会报错；而unit测试，需要启动app.js，否则会报错；<br>（2）当我们在编写unit测试命令时，我们需要把test目录下的此文件放在与配置文件同级目录，否则执行unit测试的时候，会报错，提示我们去下载该插件；</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;yarn官网：&lt;a href=&quot;https://yarnpkg.com/&quot;&gt;https://yarnpkg.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;安装yarn: npm install yarn -g&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;先搭整体页面结构&quot;&gt;&lt;a href=&quot;#先搭整体页面结构&quot; class=&quot;headerlink&quot; title=&quot;先搭整体页面结构&quot;&gt;&lt;/a&gt;先搭整体页面结构&lt;/h3&gt;&lt;h4 id=&quot;1、搭建整体结构&quot;&gt;&lt;a href=&quot;#1、搭建整体结构&quot; class=&quot;headerlink&quot; title=&quot;1、搭建整体结构&quot;&gt;&lt;/a&gt;1、搭建整体结构&lt;/h4&gt;&lt;p&gt;备注：【简述各个目录下的作用】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;conf 是放置相关配置；&lt;/li&gt;
&lt;li&gt;controllers放置路由模块；&lt;/li&gt;
&lt;li&gt;midware 是放置中间件；&lt;/li&gt;
&lt;li&gt;node_modules是放置下载的模块；&lt;/li&gt;
&lt;li&gt;public下是放置静态资源；&lt;/li&gt;
&lt;li&gt;views是放置模板；&lt;/li&gt;
&lt;li&gt;models放置与数据打交道的模块；&lt;/li&gt;
&lt;li&gt;添加启动文件 app.js；&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Redux" scheme="http://yoursite.com/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>React Flux架构</title>
    <link href="http://yoursite.com/2017/04/20/React-Flux/"/>
    <id>http://yoursite.com/2017/04/20/React-Flux/</id>
    <published>2017-04-20T02:53:50.000Z</published>
    <updated>2017-08-09T23:39:13.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>Flux架构介绍</li>
<li>React性能调优</li>
<li>Redux介绍与实战</li>
<li>GraphQL and Relay</li>
</ul>
<h3 id="Flux架构介绍"><a href="#Flux架构介绍" class="headerlink" title="Flux架构介绍"></a>Flux架构介绍</h3><ul>
<li>React :本身只涉及UI层，如果搭建大型应用，必须搭配一个前端框架。</li>
<li>Flux :是一种架构思想，专门解决软件的结构问题。它跟MVC 架构是同一类东西，但是更加简单和清晰。</li>
<li>View : 视图层</li>
<li>Action（动作）: 视图层发出的消息（比如mouseClick）</li>
<li>Dispatcher（派发器）: 用来接收Actions、执行回调函数</li>
<li>Store（数据层）: 用来存放应用的状态，一旦发生变动，就提醒Views要更新页面<a id="more"></a>
<img src="/images/170330-11.png" alt=""><br>1.用户访问 View<br>2.View 发出用户的 Action<br>3.Dispatcher 收到 Action，要求 Store 进行相应的更新<br>4.Store 更新后，发出一个”change”事件<br>5.View 收到”change”事件后，更新页面</li>
</ul>
<h3 id="React性能调优"><a href="#React性能调优" class="headerlink" title="React性能调优"></a>React性能调优</h3><pre><code>this.state.list.get(&quot;items&quot;).map(function(label) {
        return &lt;div&gt;&lt;CheckboxWithLabel onChange={this.onChange} &gt;&lt;/CheckboxWithLabel&gt;&lt;/div&gt;
});

onChange:function(){ 
 this.setState({label:123})
}

shouldComponentUpdate: function(nextProps, nextState) {
     return nextProps.label !== this.props.label;
}

mixins: [React.addons.PureRenderMixin],
constructor(props) {
     super(props);
     this.shouldComponentUpdate = React.addons.PureRenderMixin.shouldComponentUpdate.bind(this);
}
</code></pre><p>  子组件的更新触发父组件。父组件更新全部子组件要Diff,一旦更改了state类型，上面全部办法歇菜。</p>
<h3 id="Redux介绍与实战"><a href="#Redux介绍与实战" class="headerlink" title="Redux介绍与实战"></a>Redux介绍与实战</h3><ul>
<li>Flux存在多种实现（至少15种）Redux还算不错</li>
<li>redux.min.js、react-redux.js、redux-thunk.min.js、keyMirror.js、immutable.min.js、reqwest.js（fectch）、ReduxThunk.js</li>
<li>管理应用的 State:<ul>
<li>通过 store.getState() 可以获取 State</li>
<li>通过 store.dispatch(action) 来触发 Stete 更新</li>
<li>通过 store.subscribe(listener) 来注册 state 变化监听器</li>
<li>通过 createStore(reducer, [initialState]) 创建</li>
</ul>
</li>
<li>Provider(ReactRedux)注入store <provider store="{store}<App/">  </provider></li>
<li>Actions  JavaScript 普通对象 通过constants取到</li>
<li>对应 Actions Reducer 返回规律，更具体的是返回状态( Redux.combineReducers返回唯一的 Reducer)。</li>
<li>Store(Redux.createStore(rootReducer,Redux.applyMiddleware(thunkMiddleware)))具体实施的载体</li>
<li>components具体React的组件但是不涉及状态</li>
<li>components-&gt;APP容器 react-redux 提供 connect 的方法 链接React组件和Redux类</li>
</ul>
<h3 id="Redux架构"><a href="#Redux架构" class="headerlink" title="Redux架构"></a>Redux架构</h3><p><img src="images/170330-22.png" alt=""><br>异步的Reducer<br><img src="images/170330-33.png" alt=""></p>
<pre><code>import configureStore from &apos;./store/configureStore.es&apos;;
import App from &apos;./containers/App.es&apos;;
const Provider = ReactRedux.Provider;
const store = configureStore();
//通过store.getState()可以获取state
//通过store.dispatch(action)来处罚state更新
//通过store.subscribe(listener)来注册state变化监听器
//通过createStore(reducer,[initialState])创建

ReactDOM.render(
    &lt;Provider store={store}&gt;
        &lt;App/&gt;
    &lt;/Provider&gt;,
    document.getElementById(&apos;JS-container&apos;)
)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Flux架构介绍&lt;/li&gt;
&lt;li&gt;React性能调优&lt;/li&gt;
&lt;li&gt;Redux介绍与实战&lt;/li&gt;
&lt;li&gt;GraphQL and Relay&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Flux架构介绍&quot;&gt;&lt;a href=&quot;#Flux架构介绍&quot; class=&quot;headerlink&quot; title=&quot;Flux架构介绍&quot;&gt;&lt;/a&gt;Flux架构介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;React :本身只涉及UI层，如果搭建大型应用，必须搭配一个前端框架。&lt;/li&gt;
&lt;li&gt;Flux :是一种架构思想，专门解决软件的结构问题。它跟MVC 架构是同一类东西，但是更加简单和清晰。&lt;/li&gt;
&lt;li&gt;View : 视图层&lt;/li&gt;
&lt;li&gt;Action（动作）: 视图层发出的消息（比如mouseClick）&lt;/li&gt;
&lt;li&gt;Dispatcher（派发器）: 用来接收Actions、执行回调函数&lt;/li&gt;
&lt;li&gt;Store（数据层）: 用来存放应用的状态，一旦发生变动，就提醒Views要更新页面
    
    </summary>
    
    
      <category term="react flux" scheme="http://yoursite.com/tags/react-flux/"/>
    
  </entry>
  
  <entry>
    <title>Redux数据流</title>
    <link href="http://yoursite.com/2017/04/16/Redux%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    <id>http://yoursite.com/2017/04/16/Redux数据流/</id>
    <published>2017-04-16T05:56:11.000Z</published>
    <updated>2017-08-09T23:37:36.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>Redux 应用里的数据流是单向的。数据的生命周期有四个阶段：<br>1.<strong>调用 store.dispatch(action)</strong><br>一个动作就是一个纯对象，描述了发生的事情，比如：</li>
</ul>
<pre><code>{type:&apos;LIKE_ARTICLE&apos;,articleId:42}
{type:&apos;FETCH_USER_SUCCESS&apos;,response:{id:3,name:&apos;Mary}}
{type:&apos;ADD_TODO&apos;,text:&apos;Read thr Redux docs.&apos;}
</code></pre><p>把动作想成是一些简要的新闻： “Mary liked article 42.” ， “‘Read the Redux docs.’ was added to the list of todos.”。在应用的任何地方你可以调用 store.dispatch(action)，包括组件，XHR 回调等等。<br><a id="more"></a><br>2.<strong>Redux Store 会调用你给它的 reducer</strong><br>store 会把两个参数传递给 reducer：当前的状态树，还有动作。比如在一个任务列表应用里。</p>
<p>3.Reducer 是纯函数，它只计算出下一个状态。给它同样的输入，任何时候它都会计算出同样的结果。Reducer 不能执行有副作用的动作，比如去调用 API，这些动作应该在调度动作之前完成。</p>
<pre><code>// The current application state (list of todos and chosen filter)
let previousState = {
  visibleTodoFilter: &apos;SHOW_ALL&apos;,
  todos: [ 
    {
      text: &apos;Read the docs.&apos;,
      complete: false
    }
  ]
}

// The action being performed (adding a todo)
let action = {
  type: &apos;ADD_TODO&apos;,
  text: &apos;Understand the flow.&apos;
}

// Your reducer returns the next application state
let nextState = todoApp(previousState, action)
</code></pre><p>4.Root Reducer 可能会把多个 reducer 输出的东西组合成一个状态树。<br> Root Reducer 的结构完全取决于我们自己的设计。Redux 里面带个帮手函数：combineReducers()，你可以把 Root Reducer 分离成不同的 Reducer，每个 Reducer 都只管理属于它们自己的数据，然后用 combineReducers() 可以把这些分离出来的 Reducer 组合到一块儿，成为一个 Root Reducer。</p>
<p> 比如你有两个 Reducers，一个是为了任务列表，一个是为了当前选择的过滤器：</p>
<pre><code>function todos(state = [], action) {
  // Somehow calculate it...
  return nextState
}

function visibleTodoFilter(state = &apos;SHOW_ALL&apos;, action) {
  // Somehow calculate it...
  return nextState
}

let todoApp = combineReducers({
  todos,
  visibleTodoFilter
})
</code></pre><p>执行了动作以后，combineReducers 返回的 todoApp 会同时调用两个 Reducers：</p>
<pre><code>let nextTodos = todos(state.todos, action)
let nextVisibleTodoFilter = visibleTodoFilter(state.visibleTodoFilter, action)
</code></pre><p>然后会把这两个分支的结果组合成一个状态树：</p>
<pre><code>return {
  todos: nextTodos,
  visibleTodoFilter: nextVisibleTodoFilter
}
</code></pre><p>5.Redux store 会把 root reducer 返回的状态树保存起来。<br>  这个新的状态树就是应用的下一个状态。所有 store.subscribe(listener) 注册的监听器会被执行。监听器可以使用 store.getState() 得到当前的状态。现在，UI 会根据新的状态被更新，如果把 React 与 Redux 放到一块儿用，这时候可以去调用  component.setState(newState) 。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Redux 应用里的数据流是单向的。数据的生命周期有四个阶段：&lt;br&gt;1.&lt;strong&gt;调用 store.dispatch(action)&lt;/strong&gt;&lt;br&gt;一个动作就是一个纯对象，描述了发生的事情，比如：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{type:&amp;apos;LIKE_ARTICLE&amp;apos;,articleId:42}
{type:&amp;apos;FETCH_USER_SUCCESS&amp;apos;,response:{id:3,name:&amp;apos;Mary}}
{type:&amp;apos;ADD_TODO&amp;apos;,text:&amp;apos;Read thr Redux docs.&amp;apos;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;把动作想成是一些简要的新闻： “Mary liked article 42.” ， “‘Read the Redux docs.’ was added to the list of todos.”。在应用的任何地方你可以调用 store.dispatch(action)，包括组件，XHR 回调等等。&lt;br&gt;
    
    </summary>
    
    
      <category term="Redux" scheme="http://yoursite.com/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Redux:Store</title>
    <link href="http://yoursite.com/2017/04/01/Redux-Store/"/>
    <id>http://yoursite.com/2017/04/01/Redux-Store/</id>
    <published>2017-04-01T07:59:32.000Z</published>
    <updated>2017-04-02T10:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>Redux 应用里的 Actions 表示在应用里发生的事情，Reducers 会根据发生的事情去更新应用的状态。再来了解一下 Store。</p>
</li>
<li><p>Store 的主要任务是：</p>
</li>
</ul>
<p>1.持有应用的状态。<br>2.允许访问状态：getState()。<br>3.允许更新状态：dispatch(action)。<br>4.注册监听器：subscribe(listener)。<br>5.用 subscribe(listener) 返回的东西，可以注销监听器。</p>
<p>注意在 Redux 应用里只有一个 Store。如果想分离数据处理逻辑，可以使用组合 Reducer 的方式。<br><a id="more"></a><br>有了 Reducer ，很容易用它去创建一个 Store 。之前我们用 combineReducers() 把几个 Reducer 组合成了一个，现在我们可以去导入它，然后把它交给 createStore()。</p>
<pre><code>import { createStore } from &apos;redux&apos;
import todoApp from &apos;./reducers&apos;
let store = createStore(todoApp)
</code></pre><p>也可以提供一个初始状态，作为 createStore() 的第二个参数：</p>
<pre><code>let store = createStore(todoApp, window.STATE_FROM_SERVER)
</code></pre><h3 id="调度动作"><a href="#调度动作" class="headerlink" title="调度动作"></a>调度动作</h3><p>创建了 Store 以后，再去测试一下应用能不能正常运行：</p>
<pre><code>import { addTodo, toggleTodo, setVisibilityFilter, VisibilityFilters } from &apos;./actions&apos;

// Log the initial state
console.log(store.getState())

// Every time the state changes, log it
// Note that subscribe() returns a function for unregistering the listener
let unsubscribe = store.subscribe(() =&gt;
  console.log(store.getState())
)

// Dispatch some actions
store.dispatch(addTodo(&apos;Learn about actions&apos;))
store.dispatch(addTodo(&apos;Learn about reducers&apos;))
store.dispatch(addTodo(&apos;Learn about store&apos;))
store.dispatch(toggleTodo(0))
store.dispatch(toggleTodo(1))
store.dispatch(setVisibilityFilter(VisibilityFilters.SHOW_COMPLETED))

// Stop listening to state updates
unsubscribe()
</code></pre><p>观察 Store 里的状态是怎么变化的：<br><img src="/images/170401-1.png" alt=""></p>
<p>在写界面之前，我们已经设置好了应用的一些行为。</p>
<p>Source Code</p>
<p>index.js</p>
<pre><code>import { createStore } from &apos;redux&apos;
import todoApp from &apos;./reducers&apos;

let store = createStore(todoApp)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;Redux 应用里的 Actions 表示在应用里发生的事情，Reducers 会根据发生的事情去更新应用的状态。再来了解一下 Store。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Store 的主要任务是：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.持有应用的状态。&lt;br&gt;2.允许访问状态：getState()。&lt;br&gt;3.允许更新状态：dispatch(action)。&lt;br&gt;4.注册监听器：subscribe(listener)。&lt;br&gt;5.用 subscribe(listener) 返回的东西，可以注销监听器。&lt;/p&gt;
&lt;p&gt;注意在 Redux 应用里只有一个 Store。如果想分离数据处理逻辑，可以使用组合 Reducer 的方式。&lt;br&gt;
    
    </summary>
    
    
      <category term="Redux Store" scheme="http://yoursite.com/tags/Redux-Store/"/>
    
  </entry>
  
  <entry>
    <title>前端架构构建</title>
    <link href="http://yoursite.com/2017/03/30/%E5%89%8D%E7%AB%AF%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    <id>http://yoursite.com/2017/03/30/前端持续集成/</id>
    <published>2017-03-30T01:05:37.000Z</published>
    <updated>2017-03-30T10:28:12.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>什么是集成</li>
<li>什么是统一代码仓库</li>
<li>什么是前端工程化</li>
<li>什么是自动化构建</li>
<li>更多的自动化</li>
</ul>
<h3 id="持续集成需求"><a href="#持续集成需求" class="headerlink" title="持续集成需求"></a>持续集成需求</h3><p>1.持续集成是通过平台串联各个开发环节，实现和沉淀工作自动化的方法。<br>2.线上代码和代码仓库不同步，影响迭代和团队协作。<br>3.静态资源发布依赖人工，浪费开发人力。<br>4.缺少自动化测试，产品质量得不到保障。<br>5.文案简单修改上线，需要技术介入。<br><a id="more"></a><br><img src="/images/170330-1.png" alt=""></p>
<h3 id="统一代码仓库"><a href="#统一代码仓库" class="headerlink" title="统一代码仓库"></a>统一代码仓库</h3><p>1.统一代码仓库通过分支管理合并主干svn。<br>2.自动化构建工具，编译、部署、测试、监控、本机开发上线环境。<strong>FIS3/Webpack/jdists/package.json/chai/supertest/mocha/selenium-webdriver</strong><br>3.持续集成平台。<strong>Jenkins、Travis CI</strong><br>4.部署工具。<strong>rsync、shelljs、yargs</strong><br>5.运营同学有权限操作运营页面保存即可上线。</p>
<h3 id="统一代码仓库多分支开发"><a href="#统一代码仓库多分支开发" class="headerlink" title="统一代码仓库多分支开发"></a>统一代码仓库多分支开发</h3><p><img src="/images/170330-2.png" alt="">                     </p>
<h3 id="合成步骤"><a href="#合成步骤" class="headerlink" title="合成步骤"></a>合成步骤</h3><p>1.svn checkout svn地址 –username用户名<br>2.svn branch 分支名（add/commit）<br>3.svn merge 主干svn地址  分支svn地址<br>4.Beyond Compare -&gt; svn resolved<br>5.svn copy 主干svn地址 /tags/2017<br><img src="/images/170330-3.png" alt="">    </p>
<h3 id="前端工程化目标"><a href="#前端工程化目标" class="headerlink" title="前端工程化目标"></a>前端工程化目标</h3><ul>
<li>自动化编译</li>
<li>前端模块化</li>
<li>定位静态资源</li>
<li>前端开发组件化</li>
<li>自动化部署测试配合版本库</li>
<li>自动化性能优化（前端架构开发下）</li>
</ul>
<h3 id="自动化编译"><a href="#自动化编译" class="headerlink" title="自动化编译"></a>自动化编译</h3><p><img src="/images/170330-4.png" alt="">  </p>
<h3 id="自动化编译流程"><a href="#自动化编译流程" class="headerlink" title="自动化编译流程"></a>自动化编译流程</h3><ul>
<li>读入foo.es的文件内容，编译成js内容</li>
<li>分析js内容，找到资源定位标记’foo.scss’</li>
<li>对foo.scss进行编译：<ul>
<li>读入foo.scss的文件内容，编译成css内容</li>
<li>分析css内容，找到资源定位标记’url(foo.png)’</li>
<li>对foo.png进行编译：<ul>
<li>读入foo.png的内容</li>
<li>图片压缩</li>
<li>返回图片内容</li>
</ul>
</li>
<li>根据foo.png的最终内容计算md5戳，替换url(foo.png)为url(/static/img/foo_2afob.png)</li>
<li>替换完毕所有资源定位标记，对css内容进行压缩</li>
<li>返回css内容 </li>
</ul>
</li>
<li>根据foo.css的最终内容计算md5戳，替换’foo.scss’为’/static/scss/foo_bae39.css’</li>
<li>替换完毕所有资源定位标记，对js内容进行压缩</li>
<li>返回js内容</li>
<li><p>根据最终的js内容计算mds戳，得到foo.coffee的资源url为’/static/scripts/foo_3fc20.js’</p>
<h3 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h3><p>1.前端模块化框架肩负着<strong>模块管理</strong>、<strong>资源加载</strong>两项重要的功能。这两项功能与<strong>工具</strong>、<strong>性能</strong>、<strong>业务</strong>、<strong>部署</strong>等工程环节都有着非常紧密的联系。<br>因此，模块化框架的设计应该最高优先级考虑工程需要。<br>2.commonjs API定义很多普通应用程序（主要指非浏览器的应用）使用的API,从而填补了这个空白。它的终极目标是提供一个类似 Python,Ruby和Java标准库。<br>3.根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里定义的变量、函数、类，都有私有的，对其他文件不可见。<br>4.CMD和AMD都是CommonJS的一种规范的实现定义，RequireJS和SeaJS是对应的实践。</p>
</li>
<li><p>AMD</p>
</li>
</ul>
<pre><code>define([&apos;dep1&apos;,&apos;dep2&apos;],function(dep1,dep2){    
    // 内部只能使用执行的模块
    return function(){};
});
</code></pre><ul>
<li>CMD</li>
</ul>
<pre><code>define(function(require,exports,module){     
    //此处如果需要加载某xx模块，可引入
    var xx=require(&apos;xx&apos;);
})
</code></pre><h4 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h4><p>1.<strong>CMD依赖是就近声明</strong>，通过内部require方法进行声明。但是因为是异步模块，加载需要提前加载这些模块，所以模块真正使用前需要提取模块里面所有的依赖。<br>2.不能直接压缩，require局部变量如果替换无法加载资源。<br>3.CMD路径参数不能进行字符串运算。<br>4.<strong>AMD的依赖是提前声明</strong>。这种优势的好处就是依赖无需通过静态分析，无论是加载器还是自动化工具都可以直接的获取到依赖。<br>5.AMD依赖提前声明在代码书写上不是很友好。<br>6.AMD模块内部与NodeJS的Modules有一定的差异。</p>
<h3 id="依赖后置"><a href="#依赖后置" class="headerlink" title="依赖后置"></a>依赖后置</h3><p>1.requirejs和seajs在加载上都有缺陷，就是模块的依赖要等到模块加载完成后，通过静态分析（seajs）或者deps参数（requirejs）来获取，这就为合并请求和按需加载带来了实现上的矛盾：要么放弃按需加载，把所有js合成一个文件。要么放弃请求合并，请求独立的模块文件，从而满足按需加载。<br>2.AMD规范在执行callback的时候，要初始化所有依赖的模块，而CMD只有执行到require的时候才初始化模块。所以用AMD实现某种if-else逻辑分支家在不同的模块时候，就会比较麻烦了。</p>
<pre><code>reqquire([&apos;page/index&apos;,&apos;page/detail&apos;],function(index,detail){
    switch(location.hash){
        case&apos;index&apos;:
            index();
        break;
    }
}});
</code></pre><p>3.以上纯前端方式实现模块化框架不能同时满足 按需加载、请求合并和依赖管理 三个需求。</p>
<p><img src="/images/170330-5.png" alt="">  </p>
<h3 id="为什么用webpack"><a href="#为什么用webpack" class="headerlink" title="为什么用webpack"></a>为什么用webpack</h3><p>1.webpack执行commonJs标准，解决了依赖配置和请求流量。<br>2.对于webpack来讲万物都可以是模块，所有的文件都被合并到js中，最终在浏览器。<br>3.兼容AMD和CMD<br>4.js模块化不仅仅为了提高代码复用性，更是为了让资源文件更合理的进行缓存。</p>
<pre><code>function(moudle,exportss._webpack_require_){
    exports=module.exports=_webpack_require_(3)();
    //imports

    //module

    exports.push([module.id,&quot;body{\r\n background-color:yellow;\r\n}\r\n&quot;,&quot;&quot;]);

    //exports

},

new webpack.optimize.UglifyJsPlugin({
    mangle:{
        except:[&apos;$super&apos;,&apos;$&apos;,&apos;exports&apos;,&apos;require&apos;]
    }
})


var path = require(&quot;path&quot;);
var CommonsChunkPlugin = require(&quot;../../node_modules/webpack/lib/optimize/CommonsChunkPlugin&quot;);
module.exports={
    entry:{
        m1:&apos;./m1.js&apos;,
        m2:&apos;./m2.js&apos;
    },
    output:{
        path:&quot;build&quot;,
        filename:&apos;[name].bundle.js&apos;
    },
    plugins:[
        new CommonsChunkPlugin(&apos;common.js&apos;);
    ]
};
</code></pre><h3 id="资源定位"><a href="#资源定位" class="headerlink" title="资源定位"></a>资源定位</h3><p>1.配置超长时间的本地缓存–节省宽带，提高性能<br>2.采用内容摘要作为缓存更新依据–精确的缓存控制<br>3.静态资源CDN部署–优化网络请求<br>4.资源发布路径实现非覆盖式发布–平滑升级</p>
<ul>
<li>FIS3根据分析好的文件包，利用HOOK插件 分析下FIS生成的配置文件</li>
<li>webpack阿紫开发阶段打包，利用插件分析直接提取。FileLoader&amp;&amp;extract-text-webpack-plugin</li>
<li>配置publicpath分发到CDN</li>
</ul>
<h3 id="前端开发组件化"><a href="#前端开发组件化" class="headerlink" title="前端开发组件化"></a>前端开发组件化</h3><p>1.每个前端模块都是一个小项目，配合mock.js可以进行本地的开发测试，package.json是标配产物。经过webpack的环境配置统一进行本地环境、上线环境的变异过程。<br>2.由page组装widget，由widget组装webComponents(X-TAG)<br>3.能够根据路由快速选择配置SPA或者直出。</p>
<h3 id="web-components"><a href="#web-components" class="headerlink" title="web components"></a>web components</h3><p>1.Custom Elements<br>2.HTML Imports<br>3.HTML Templates<br>4.Shadow DOM</p>
<ul>
<li>Custom Elements 提供一种方式让开发者可以自定义HTML元素，包括特定的组成，样式和行为。</li>
</ul>
<pre><code>class ButtonHelloElement extends HTMLButtonElement{
   constructor(){
       super()
       this.addEventListener(&apos;click&apos;,()=&gt;{
           alert(&apos;hello world&apos;);
       })
   }
}
customElements.define(&apos;button-hello&apos;,ButtonHelloElement,{extends:&apos;button&apos;})
&lt;button is=&quot;button-hello&quot;&gt;hello world&lt;/button&gt;
</code></pre><ul>
<li>HTML Imports 是一种在HTML中引用以及服用其他的HTML文档的方式。这个Import很漂亮，可以简单理解为我们常见的末班中的include之类的作用。</li>
</ul>
<pre><code>&lt;link rel=&quot;import&quot; href=&quot;/components/header.html&quot;&gt;
const link=document.querySelector(&apos;link[rel=import]&apos;)
const header=link.import;

const pulse=header.querySelector(&apos;div.logo&apos;);
//获取import的HTMl的document
const d=document.currentScript.ownerDocument
</code></pre><p>用过handlebars的人都知道有这么一个东西：</p>
<pre><code>&lt;script id=&quot;template&quot; type=&quot;text/x-handlebars-template&quot;&gt;&lt;/script&gt;
</code></pre><p>那么HTML Templates是把这个东西官方标准化，提供了一个template 标签来存放以后需要但是暂时不渲染的HTML代码。</p>
<pre><code>&lt;template id=&quot;template&quot;&gt;&lt;p&gt;Smile&lt;/p&gt;&lt;/template&gt;
&lt;script&gt;
let num=3;
const fragment=document.getElementById(&apos;template&apos;).content.cloneNode(true);
while(num --&gt;1 ){
    fragment.firstChild.before(fragment.firstChild.cloneNode(true));
    fragment.firstChild.textContent+=fragment.lastChild.textContent;
}
document.body.appendChild(fragment);
&lt;/script&gt;
</code></pre><ul>
<li>Shadow DOM  最本质的需求是需要一个隔离组件代码作用域的东西，例如我组件代码的css不能影响其他组件之类的，而iframe又太重并且可能有各种奇怪问题。旨在提供一种更好的组织页面元素的方式，来为日趋复杂的页面应用提供强大支持，避免代码间的相互影响。</li>
</ul>
<pre><code>const div=document.getElementById(&apos;id&apos;)
const shadowRoot=div.createShadowRoot()
const span=document.creatElement(&apos;span&apos;)

span.textContent=&apos;hello world&apos;
shadowRoot.appendChild(span)

&lt;x-foo&gt;
   &lt;&quot;shadow tree&quot;&gt;
       &lt;div&gt;
           &lt;span id=&quot;not-top&quot;&gt;...&lt;/span&gt;
       &lt;/div&gt;
       &lt;span id=&quot;top&quot;&gt;...&lt;/span&gt;
   &lt;/&gt;
&lt;/x-foo&gt;

x-foo::shadow &gt; span 可以匹配到#top元素
x-foo /deep/span 可以匹配到 #not-top和 #top元素
:host(.foo) 匹配&lt;x-foo&gt;元素
</code></pre><ul>
<li>Web Components</li>
</ul>
<pre><code>&lt;template id=&quot;&quot;&gt;
&lt;style&gt;
::content li{
   display:inline-block;
   padding:20px 10px;
}
&lt;/style&gt;
&lt;content select=&quot;ul&quot;&gt;&lt;/content&gt;
&lt;/template&gt;


&lt;link rel=&quot;import&quot; href=&quot;components/header.html&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;test-header&gt;
       &lt;ul&gt;
           &lt;li&gt;Home&lt;/li&gt;
           &lt;li&gt;About&lt;/li&gt;
       &lt;/ul&gt;
   &lt;/test-header&gt;
&lt;/body&gt;
</code></pre><h3 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h3><p>1.自动化运营平台<br>2.自动化雪碧图<br>3.自动化离线打包<br>4.自动化控制缓存级别<br>5.自动化处理inline<br>6.自动化根据网速分发版本资源<br>7.自动化运维平台</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;什么是集成&lt;/li&gt;
&lt;li&gt;什么是统一代码仓库&lt;/li&gt;
&lt;li&gt;什么是前端工程化&lt;/li&gt;
&lt;li&gt;什么是自动化构建&lt;/li&gt;
&lt;li&gt;更多的自动化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;持续集成需求&quot;&gt;&lt;a href=&quot;#持续集成需求&quot; class=&quot;headerlink&quot; title=&quot;持续集成需求&quot;&gt;&lt;/a&gt;持续集成需求&lt;/h3&gt;&lt;p&gt;1.持续集成是通过平台串联各个开发环节，实现和沉淀工作自动化的方法。&lt;br&gt;2.线上代码和代码仓库不同步，影响迭代和团队协作。&lt;br&gt;3.静态资源发布依赖人工，浪费开发人力。&lt;br&gt;4.缺少自动化测试，产品质量得不到保障。&lt;br&gt;5.文案简单修改上线，需要技术介入。&lt;br&gt;
    
    </summary>
    
    
      <category term="前端架构构建  前端集成" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E6%9E%84%E5%BB%BA-%E5%89%8D%E7%AB%AF%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>http协议背后的事</title>
    <link href="http://yoursite.com/2017/03/29/http%E5%8D%8F%E8%AE%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8B/"/>
    <id>http://yoursite.com/2017/03/29/http协议背后的事/</id>
    <published>2017-03-29T07:27:02.000Z</published>
    <updated>2017-04-01T02:02:05.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>当我们输入网址后发生了什么</li>
<li>HTTP协议详解</li>
<li>HTTP协议安全</li>
<li>后台服务与HTTP</li>
<li>反向代理与web服务</li>
</ul>
<h3 id="浏览器行为与HTTP协议"><a href="#浏览器行为与HTTP协议" class="headerlink" title="浏览器行为与HTTP协议"></a>浏览器行为与HTTP协议</h3><p>处理流程：<br>1.输入网址并回车<br>2.解析域名<br>3.浏览器发送http请求<br>4.服务器处理请求<br>5.服务器返回HTML响应<br>6.浏览器处理HTML页面<br>7.继续请求其他资源</p>
<a id="more"></a>
<h3 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h3><ul>
<li>HTTP是超文本传输协议，从www浏览器传输到本地浏览器的一种传输协议，网站是基于HTTP协议的，例如网站的图片、CSS、JS等都是基于HTTP协议进行传输的。</li>
<li>HTTP协议是由从客户机到服务器的请求(Reuqest)和从服务器到客户机的响应(response)进行约束和规范。</li>
</ul>
<h3 id="了解TCP-IP协议栈"><a href="#了解TCP-IP协议栈" class="headerlink" title="了解TCP/IP协议栈"></a>了解TCP/IP协议栈</h3><p>1.应用层：为用户提供所需要的各种服务，例如：HTTP、FTP、DNS、SMTP等。<br>2.传输层：为应用层实体提供端到端通信功能，保证数据包的顺序传送及数据的完整性。该层定义了两个主要协议：<strong>传输控制协议(TCP)和用户数据报协议(UDP)</strong>。<br>3.网络层：主要解决主机到主机的通信问题。IP协议是网际互联层最重要的协议。<br>4.网络接口层：负责监视数据在主机和网络之间的交换。</p>
<h3 id="在TCP-IP协议栈中得位置"><a href="#在TCP-IP协议栈中得位置" class="headerlink" title="在TCP/IP协议栈中得位置"></a>在TCP/IP协议栈中得位置</h3><ul>
<li>目前应用版本HTTP1.1</li>
<li>HTTP默认端口号为80</li>
<li>HTTPS默认端口443<br><img src="/images/http1.png" alt=""></li>
</ul>
<h3 id="HTTP的工作过程"><a href="#HTTP的工作过程" class="headerlink" title="HTTP的工作过程"></a>HTTP的工作过程</h3><ul>
<li>一次HTTP操作称为一个事务,其工作过程可分为四步:<br>1.首先客户机与服务器需要建立连接。只要单击某个超级链接,HTTP的工作开始。<br>2.建立连接后,客户机发送一个请求给服务器,请求方式的格式为:统一资源标识符(URL)、协议版本号,后边是MIME信息包括请求修饰符、客户机信息和可能的内容。<br>3.服务器接到请求后,给予相应的响应信息,其格式为一个状态行,包括信息的协议版本号、一个成功或错误的代码,后边是MIME信息包括服务器信息、实体信息和可能的内容。<br>4.客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上,然后客户机与服务器断开连接。<br>如果在以上过程中的某一步出现错误,那么产生错误的信息将返回到客户端,有显示屏输出。对于用户来说,这些过程是由HTTP自己完成的,用户只要用鼠标点击,等待信息显示就可以了。</li>
</ul>
<h3 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h3><ul>
<li>HTTP请求组成:请求行、消息报头、请求正文。</li>
<li>HTTP响应组成:状态行、消息报头、响应正文。</li>
<li>请求行组成:以一个方法符号开头,后面跟着请求的URI和协议的版本。</li>
<li>状态行组成:服务器HTTP协议的版本,服务器发回的响应状态代码和状态代码的文本描述。</li>
</ul>
<p>(1) <strong>请求报文</strong><br><img src="/images/request.png" alt=""><br>(2) <strong>响应报文</strong><br><img src="/images/response.png" alt=""></p>
<h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><ul>
<li>GET: 请求获取Request-URI所标识的资源</li>
<li>POST: 在Request-URI所标识的资源后附加新的数据</li>
<li>HEAD: 请求获取由Request-URI所标识的资源的响应消息报头 </li>
<li>PUT: 请求服务器存储一个资源,并用Request-URI作为其标识 </li>
<li>DELETE: 请求服务器删除Request-URI所标识的资源</li>
<li>TRACE: 请求服务器回送收到的请求信息,主要用于测试或诊断</li>
<li>CONNECT: 保留将来使用 OPTIONS:请求查询服务器的性能,或者查询与资源相关的选项和需求</li>
</ul>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>状态代码有三位数字组成,第一个数字定义了响应的类别,且有五种可能取值: </p>
<ul>
<li>1xx:指示信息–表示请求已接收,继续处理 </li>
<li>2xx:成功–表示请求已被成功接收、理解、接受 </li>
<li>3xx:重定向–要完成请求必须进行更进一步的操作 </li>
<li>4xx:客户端错误–请求有语法错误或请求无法实现 </li>
<li>5xx:服务器端错误–服务器未能实现合法的请求</li>
</ul>
<h3 id="常用的请求报头"><a href="#常用的请求报头" class="headerlink" title="常用的请求报头"></a>常用的请求报头</h3><ul>
<li>Accept请求报头域用于指定客户端接受哪些类型的信息。eg:Accept:image/gif,Accept:text/ htmlAccept-Charset请求报头域用于指定客户端接受的字符集。Accept-Encoding:Accept-Encoding请求 报头域类似于Accept,但是它是用于指定可接受的内容编码。</li>
<li>Accept-Language请求报头域类似于Accept,但是它是用于指定一种自然语言。</li>
<li>Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时,如果收到服务器的响应代码为401(未授权),可以发送一个包含Authorization请求报头域的请求,要求服务 器对其进行验证。</li>
<li>Host请求报头域主要用于指定被请求资源的Internet主机和端又号,它通常从HTTP URL中提取出来 的,发送请求时,该报头域是必需的。</li>
<li>User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。</li>
</ul>
<h3 id="常用的响应报头"><a href="#常用的响应报头" class="headerlink" title="常用的响应报头"></a>常用的响应报头</h3><ul>
<li>Location响应报头域用于重定向接受者到一个新的位置。Location 响应报头域常用在更换域名的时候。</li>
<li>Server响应报头域包含了服务器用来处理请求的软件信息。与User- Agent请求报头域是相对应的。</li>
<li>WWW-Authenticate响应报头域必须被包含在401(未授权的)响应 消息中,客户端收到401响应消息时候,并发送Authorization报头 域请求服务器对其进行验证时,服务端响应报头就包含该报头域。</li>
</ul>
<h3 id="实体报头"><a href="#实体报头" class="headerlink" title="实体报头"></a>实体报头</h3><p>请求和响应消息都可以传送一个实体。一个实体由实体报头域 和实体正文组成,但并不是说实体报头域和实体正文要在一起 发送,可以只发送实体报头域。实体报头定义了关于实体正文 (eg:有无实体正文)和请求所标识的资源的元信息。</p>
<h3 id="常用的实体报头"><a href="#常用的实体报头" class="headerlink" title="常用的实体报头"></a>常用的实体报头</h3><ul>
<li>Content-Encoding实体报头域被用作媒体类型的修饰符,它的值指示了已经被应用到实体正文 的附加内容的编码,因而要获得Content-Type报头域中所引用的媒体类型,必须采用相应的解 码机制。</li>
<li>Content-Language实体报头域描述了资源所用的自然语言。 </li>
<li>Content-Length实体报头域用于指明实体正文的长度,以字节方式存储的十进制数字来表示。</li>
<li>Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。</li>
<li>Last-Modified实体报头域用于指示资源的最后修改日期和时间。 </li>
<li>Expires实体报头域给出响应过期的日期和时间。</li>
</ul>
<h3 id="cookies-与-session"><a href="#cookies-与-session" class="headerlink" title="cookies 与 session"></a>cookies 与 session</h3><ul>
<li>Cookies是保存在客户端的小段文本,随客户端点每一个请求发送该url下的所有cookies到服务器端。</li>
<li>Session则保存在服务器端,通过唯一的值sessionID来区别每一 个用户。SessionID随每个连接请求发送到服务器,服务器根据 sessionID来识别客户端,再通过session 的key获取session值。</li>
</ul>
<h3 id="cookie应用"><a href="#cookie应用" class="headerlink" title="cookie应用"></a>cookie应用</h3><p>与Cookie相关的HTTP扩展头<br>1.Cookie:客户端将服务器设置的Cookie返回到服务器;<br>2.Set-Cookie:服务器向客户端设置Cookie;<br>服务器在响应消息中用Set-Cookie头将 Cookie的内容回送给客户端,客户端在新 的请求中将相同的内容携带在Cookie头中 发送给服务器。从而实现会话的保持。</p>
<h3 id="session-使用"><a href="#session-使用" class="headerlink" title="session 使用"></a>session 使用</h3><ul>
<li>使用Cookie来实现 </li>
<li>使用URL回显来实现</li>
</ul>
<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><ul>
<li>缓存会根据请求保存输出内容的副本,例如html页面,图片,文 件,当下一个请求来到的时候:如果是相同的URL,缓存直接使 用副本响应访问请求,而不是向源服务器再次发送请求。</li>
<li>缓存的优点:<ol>
<li>减少相应延迟</li>
<li>减少网络带宽消耗</li>
</ol>
</li>
</ul>
<h3 id="浏览器缓存机制-浏览器第一次请求"><a href="#浏览器缓存机制-浏览器第一次请求" class="headerlink" title="浏览器缓存机制-浏览器第一次请求"></a>浏览器缓存机制-浏览器第一次请求</h3><p><img src="/images/request1.png" alt=""></p>
<h3 id="浏览器缓存机制-浏览器再次请求"><a href="#浏览器缓存机制-浏览器再次请求" class="headerlink" title="浏览器缓存机制-浏览器再次请求"></a>浏览器缓存机制-浏览器再次请求</h3><p><img src="/images/request2.png" alt=""></p>
<h3 id="Etag-if-None-Match策略"><a href="#Etag-if-None-Match策略" class="headerlink" title="Etag/if-None-Match策略"></a>Etag/if-None-Match策略</h3><ul>
<li>Etag:web服务器响应请求时,告诉浏览器当前资源在服务器的唯一标识(生成规则由服务器决定)</li>
<li>If-None-Match:当资源过期时(使用Cache-Control标识的max- age),发现资源具有Etage声明,则再次向web服务器请求时带 上头If-None-Match (Etag的值)。web服务器收到请求后发现 有头If-None-Match 则与被请求资源的相应校验串进行比对,决 定返回200或304。</li>
</ul>
<h3 id="Last-Modified-if-Modified-Since策略"><a href="#Last-Modified-if-Modified-Since策略" class="headerlink" title="Last-Modified/if-Modified-Since策略"></a>Last-Modified/if-Modified-Since策略</h3><ul>
<li>Last-Modified:标示这个响应资源的最后修改时间。web服务器在响应请求时,告诉浏览器资源的最后修改时间。</li>
<li>If-Modified-Since:当资源过期时(使用Cache-Control标识的max-age),发 现资源具有Last-Modified声明,则再次向web服务器请求时带上头 If- Modified-Since,表示请求时间。web服务器收到请求后发现有头If-Modified- Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新,说 明资源又被改动过,则响应整片资源内容(写在响应消息包体内),HTTP 200;若最后修改时间较旧,说明资源无新修改,则响应HTTP 304 (无需包 体,节省浏览),告知浏览器继续使用所保存的cache。</li>
</ul>
<h3 id="HTTP链路安全"><a href="#HTTP链路安全" class="headerlink" title="HTTP链路安全"></a>HTTP链路安全</h3><p>1.加密重要数据<br>2.对非重要数据签名<br>3.使用安全连接HTTPS协议</p>
<h3 id="下一代标准：HTTP2"><a href="#下一代标准：HTTP2" class="headerlink" title="下一代标准：HTTP2"></a>下一代标准：HTTP2</h3><ul>
<li>使用二进制格式传输,更高效、更紧凑。</li>
<li>对报头压缩,降低开销。</li>
<li>多路复用,一个网络连接实现并行请求。</li>
<li>服务器主动推送,减少请求的延迟</li>
</ul>
<h3 id="http与反向代理"><a href="#http与反向代理" class="headerlink" title="http与反向代理"></a>http与反向代理</h3><ul>
<li>什么是代理,什么又是反向代理?</li>
<li>为什么要使用反向代理? </li>
<li>都有哪些反向代理服务器?</li>
</ul>
<h3 id="反向代理的用途"><a href="#反向代理的用途" class="headerlink" title="反向代理的用途"></a>反向代理的用途</h3><ul>
<li>加密和SSL加速 </li>
<li>负载均衡 </li>
<li>缓存静态内容 </li>
<li>压缩</li>
<li>减速上传 </li>
<li>安全</li>
<li>外网发布</li>
</ul>
<h4 id="反向代理做负载均衡"><a href="#反向代理做负载均衡" class="headerlink" title="反向代理做负载均衡"></a>反向代理做负载均衡</h4><p><img src="/images/daili.png" alt=""></p>
<h4 id="让nginx跑起来"><a href="#让nginx跑起来" class="headerlink" title="让nginx跑起来"></a>让nginx跑起来</h4><ul>
<li>准备环境:Linux服务器、gcc编译器、nginx源代码 </li>
<li>获取nginx源码:<a href="http://nginx.org" target="_blank" rel="external">http://nginx.org</a> </li>
<li>编译安装nginx源码</li>
<li>配置规则</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;当我们输入网址后发生了什么&lt;/li&gt;
&lt;li&gt;HTTP协议详解&lt;/li&gt;
&lt;li&gt;HTTP协议安全&lt;/li&gt;
&lt;li&gt;后台服务与HTTP&lt;/li&gt;
&lt;li&gt;反向代理与web服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;浏览器行为与HTTP协议&quot;&gt;&lt;a href=&quot;#浏览器行为与HTTP协议&quot; class=&quot;headerlink&quot; title=&quot;浏览器行为与HTTP协议&quot;&gt;&lt;/a&gt;浏览器行为与HTTP协议&lt;/h3&gt;&lt;p&gt;处理流程：&lt;br&gt;1.输入网址并回车&lt;br&gt;2.解析域名&lt;br&gt;3.浏览器发送http请求&lt;br&gt;4.服务器处理请求&lt;br&gt;5.服务器返回HTML响应&lt;br&gt;6.浏览器处理HTML页面&lt;br&gt;7.继续请求其他资源&lt;/p&gt;
    
    </summary>
    
    
      <category term="http https" scheme="http://yoursite.com/tags/http-https/"/>
    
  </entry>
  
  <entry>
    <title>小程序面向个人开发者开放</title>
    <link href="http://yoursite.com/2017/03/28/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%9D%A2%E5%90%91%E4%B8%AA%E4%BA%BA%E5%BC%80%E5%8F%91%E8%80%85%E5%BC%80%E6%94%BE/"/>
    <id>http://yoursite.com/2017/03/28/小程序面向个人开发者开放/</id>
    <published>2017-03-28T12:12:26.000Z</published>
    <updated>2017-03-29T07:10:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>3月27日晚上10点，微信官方通过“微信公开课”和“微信公众平台”发布重磅消息称，小程序对个人开发者开放注册，并宣布小程序新增六大能力。</li>
</ul>
</blockquote>
<p>   新增6大功能为：个人开发者开放、公众号自定义菜单跳小程序、公众号模版消息可打开相关小程序、模板消息跳小程序 、绑定时可发送模板消息、兼容线下二维码、App分享用小程序打开。</p>
<p>1.<strong>个人开发者可申请小程序</strong></p>
<p>   小程序开放个人开发者申请注册，个人用户可访问微信公众平台，扫码验证个人身份后即可完成小程序帐号申请并进行代码开发。</p>
<p>   申请个人开发者的个人需要实名。现在，对小程序感兴趣，并且有开发能力者，可以在开放的类目范围内，通过开发小程序，把自己的“一个想法”变成“一件作品”，并为微信用户所使用，进一步发挥开发者的个人价值。</p>
<a id="more"></a>    
<blockquote>
<ul>
<li><p>个人开发者可以做些什么？</p>
</li>
<li><p>Q：作为一个个人开发者，我可以申请注册几个小程序？可以开发什么类型的小程序？</p>
</li>
<li><p>A：每个个人可申请5个小程序（身份证+微信号合计5个），不占用组织类型帐号的名额。目前，个人开发者可以开发生活服务、工具、旅游、出行与交通、餐饮、商业服务、体育、快递业与邮政、教育等类别的小程序。后续，支持的类目会随平台规则而调整。</p>
</li>
<li><p>Q：和组织类型开发者相比，个人开发者在小程序的开发上有什么不同？</p>
</li>
<li><p>A：和组织类型开发者相比，个人类型开发者的开发流程更短：注册——验证身份——填写详细信息——开发——提交代码审核——审核通过后可发布。</p>
</li>
<li><p>Q：目前，小程序对于个人开发者开放了哪些能力？</p>
</li>
<li><p>A：小程序对个人开发者开放的API能力和组织类型的基本一致，如消息通知（客服消息、模板消息）、自定义二维码生成等能力，也支持同主体的公众号关联。</p>
</li>
<li><p>在开放能力上，我们希望有更多的突破，以帮助个人能在开发中更好地运用开发工具。因此，我们开放了更多的接口权限给到了个人开发者。目前，个人小程序不支持进行个人认证、支付和卡券功能。</p>
</li>
</ul>
</blockquote>
<p>请访问：<a href="mp.weixin.qq.com">微信公众平台mp.weixin.qq.com</a></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/Sl2B4aOmG2MdomPTjz8wt5AhZ9eJvcD1tM4L4YnHKDibxRicaWwK0pmxSqT4YGKDdGY2k4XMdHtnSVyOxPb9Hyzg/640?wx_fmt=jpeg" alt=""></p>
<p>2.<strong>公众号自定义菜单点击可打开相关小程序</strong></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Sl2B4aOmG2MdomPTjz8wt5AhZ9eJvcD1V9w0XyibD2zmNYSEAECoz89USoxEWZoia2g9YFicEkWwPibVv41uic2HrAA/640?wx_fmt=png" alt=""></p>
<p>公众号可将已关联的小程序页面放置到自定义菜单中，用户点击后可打开该小程序页面。公众号运营者可在公众平台进行设置，也可以通过自定义菜单接口进行设置。</p>
<p>详见开发文档：<a href="mp.weixin.qq.com/wiki">微信公众平台文档mp.weixin.qq.com/wiki -自定义菜单</a></p>
<p>3.<strong>公众号模版消息可打开相关小程序</strong></p>
<p>公众号已关联的小程序页面可以配置到公众号的模版消息中，用户点击公众号下发的模版消息，可以打开对应的小程序页面。</p>
<p>详见开发文档：微信公众平台文档(mp.weixin.qq.com/wiki)-模版消息</p>
<p>4.<strong>公众号关联小程序时，可选择给粉丝下发通知</strong></p>
<p><img src="https://mmbiz.qlogo.cn/mmbiz_png/Sl2B4aOmG2MdomPTjz8wt5AhZ9eJvcD1ZqTbVmKAmSibaCZppvxrYl293fhmSasBl68dKYhGtsLGtAiaN2CE37RA/0?wx_fmt=png" alt=""></p>
<p>公众号关联小程序时，可选择给粉丝下发通知消息，粉丝点击该通知消息可以打开小程序。该消息不占用原有群发条数。</p>
<p>5.<strong>移动App可分享小程序页面</strong></p>
<p>开发者可以把小程序绑定到微信开放平台。绑定后，同一微信开放平台帐号下的App可分享已绑定的小程序页面到微信内的会话或群聊。APP链接分享到微信，点开就是小程序。</p>
<p>详见开发文档：<a href="open.weixin.qq.com">微信开放平台open.weixin.qq.com -资源中心-移动应用-分享与收藏功能</a></p>
<p>6.<strong>扫描普通链接二维码可打开小程序</strong></p>
<p>商户如果在线下已铺设了普通链接二维码，可在公众平台的小程序管理后台进行配置，用户扫描该原有线下普通链接二维码可直接打开小程序。</p>
<p>微信官方称，摩拜单车扫描单车二维码直接进入小程序的能力，现在通用了。</p>
<h2 id="总结：公众号和小程序新增三种连接方式："><a href="#总结：公众号和小程序新增三种连接方式：" class="headerlink" title="总结：公众号和小程序新增三种连接方式："></a>总结：公众号和小程序新增三种连接方式：</h2><p>在支持公众号绑定相关小程序后，公众号和小程序有了三种新的连接跳转方式：</p>
<p>①公众号可以把自己关联的小程序放在自定义菜单中，用户点击可直达小程序。</p>
<p>②公众号模版消息可打开相关小程序。通过公众号，公众号运营者可以推送关联的小程序页面了。</p>
<p>③公众号绑定相关小程序时，可选择给粉丝下发通知。公众号运营者可以通知粉丝，“我绑定了这个小程序”，粉丝点击消息就可以打开小程序。（此消息不占用原有群发条数）</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;3月27日晚上10点，微信官方通过“微信公开课”和“微信公众平台”发布重磅消息称，小程序对个人开发者开放注册，并宣布小程序新增六大能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;   新增6大功能为：个人开发者开放、公众号自定义菜单跳小程序、公众号模版消息可打开相关小程序、模板消息跳小程序 、绑定时可发送模板消息、兼容线下二维码、App分享用小程序打开。&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;个人开发者可申请小程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   小程序开放个人开发者申请注册，个人用户可访问微信公众平台，扫码验证个人身份后即可完成小程序帐号申请并进行代码开发。&lt;/p&gt;
&lt;p&gt;   申请个人开发者的个人需要实名。现在，对小程序感兴趣，并且有开发能力者，可以在开放的类目范围内，通过开发小程序，把自己的“一个想法”变成“一件作品”，并为微信用户所使用，进一步发挥开发者的个人价值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="小程序开发" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>javascript函数式编程</title>
    <link href="http://yoursite.com/2017/03/28/javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/03/28/javascript函数式编程/</id>
    <published>2017-03-28T07:52:35.000Z</published>
    <updated>2017-08-09T08:57:20.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>函数式编程思维</li>
<li>函数式编程常用核心概念</li>
<li>当下函数式编程最热的库</li>
</ul>
<h2 id="函数式编程基础理论"><a href="#函数式编程基础理论" class="headerlink" title="函数式编程基础理论"></a>函数式编程基础理论</h2><p>1.函数式编程（Functional Programming）相对计算机历史而言是一个古老的概念，甚至早于第一台计算机的诞生。函数式编程的基础模型来源于 ℷ (lambda x=x&gt;x*2)演算，<br>     而 ℷ 演算并非设计于在计算机上执行，它是一套用于研究函数定义、函数应用和递归的形式系统。<br>2.函数式编程不是用函数来编程，也不是传统的面向过程编程。是将复杂的函数符合成简单的函数（计算理论、递归论、ℷ 演算）。运算过程尽量写成一系列嵌套的函数调用。<br>3.javascript是披着 C 外衣的lisp。<br>4.真正的火热是随着React的高阶函数而逐步升温。</p>
<a id="more"></a>
<blockquote>
<ul>
<li><strong>函数</strong>：函数是一等公民，指的是<strong>函数与其他数据类型一样</strong>，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</li>
<li><strong>不可变量</strong>：在函数编程中，我们通常理解的变量在函数式编程中也被函数代替了。<strong>在函数编程中变量仅仅代表某个表达式</strong>。这里所说的’变量’是不能被修改的。<br>  所有的变量只能被赋值一次初值。</li>
<li>map &amp; reduce 他们是最常用的函数式编程的方法。</li>
</ul>
</blockquote>
<h2 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h2><ul>
<li>纯函数</li>
<li>函数的柯里化</li>
<li>函数组合</li>
<li>Point Free</li>
<li>声明式与命令式代码</li>
<li>惰性求值</li>
</ul>
<p>1.纯函数：对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。</p>
<pre><code>var arr=[1,2,3,4,5];
// Array.slice是纯函数，因为它没有副作用，对于固定的输入，输出总是固定的
xs.slice(0,3);
xs.slice(0,3);
xs.slice(0,3);
xs.slice(0,3);
</code></pre><p>优缺点：</p>
<pre><code>import_from &apos;lodash&apos;;
var sin=_.memorize(x=&gt;Math.sin(x));
//第一次计算的时候会稍微慢一点 var a=sin(1);
//第二次有了缓存，速度极快  var b=sin(1);
</code></pre><p>纯函数不仅可以有效降低系统的复杂度，还有很多很棒的特性，必如<strong>可缓存性</strong>；</p>
<pre><code>//不纯的
var min=18;
var checkage = age =&gt; age &gt;18;
</code></pre><p>在不纯的版本中，checkage不仅取决于age还有外部依赖的变量min。纯的checkage把关键数字18硬编码在函数内部，扩展性比较差，柯里化优雅的函数式解决。</p>
<p>2.函数的柯里化：传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
<pre><code>var checkage = min =&gt;(age =&gt; age &gt;min);
var checkage18 =checkage(18);
checkage18(20); 
</code></pre><p>优缺点：</p>
<pre><code>import {curry} from &apos;lodash&apos;;
var match=curry((reg,str)=&gt; str.match(reg));
var filter=curry((f,arr)=&gt; arr.filter(f));
var haveSpace = match(/\s+/g);
haveSpave(&quot;ffffff&quot;);
haveSpace(&quot;a b&quot;);

filter(haveSpace,[&quot;abcdefg&quot;,&quot;Hello World&quot;]);
//=&gt;[&quot;Hello world&quot;];
</code></pre><font color="red" size="16">事实上柯里化是一种 “预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的”缓存”，是一种非常高效的编写函数的方法。</font>

<p>3.函数组合：纯函数以及如何把它柯里化写出的层叠代码h(g(f(x))),为了解决函数嵌套问题，我们需要用到”函数组合”。</p>
<pre><code>//我们用柯里化改，让多个函数像拼积木一样
const compose = (f,g) =&gt; (x =&gt; f(g(x)));
var first = arr =&gt; arr[0];
var reverse = arr =&gt; arr.reverse();
var last = compose(first,reverse);
last([1,2,3,4,5]);
</code></pre><p>4.Point Free: 把一些对象自带的方法转化成纯函数，不要命名转瞬即逝的中间变量。</p>
<pre><code>const f = str =&gt; str.toUpperCase().split(&apos;&apos;);
</code></pre><p>这个函数中，我们使用了str作为中间变量，但是这个中间变量除了让代码长以外毫无意义。</p>
<p>优缺点: </p>
<pre><code>var toUpperCasre = word =&gt; word.toUpperCase();
var split = x =&gt; (str =&gt; str.split(x));
var f = compose(split(&apos;&apos;),toUpperCase);
f(&quot;abcd efgh&quot;);
</code></pre><p>这种风格能够帮助我们减少不必要的命名，让代码保持简洁和通用。</p>
<p>5.声明式与命令式代码</p>
<p>命令式代码：通过编写一条又一条指令让计算机执行一些动作，一般都会涉及到很多繁杂的细节。<br>声明式代码：通过写表达式的方法来声明我们想干什么，而不是通过一步一步的指示。</p>
<pre><code>//命令式
let CEOs=[];
for(var i=0;i&lt;companies.length;i++){
    CEOs.push(comanies[i].CEO);
}
//声明式
let CEOs=companies.map(c =&gt; c.CEO);
</code></pre><p>优缺点：函数式编程的一个明显好处就是这种声明式的代码，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的，专注于编写业务代码。<br>优化代码时，只需要集中在稳定坚固的函数内部。相反，不纯的函数式的代码会产生副作用或者依赖外部系统环境，使用他们的时候总要考虑这些副作用，<br>在复杂的系统中，这对于程序员是极大的负担。</p>
<p>6.惰性求值、惰性函数</p>
<p>在指令式语言中以下代码会按顺序执行，由于每个函数都有可能改动或者依赖于外部状态，因此必须顺序执行。<br>把concatenate 换成另外一个函数，这个函数中又条件判断语句，实际上只会需要两个参数中的其中一个，<br>那么就没有必要执行计算另外一个参数的函数了。</p>
<pre><code>var s1=somewhatlongOperation1();
var s2=somewhatlongOperation2();
var s3=concatenate(s1,s2);
function somewhatlongOperation1(){somewhatlongOperation1}
</code></pre><h2 id="更加专业术语"><a href="#更加专业术语" class="headerlink" title="更加专业术语"></a>更加专业术语</h2><ul>
<li>高阶函数</li>
<li>尾调用优化</li>
<li>闭包</li>
<li>容器、Functor</li>
<li>错误处理、Either</li>
<li>IO</li>
<li>Monad</li>
</ul>
<p>1.高阶函数：函数当参数，把传入的函数做一个封装，然后返回这个封装函数，达到更高程度的抽象。</p>
<pre><code>//命令式
var add = function(a,b){
    return a+b;
};
function math(func,array){
    return func(array[0],array[1]);
}
math(add,[1,2]); //3
</code></pre><p>2.尾调用优化：函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。<br>   函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归需要保存大量的调用记录，很容易发生栈溢出错误，如果使用尾递归优化，<br>   将递归变为循环，那么只需要保存一个调用记录，这样就不会发生栈溢出错误了。</p>
<pre><code>//不是尾递归，无法优化
function factorial(n){
    if(n===1)return 1;
    return n * factorial(n-1);
}
function factorial(n,total){
    if(n===1) return total;
    return factorial(n-1,n*total);
} //es6强制使用尾递归
</code></pre><p>细数尾递归</p>
<p>实例一：</p>
<pre><code>function sum(n){
    if(n===1)return 1;
    return n + sum(n-1);
}

sum(5)
(5 + sum(4))
(5 + (4 + sum(3)))
(5 + (4 + (3 + sum(2))))
(5 + (4 + (3 + (2 + sum(1)))))
(5 + (4 + (3 + (2 + 1))))
(5 + (4 + (3 + 3)))
(5 + (4 + 6))
(5 + 10)
15
</code></pre><p>普通递归时，内存需要记录调用的堆栈所处的深度和位置信息。<br>在最底层计算返回值，再根据记录信息，跳回上一层级计算，然后再跳回更高一层，依次运行，直到最外层调用函数。<br>在cpu计算和内存会消耗很多，而且当深度过大时，会出现堆栈溢出。</p>
<p>实例二：   </p>
<pre><code>function sum(x,total){
    if(x === 1){
        return x + total;
    }
    return sum(x-1,x + total); 
}

sum(5,0)
sum(4,5)
sum(3,9)
sum(2,12)
sum(1,14)
15
</code></pre><p>整个计算过程是线性的，调用一次 sum(x,total)后，会进入下一个栈，相关的数据信息跟随进入，不再放在堆栈上保存。<br>当计算完最后的值之后，直接返回到最上层的sum(5,0)。这能有效的防止堆栈溢出。<br>在ECMAScript6,我们将迎来尾递归优化，通过尾递归优化，javascript代码在解释成机器码的时候，将会向while看起，也就是说，同事拥有数学表达式能力和while的效能。</p>
<p>3.闭包</p>
<p>如下例子，虽然外层的makePowerFn函数执行完毕，栈上的调用帧被释放，但是堆上的作用域并不被释放，因此power依旧可以被powerFn函数访问，这样就形成了闭包。</p>
<pre><code>function makePowerFn(power){
    function powerFn(base){
        return Math.pow(base,power);
    }
    return powerFn;
}
var square = makePowerFn(2);
square(3); //9
</code></pre><p>4.容器、Functor（函子）</p>
<blockquote>
<ul>
<li>$(…)返回的对象并不是一个原生的DOM对象，而是对于原生对象的一种封装，这在某种意义上就是一个”容器”（但它并不函数式）。</li>
<li>Functor(函子)遵守一些特定规则的容器类型。</li>
<li>Functor是一个对于函数调用的抽象，我们赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口map给容器外的函数，map一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由的选择何时何地如何操作这个函数，以至于拥有惰性求值、错误处理、异步调用等等非常棒的特性。</li>
</ul>
</blockquote>
<pre><code>var Container = fuunction(x){
    this._value = x;
}
Container.of = x =&gt; new Container(x);
//Container.of(&apos;abcd&apos;);
Container.prototype.map = function(f){
    return Container.of(f(this._value));
}
Container.of(3)
    .map(x =&gt; x+1) // =&gt;Container(4)
    .map(x =&gt; &apos;Result is&apos; + x);  // =&gt; Container(&apos;Result is 4&apos;);

---

var Maybe = function(x){
    this._value = x;
}
Maybe.of = function(x){
    return new Maybe(x);
}
Maybe.prototype.map=function(f){
    return this.isNothing()? Maybe.of(null) : Maybe.of(f(this._value));
}
Maybe.prototype.isNothing = function(){
    return (this._value === null || this._value === undefined);
}
//新的容器我们称为 Maybe(原型来自于 Haskell)
</code></pre><p>5.错误处理、Either</p>
<blockquote>
<ul>
<li>我们的容器能做的事情太少，try/catch/throw 并不是”纯”的，因为它从外部接管了我们的函数，并且在这个函数出错时抛弃了它的返回值。</li>
<li>Promise 是可以调用 catch来集中处理错误的。</li>
<li>事实上Either并不只是用来做错误处理的，它表示了逻辑或，范畴学里的coproduc。</li>
</ul>
</blockquote>
<pre><code>var left = function(x){
    this._value = x;
}
var Right = function(x){
     this._value = x;
}

Left.of = function(x){
    return new Left(x);
}
Right.of=function(x){
    return new Rgith(x);
}

---
//这里不同
Left.prototype.map = function(f){
    return this;
}
Rgiht.prototype.map = function(f){
    return Right.of(f(this._value));
}
</code></pre><p>left和Right 唯一的区别在于 map方法的实现，Right.map的行为和之前提到的map函数一样。<br>但是left.map就很不同了，它不会对容器做任何事情，只是很简单地把这个容器拿进来又扔出去。<br>这个特性意味着，left可以用来传递一个错误消息。</p>
<pre><code>var getAge = user =&gt; user.age ? Right.of(user.age):Left.of(&quot;ERROR&quot;);

getAge({name:&apos;stark&apos;,age:&apos;21&apos;}).map(age =&gt; &apos;Age is&apos;+ age);
// =&gt; Right(&apos;Age is 21&apos;)
get Age({name:&apos;stark}).map(age =&gt; &apos;Age is&apos; +age);
//=&gt; Left(&apos;ERROR&apos;)
</code></pre><p>left 可以让调用链中任意一环的错误立刻返回到调用链的尾部，这给我们错误处理带来了很大的方便，再也不用一层一层的try/catch。</p>
<p>6.IO</p>
<p>真正的程序总要去接触不纯的世界。如下例子就依赖于window。</p>
<pre><code>function readlocalStorage(){
    return window.localStorage;
}
</code></pre><blockquote>
<ul>
<li>IO跟前面几个Functor不同的地方在于，它的_value是一个函数。它把不纯的操作(比如IO、网络请求、DOM)包裹到一个函数内，从而延迟这个操作的执行。所以我们认为，<strong>IO包含的是被包裹的操作的返回值</strong>。</li>
<li>IO其实也算是惰性求值。</li>
<li>IO负责了调用链积累了很多不纯的操作，带来的复杂性和不可维护性。</li>
</ul>
</blockquote>
<pre><code>impport _from &apos;lodash&apos;;
var compose = _.flowRight;

var IO = function(f){
    this._value = f;
}

IO.of = x =&gt; new IO(_ =&gt; x);

IO.prototype.map = function(f){
    return new IO(compose(f,this._value));
}
</code></pre><h2 id="流行的几大函数式编程库"><a href="#流行的几大函数式编程库" class="headerlink" title="流行的几大函数式编程库"></a>流行的几大函数式编程库</h2><ul>
<li>RxJS</li>
<li>cycleJS</li>
<li>lodashJS</li>
<li>underscoreJS</li>
<li>ramdajs</li>
</ul>
<p>1.Rxjs从诞生依赖一直都不温不火，但它函数响应式编程(Functional Reactive Programming ,FRP)的理念非常先进，虽然或许对于大部分应用环境，外部输入事件并不是太频繁，并不需要引入一个如此庞大的FRP体系，但我们也可以了解一下它又哪些优秀的特性。<br>  <strong>  在 Rxjs中，所有的外部输入（用户输入、网络请求等等）都被视作一种【事件流】：</strong><br>  用户点击了按钮 –&gt; 网络请求成功 –&gt; 用户键盘输入 –&gt; 某个定时事件发生 –&gt; 这种事件流特别适合实例游戏，上上下下上上下下<br>  举个例子，下面这段代码会监听点击事件，每两次点击事件产生一次事件相应：</p>
<pre><code>var clicks = Rx.Observable
    .fromEvent(document,&apos;click&apos;)
    .bufferCount(2)
    .subscribe(x =&gt; console.log(x)); //打印出两次点击事件
</code></pre><p>2.Cycle.js 是一个基于Rxjs的框架，它是一个彻彻底底的 FRP 理念的框架，和 React一样支持virtual DOM 、JSX语法，但现在似乎还没有看到大型的应用经验。<br>     本质的讲，它就是在 Rxjs的基础上加入了对 virtual DOM、容器和组件的支持，比如下面就是一个简单的【开关】按钮：   </p>
<pre><code>function main(sources){
   const sinks={
       DOM : sources.DOM.select(&apos;input&apos;).events(&apos;click&apos;)
       .map(ev =&gt; ev.target.checked)
       .startWith(false)
       .map(toggled =&gt;
           &lt;div&gt;
               &lt;input type=&quot;checkbox&quot; /&gt; Toggle me
               &lt;p&gt;{toggled ? &apos;ON&apos; ： &apos;off&apos;}&lt;/p&gt;
           &lt;/div&gt;
       )
   };
   return sinks;
}

const drivers={
   DOM:makeDOMDriver(&apos;#app&apos;)
};

run(main,drivers);    
</code></pre><p>3.Underscore 是一个 javascript工具库，它提供了一整套函数式编程实用功能，但是没有扩展任何 javascript内置对象。</p>
<blockquote>
<ul>
<li><p>它解决了这个问题：”如果我面对一个空白的html页面，并希望立即开始工作，我需要什么？”它你不了jquery没有实现的功能，同时又是backbone必不可少的部分。</p>
</li>
<li><p>underscore提供了100多个函数，包括常用的：map、filter、invoke 当然还有更专业的辅助函数，如：函数绑定、javascript模板功能、创建快速索引、强类型相等测试等等。</p>
</li>
</ul>
</blockquote>
<p>4.lodash是一个具有一致接口、模块化、高性能等特性的javascript工具库，是unserscorejs的 fork,最初目标也是”一致的跨浏览器行为，并改善性能。”</p>
<blockquote>
<ul>
<li><p>lodash采用延迟计算，意味着我们的链式方法在显式或者隐式的value()调用之前是不会执行的，因此lodash可以进行 shortcut(捷径)fusion(融合)这样的优化，通过合并链式大大降低迭代的次数，从而大大提升其执行性能。</p>
</li>
<li><p>就如同jquery在全部函数前加全局的$一样，lodash使用全局的 _来提供对工具的快速访问。     </p>
</li>
</ul>
</blockquote>
<pre><code>var abc = function(a,b,c){
   return [a,b,c];
};
var currid = _.curry(abc);
curried(1)(2)(3);

------
function square(n){
   return n*n;
} 
var addSquare = _.flowRight(square,_.add);
addSquare(1,2);
// =&gt; 9
</code></pre><p>5.Ramdajs: 是一个非常优秀的js工具库，跟同类比更函数式主要体现在以下几个原则。</p>
<blockquote>
<ul>
<li>ramda里面的提供的函数全部都是curry的，意味着函数没有默认参数可选参数从而减轻认知函数的难度。</li>
<li>ramda 推崇pointfree简单的说就是使用简单函数组合实现一个复杂功能，而不是单独写一个函数操作临时变量。</li>
<li>ramda有个非常好用的参数占位符 R._ 大大减轻了函数在 pointfree过程中参数位置的问题。</li>
<li>相比underscore/lodash感觉更干净很多。</li>
</ul>
</blockquote>
<h2 id="函数式编程实际应用场景"><a href="#函数式编程实际应用场景" class="headerlink" title="函数式编程实际应用场景"></a>函数式编程实际应用场景</h2><ul>
<li>易调试、热部署、并发</li>
<li>单元测试</li>
<li>总结与补充</li>
</ul>
<h3 id="易调试、热部署、并发"><a href="#易调试、热部署、并发" class="headerlink" title="易调试、热部署、并发"></a>易调试、热部署、并发</h3><blockquote>
<ul>
<li><p>函数式编程中得每个符号都是const的，于是没有什么函数会有副作用。<br> 谁也不能在运行时修改任何东西，也没有函数可以修改在它的作用域之外修改什么值给其他函数继续使用。<br> 这意味着<strong>决定函数执行结果的唯一因素就是他的返回值，而影响其返回值的唯一因素就是它的参数。</strong></p>
</li>
<li><p>函数式变成不需要考虑”死锁”（deadlock）,因为它不仅改变量，所以根本不存在”锁”线程的问题。不必担心<br>  一个线程的数据被另一个线程修改，所以可以发那个心把工作分摊到多个线程，部署”并发编程”（concurrency）。</p>
</li>
<li><p>函数式编程中所有状态就是传给函数的参数，而参数都是储存在栈上的。这一特性让软件的热部署变得十分简单。<br>  只要比较一下正在运行的代码以及新的代码获得一个diff,然后用这个diff更新现有的代码，新代码的热部署就完成了。    </p>
</li>
</ul>
</blockquote>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><blockquote>
<ul>
<li><p>严格函数式编程的每一个函数都是对直接量或者表达式结果的引用，没有函数产生副作用。<br>  因为从未在某个地方修改过值，也没有函数修改过在其作用域之外的量并被其他函数使用(如类成员或全局变量)。<br>  这意味着函数求值的结果只是其返回值，而唯一影响其返回值的就是函数的参数。</p>
</li>
<li><p>这就是单元测试者的梦中仙境。对被测试程序中的每个函数，你只需在意其参数，而不必考虑函数调用顺序，不用谨慎地设置外部状态。<br>  所有要做的就是传递代表了边际情况的参数。如果程序中的每个函数都通过了单元测试，你就对这个软件的质量有了相当的自信。<br>  而命令式编程就不能这样乐观了，在java或 c++中只检查函数的返回值还不够–我们还必须验证这个函数可能修改了外部状态。</p>
</li>
</ul>
</blockquote>
<h2 id="总结与补充"><a href="#总结与补充" class="headerlink" title="总结与补充"></a>总结与补充</h2><p>函数式编程不应被视为灵丹妙药。相反的，它应被视为我们现有工具箱的一个很自然的补充—它带来的更高的可组合型，灵活性以及容错性。现代的javascript库已经开始尝试拥抱函数式编程的概念以获取这些优势。Redux作为一种 FLUX的变种实现，核心理念也是<br>状态机和函数式编程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;函数式编程思维&lt;/li&gt;
&lt;li&gt;函数式编程常用核心概念&lt;/li&gt;
&lt;li&gt;当下函数式编程最热的库&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;函数式编程基础理论&quot;&gt;&lt;a href=&quot;#函数式编程基础理论&quot; class=&quot;headerlink&quot; title=&quot;函数式编程基础理论&quot;&gt;&lt;/a&gt;函数式编程基础理论&lt;/h2&gt;&lt;p&gt;1.函数式编程（Functional Programming）相对计算机历史而言是一个古老的概念，甚至早于第一台计算机的诞生。函数式编程的基础模型来源于 ℷ (lambda x=x&amp;gt;x*2)演算，&lt;br&gt;     而 ℷ 演算并非设计于在计算机上执行，它是一套用于研究函数定义、函数应用和递归的形式系统。&lt;br&gt;2.函数式编程不是用函数来编程，也不是传统的面向过程编程。是将复杂的函数符合成简单的函数（计算理论、递归论、ℷ 演算）。运算过程尽量写成一系列嵌套的函数调用。&lt;br&gt;3.javascript是披着 C 外衣的lisp。&lt;br&gt;4.真正的火热是随着React的高阶函数而逐步升温。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>vue精炼秘籍</title>
    <link href="http://yoursite.com/2017/03/28/vue/"/>
    <id>http://yoursite.com/2017/03/28/vue/</id>
    <published>2017-03-28T02:13:07.000Z</published>
    <updated>2017-04-01T02:02:23.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>Vuex理论介绍</li>
<li>Vuex核心概念</li>
<li>Vuex搭载vue-Resource&amp;vue-router</li>
<li>Vue2+Webpack2+KOA2构建大型应用</li>
</ul>
<h3 id="Vuex理论基础"><a href="#Vuex理论基础" class="headerlink" title="Vuex理论基础"></a>Vuex理论基础</h3><p>1.Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 devtools。<br>2.不开发大型单页应用尽量不要使用Vuex。<br>3.多个视图依赖于同一状态。来自不同视图的行为需要变更同一状态。<br><a id="more"></a><br><img src="/images/vue1.png" alt=""></p>
<ul>
<li>state，驱动应用的数据源；</li>
<li>view，以声明方式将state映射到视图；</li>
<li>actions，响应在view上的用户输入导致的状态变化。<br><img src="/images/vuex1.png" alt=""><h3 id="vuex-的不同"><a href="#vuex-的不同" class="headerlink" title="vuex 的不同"></a>vuex 的不同</h3>1.Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>2.你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 mutations。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>
<li>store</li>
</ul>
<pre><code>Vue.use(Vuex)
const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  }
})
store.commit(&apos;increment&apos;)
console.log(store.state.count) // -&gt; 1
</code></pre><h3 id="Vuex核心模块"><a href="#Vuex核心模块" class="headerlink" title="Vuex核心模块"></a>Vuex核心模块</h3><ul>
<li>State</li>
<li>Getters</li>
<li>Mutations</li>
<li>Actions</li>
<li>Modules</li>
</ul>
<p>1.State</p>
<ul>
<li>单一状态树，用一个对象就包含了全部的应用层级状态。</li>
<li>mapState 当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。</li>
<li>对象展开符号……mapState({})</li>
</ul>
<pre><code>import { mapState } from &apos;vuex&apos;
export default {
  computed: mapState({
    count: state =&gt; state.count,
    countAlias: ‘count&apos;,
    countPlusLocalState (state) {
      return state.count + this.localCount
    }
  }
  //…mapState({count})扩展函数符
}
</code></pre><p>2.Getters</p>
<ul>
<li>从 store 中的 state 中派生出一些状态</li>
<li>mapGetters 辅助函数仅仅是将 store 中的 getters 映射到局部计算属性</li>
<li>getters（可以认为是 store 的计算属性）</li>
</ul>
<pre><code>const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: &apos;...&apos;, done: true },
      { id: 2, text: &apos;...&apos;, done: false }
    ]
  },
  getters: {
    doneTodos: state =&gt; {
      return state.todos.filter(todo =&gt; todo.done)
    }
  }
})

computed: {
  doneTodosCount () {
    return this.$store.getters.doneTodosCount
  }
}

computed: {
    ...mapGetters([
      &apos;doneTodosCount&apos;
    ])
  }
</code></pre><p>3.Mutations</p>
<ul>
<li>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation（不能直接调用句柄，必须通过触发）</li>
<li>mutations就是vue methods</li>
<li>每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)</li>
<li>使用常量替代 Mutation 事件类型</li>
<li>mutation 必须是同步函数</li>
</ul>
<pre><code>// mutation-types.js
export const SOME_MUTATION = ‘SOME_MUTATION&apos;

// store.js
import { SOME_MUTATION } from &apos;./mutation-types&apos;

const store = new Vuex.Store({
  state: { ... },
  mutations: {
    [SOME_MUTATION] (state) {
      // mutate state
    }
  }
})


//Mutations (调用)
import { mapMutations } from ‘vuex&apos;
import { SOME_MUTATION } from &apos;./mutation-types&apos;

export default {
  methods: {
    test(){
          this.$store.commit(SOME_MUTATION)
    },
    ...mapMutations([
      &apos;SOME_MUTATION&apos; 
      // 映射 this.increment() 为 this.$store.commit(&apos;SOME_MUTATION&apos;)
    ])
  }
}
</code></pre><p>4.Actions</p>
<ul>
<li>Action 提交的是 mutation</li>
<li>Action 可以包含任意异步操作</li>
<li>mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用</li>
<li>view    store.dispatch(‘increment’)</li>
<li>action  commit(‘someMutation’)</li>
</ul>
<pre><code>actions: {
  async actionA ({ commit }) {
    commit(&apos;gotData&apos;, await getData())
  },
  async actionB ({ dispatch, commit }) {
    await dispatch(&apos;actionA&apos;) // 等待 actionA 完成
    commit(&apos;gotOtherData&apos;, await getOtherData())
  }
}


//Actions（调用）
import { mapActions } from &apos;vuex&apos;
export default {
  methods: {
    test(){
         store.dispatch(‘actionB&apos;);
    },
    ...mapActions([
      ‘actionB&apos;
      // 映射 this.increment() 
     //this.$store.dispatch(‘actionB’)
    ])
  }
}
</code></pre><p>5.Modules</p>
<ul>
<li>Vuex 运行我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割。</li>
<li>store 创建之后，你可以使用 store.registerModule 方法注册模块：</li>
</ul>
<pre><code>const moduleA = {
  state: { ... },
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: { ... },
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})

store.state.a // -&gt; moduleA 的状态
store.state.b // -&gt; moduleB 的状态

store.registerModule(&apos;myModule&apos;, {
  // ...
})
</code></pre><p>6.Plugins</p>
<ul>
<li>Vuex 的 store 接受 plugins 选项，这个选项暴露出每次 mutation 的钩子。Vuex 插件就是一个函数，它接收 sotre 作为唯一参数。</li>
<li>在插件中不允许直接修改状态——类似于组件，只能通过提交 mutation 来触发变化。</li>
<li>自定义的状态快照。</li>
</ul>
<pre><code>const myPlugin = store =&gt; {
  // 当 store 初始化后调用
  store.subscribe((mutation, state) =&gt; {
    // 每次 mutation 之后调用
    // mutation 的格式为 { type, payload }
  })
}

const store = new Vuex.Store({
  plugins: [myPlugin]
})
</code></pre><h3 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h3><ul>
<li>Vuex的思维处理表单<input :value="message" @input="updateMessage"></li>
<li>测试Actions需要增加一个mocking服务层，测试文件中用 mock 服务回应 API 调用。为了便于解决 mock 依赖，可以用 Webpack 和 inject-loader 打包测试文件。</li>
<li>Hot Module Replacement API，Vuex 支持在开发过程中热重载 mutation、modules、actions、和getters。   </li>
</ul>
<pre><code>测试Actions演示
import { expect } from &apos;chai&apos;
const actionsInjector = require(&apos;inject!./actions&apos;)
// 使用 mocks 创建模块
const actions = actionsInjector({
  &apos;../api/shop&apos;: {
    getProducts (cb) {
      setTimeout(() =&gt; {
        cb([ /* mocked response */ ])
      }, 100)
    }
  }
})


测试代码
describe(&apos;actions&apos;, () =&gt; {
  it(&apos;getAllProducts&apos;, done =&gt; {
    testAction(actions.getAllProducts, [], {}, [
      { type: &apos;REQUEST_PRODUCTS&apos; },
      { type: &apos;RECEIVE_PRODUCTS&apos;, payload: { } }
    ], done)
  })
})
</code></pre><h3 id="vuex-router-sync"><a href="#vuex-router-sync" class="headerlink" title="vuex-router-sync"></a>vuex-router-sync</h3><p>1.视图层</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
  &lt;h1&gt;Hello App!&lt;/h1&gt;
  &lt;p&gt;
    &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;
    &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt;
  &lt;/p&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
&lt;/div&gt;
</code></pre><p>2.结合 Vuex</p>
<pre><code>import { sync } from &apos;vuex-router-sync&apos;
import store from &apos;./vuex/store&apos; 
import router from &apos;./router&apos; 
sync(store, router) 
this.$store.state.route.path   // current path (string)
this.$store.state.route.params // current params (object) this.$store.state.route.query  // current query (object)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Vuex理论介绍&lt;/li&gt;
&lt;li&gt;Vuex核心概念&lt;/li&gt;
&lt;li&gt;Vuex搭载vue-Resource&amp;amp;vue-router&lt;/li&gt;
&lt;li&gt;Vue2+Webpack2+KOA2构建大型应用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Vuex理论基础&quot;&gt;&lt;a href=&quot;#Vuex理论基础&quot; class=&quot;headerlink&quot; title=&quot;Vuex理论基础&quot;&gt;&lt;/a&gt;Vuex理论基础&lt;/h3&gt;&lt;p&gt;1.Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 devtools。&lt;br&gt;2.不开发大型单页应用尽量不要使用Vuex。&lt;br&gt;3.多个视图依赖于同一状态。来自不同视图的行为需要变更同一状态。&lt;br&gt;
    
    </summary>
    
    
      <category term="vuejs   vue" scheme="http://yoursite.com/tags/vuejs-vue/"/>
    
  </entry>
  
  <entry>
    <title>CSS3核心高级技巧</title>
    <link href="http://yoursite.com/2017/03/21/CSS3%E6%A0%B8%E5%BF%83%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2017/03/21/CSS3核心高级技巧/</id>
    <published>2017-03-21T03:32:46.000Z</published>
    <updated>2017-04-06T00:55:55.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>早期的双飞翼布局+CSS HACK</li>
<li>基于移动端的PX与REM转换兼容方案</li>
<li>弹性盒模型与Reset的选择</li>
<li>自制的ICON-FONT与常用字体排版</li>
<li>CSS代码检测与团队项目规范</li>
<li>CSS绘制特殊图形 高级技巧</li>
<li>CSS高效动画 WorkFlow与分层（详细讲解）</li>
</ul>
<h4 id="双飞翼布局-CSS-HACK"><a href="#双飞翼布局-CSS-HACK" class="headerlink" title="双飞翼布局+CSS HACK"></a>双飞翼布局+CSS HACK</h4><ul>
<li>position</li>
<li>float </li>
<li>负边距</li>
<li>等高</li>
<li>盒子模型</li>
<li>清除浮动 </li>
</ul>
<a id="more"></a>
<h4 id="IE6经典bug"><a href="#IE6经典bug" class="headerlink" title="IE6经典bug"></a>IE6经典bug</h4><blockquote>
<ul>
<li><p><strong>IE6怪异解析之padding与border算入宽高</strong><br>原因：未加文档声明造成非盒模型解析<br>解决方法：加入文档声明&lt;!doctype html&gt; </p>
</li>
<li><p><strong>IE6在块元素、左右浮动、设定maring时造成margin双倍（双边距）</strong><br>解决方法：display:inline </p>
</li>
<li><p>以下三种其实是同一种bug，其实也不算是个bug，举个例子：父标签高度20，子标签11，垂直居中，20-11=9，9要分给文字的上面与下面，怎么分？IE6就会与其它的不同，所以，尽量避免。<br>1）<strong>字体大小为奇数之边框高度少1px</strong><br>解决方法：字体大小设置为偶数或line-height为偶数<br>2）<strong>line-height，文本垂直居中差1px</strong><br>解决方法：padding-top代替line-height居中，或line-height加1或减1<br>3）<strong>与父标签的宽度的奇偶不同的居中造成1px的偏离</strong><br>解决方法：如果父标签是奇数宽度，则子标签也用奇数宽度;如果是父标签偶数宽度，则子标签也用偶数宽度  </p>
</li>
<li><p><strong>内部盒模型超出父级时，父级被撑大</strong><br>解决方法：父标签使用overflow:hidden </p>
</li>
<li><p><strong>line-height默认行高bug</strong><br>解决方法：line-height设值 </p>
</li>
<li><p><strong>行标签之间会有一小段空白</strong><br>解决方法：float或结构并排(可读性差，不建议)</p>
</li>
<li><p><strong>标签高度无法小于19px</strong><br>解决方法：overflow:hidden;</p>
</li>
<li><p><strong>左浮元素 margin-bottom 失效</strong><br>解决方法：显示设置高度 or 父标签设置 padding-bottom代替子标签的margin-bottom 再放个标签让父标签浮动，子标签<br>margin-bototm，即（margin-bottom与float不同时作用于一个标签）</p>
</li>
<li><p><strong>img于块元素中，底边多处空白</strong><br>解决方法：父级设置overflow:hidden;或img{display:block;或 img:-5px;</p>
</li>
<li><p><strong>li之间会有间距</strong><br>解决方法：float:left;</p>
</li>
<li><p><strong>块元素中有文字及右浮动的元素，行元素换行</strong><br>解决方法：将行元素于块元素内的文字前</p>
</li>
<li><p><strong>position下的left,bottom错位</strong><br>解决方法：为父级（relative层）设置宽高或者添加 *zoom:1</p>
</li>
<li><p><strong>子级中有设置position,则父级overflow失效</strong><br>解决方法：为父级设置position:relative</p>
</li>
</ul>
</blockquote>
<h3 id="基于移动端的PX与REM转换兼容方案"><a href="#基于移动端的PX与REM转换兼容方案" class="headerlink" title="基于移动端的PX与REM转换兼容方案"></a>基于移动端的PX与REM转换兼容方案</h3><ul>
<li>different size  different DPR</li>
<li>目前的设计稿一般式640 750 1125 ，一般要先均分成100份，（简荣芳vh,vm）750/10=75px; div宽是240px<em>120px  css<br>的书写改为3.2rem </em> 1.6rem。配合响应式修改html根的大小。</li>
<li>字体不建议使用rem,data-dpr属性动态设置字体大小。屏幕变大放更多文字，或者屏幕更大放更多的字。</li>
<li>神奇的padding/margin-top等比例缩放间距。</li>
</ul>
<h3 id="弹性盒模型与Reset的选择"><a href="#弹性盒模型与Reset的选择" class="headerlink" title="弹性盒模型与Reset的选择"></a>弹性盒模型与Reset的选择</h3><ul>
<li>flex模型</li>
<li>*的杀伤力太大</li>
<li>reset.css重置 Normalize.css修复 Neat.css融合</li>
<li>html{box-sizing:border-box;}<br> :before,X:after{box-sizing:inherit;}</li>
</ul>
<h3 id="ICON-FONT与常用字体排版"><a href="#ICON-FONT与常用字体排版" class="headerlink" title="ICON-FONT与常用字体排版"></a>ICON-FONT与常用字体排版</h3><ul>
<li>no-images时代，不超过纯色为2的图像</li>
<li>宋体非宋体 黑体非黑体 windows下的宋体叫中易宋体 SimSun,Mac是华文宋体STSong。Windows下的黑体叫中易黑体SimHei,<br>Mac华文黑体STHeiti。</li>
<li>不要只写中文字体名，保证西文字体在中文字体前面。Mac-linux-windows</li>
<li>切忌不要直接使用设计师psd的设计font-family，关键时刻再去启动font-face(Typo.css,Entry.css,Type.css)</li>
<li>font-family : sans-serif;系统默认，字体多个单词组成加引号。</li>
</ul>
<h3 id="CSS代码检测团队项目规范"><a href="#CSS代码检测团队项目规范" class="headerlink" title="CSS代码检测团队项目规范"></a>CSS代码检测团队项目规范</h3><p>1.不要使用多个class选择元素，如a.foo.boo,这在ie6及以下不能正确解析<br>2.移除空的css规则，如a{}<br>3.正确使用显示属性，如display:inline不要和width,height,float,margin,padding同时使用<br>display:inline-block不要和float同时使用等<br>4.避免过多的浮动，当浮动次数超过十次时，会显示警告<br>5.避免使用过多的字号，当字号声明超过十种时，显示警告<br>6.避免使用过多的web字体，当使用超过五次时，显示警告<br>7.避免使用id作为样式选择器<br>8.标题元素只定义一次<br>9.使用width:100%时要小心<br>10.属性值为0时不要写单位<br>11.各浏览器专属的css属性要有规范，例如.foo{-moz-border-radius:5px;border-radius:5px}<br>12.避免使用看起来像正则表达式的css3选择器<br>13.遵守合模型规则</p>
<h3 id="CSS绘制高级技巧"><a href="#CSS绘制高级技巧" class="headerlink" title="CSS绘制高级技巧"></a>CSS绘制高级技巧</h3><ul>
<li>border &amp;&amp; border-radius 造就万千可能</li>
<li>linear-gradient();radial-gradient();<br>渐变轴：每个色标的推进以圆心为中心同心圆扩散。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;早期的双飞翼布局+CSS HACK&lt;/li&gt;
&lt;li&gt;基于移动端的PX与REM转换兼容方案&lt;/li&gt;
&lt;li&gt;弹性盒模型与Reset的选择&lt;/li&gt;
&lt;li&gt;自制的ICON-FONT与常用字体排版&lt;/li&gt;
&lt;li&gt;CSS代码检测与团队项目规范&lt;/li&gt;
&lt;li&gt;CSS绘制特殊图形 高级技巧&lt;/li&gt;
&lt;li&gt;CSS高效动画 WorkFlow与分层（详细讲解）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;双飞翼布局-CSS-HACK&quot;&gt;&lt;a href=&quot;#双飞翼布局-CSS-HACK&quot; class=&quot;headerlink&quot; title=&quot;双飞翼布局+CSS HACK&quot;&gt;&lt;/a&gt;双飞翼布局+CSS HACK&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;position&lt;/li&gt;
&lt;li&gt;float &lt;/li&gt;
&lt;li&gt;负边距&lt;/li&gt;
&lt;li&gt;等高&lt;/li&gt;
&lt;li&gt;盒子模型&lt;/li&gt;
&lt;li&gt;清除浮动 &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="css3" scheme="http://yoursite.com/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>vue项目搭建</title>
    <link href="http://yoursite.com/2017/03/20/vue%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2017/03/20/vue项目搭建/</id>
    <published>2017-03-20T01:16:11.000Z</published>
    <updated>2017-08-09T23:14:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>需要的东西：</p>
<ul>
<li>node.js环境（npm包管理器）</li>
<li>vue-cli 脚手架构建工具</li>
<li>cnpm  npm的淘宝镜像</li>
</ul>
<h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><p>1.从node.js官网下载并安装node，安装过程很简单，一路“下一步”就可以了（傻瓜式安装）。<br>安装完成之后，打开命令行工具，输入 <strong>node -v</strong>，如下图，如果出现相应的版本号，则说明安装成功。<br><a id="more"></a><br>2.npm包管理器，是集成在node中的，所以，直接输入 <strong>npm -v</strong> 就会如下图所示，显示出npm的版本信息。<br>node环境已经安装完成，npm包管理器也有了。由于有些npm有些资源被屏蔽或者是国外资源的原因，经常会导致用npm安装依赖包的时候失败，所有我还需要npm的国内镜像—cnpm。<br><img src="/images/170410-1.png" alt=""><br>3.安装cnpm<br>在命令行中输入 <strong>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org" target="_blank" rel="external">http://registry.npm.taobao.org</a></strong> 然后等待安装完成。<br>完成之后，我们就可以用cnpm代替npm来安装依赖包了。如果想进一步了解cnpm的，查看淘宝npm镜像官网。</p>
<p>4.安装vue-cli脚手架构建工具<br>在命令行中运行命令 <strong>npm install -g vue-cli</strong> ，然后等待安装完成。<br>通过以上三部，我们需要准备的环境和工具都准备好了，接下来就开始使用vue-cli来构建项目。</p>
<p>5.用vue-cli构建项目<br>要创建项目，首先我们要选定目录，然后再命令行中把目录转到选定的目录。<br>在这里，我选择桌面来存放新建的项目，则我们需要先把目录cd到桌面。在桌面目录下，在命令行中运行命令 <strong>vue init webpack firstVue</strong><br>解释一下这个命令，这个命令的意思是初始化一个项目，其中webpack是构建工具，也就是整个项目是基于webpack的。其中firstVue是整个项目文件夹的名称，这个文件夹会自动生成在你指定的目录中（我的实例中，会在桌面生成该文件夹），如下图。<br><img src="/images/170410-2.png" alt=""></p>
<p>运行初始化命令的时候回让用户输入几个基本的选项，如项目名称，描述，作者等信息，如果不想填直接回车默认就好。<br>打开firstVue文件夹，项目文件如下所示。<br><img src="/images/170410-3.png" alt=""></p>
<p>这就是整个项目的目录结构，其中，我们主要在src目录中做修改。这个项目现在还只是一个结构框架，整个项目需要的依赖资源都还没有安装，如下图。<br><img src="/images/170410-4.png" alt=""></p>
<p>6.安装项目所需的依赖<br>要安装依赖包，首先cd到项目文件夹（firstVue文件夹），然后运行命令 <strong>cnpm install</strong> ，等待安装。<br><img src="/images/170410-5.png" alt=""></p>
<p>安装完成之后，会在我们的项目目录firstVue文件夹中多出一个node_modules文件夹，这里边就是我们项目需要的依赖包资源。<br><img src="/images/170410-6.png" alt=""><br>安装完依赖包之后，就可以运行整个项目了。</p>
<p>7.运行项目<br>在项目目录中，运行命令 <strong>npm run dev</strong> ，会用热加载的方式运行我们的应用，热加载可以让我们在修改完代码后不用手动刷新浏览器就能实时看到修改后的效果。<br><img src="/images/170410-7.png" alt=""><br>这里简单介绍下 npm run dev 命令，其中的“run”对应的是package.json文件中，scripts字段中的dev，也就是 node build/dev-server.js命令的一个快捷方式。</p>
<p>项目运行成功后，浏览器会自动打开localhost:8080（如果浏览器没有自动打开，可以手动输入）。运行成功后，会看到如下所示的界面。<br><img src="/images/170410-8.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需要的东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;node.js环境（npm包管理器）&lt;/li&gt;
&lt;li&gt;vue-cli 脚手架构建工具&lt;/li&gt;
&lt;li&gt;cnpm  npm的淘宝镜像&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;安装步骤&quot;&gt;&lt;a href=&quot;#安装步骤&quot; class=&quot;headerlink&quot; title=&quot;安装步骤&quot;&gt;&lt;/a&gt;安装步骤&lt;/h4&gt;&lt;p&gt;1.从node.js官网下载并安装node，安装过程很简单，一路“下一步”就可以了（傻瓜式安装）。&lt;br&gt;安装完成之后，打开命令行工具，输入 &lt;strong&gt;node -v&lt;/strong&gt;，如下图，如果出现相应的版本号，则说明安装成功。&lt;br&gt;
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>javascript语言精髓 闭包、作用域、原型链</title>
    <link href="http://yoursite.com/2017/02/11/javascript%E8%AF%AD%E8%A8%80%E7%B2%BE%E9%AB%93/"/>
    <id>http://yoursite.com/2017/02/11/javascript语言精髓/</id>
    <published>2017-02-11T01:36:06.000Z</published>
    <updated>2017-08-09T08:03:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="作用域的种类"><a href="#作用域的种类" class="headerlink" title="作用域的种类"></a>作用域的种类</h3><p>作用域由大到小: </p>
<ul>
<li>程序级</li>
<li>文件级</li>
<li>函数级</li>
<li>块级</li>
</ul>
<h3 id="javascript作用域"><a href="#javascript作用域" class="headerlink" title="javascript作用域"></a>javascript作用域</h3><ul>
<li>全局作用域 </li>
<li>函数作用域 </li>
<li>块级作用域(ES6)</li>
</ul>
<a id="more"></a>       
<pre><code>var global = 1;
function doSomething(){
    var inner = 2;
    globalA = 3; 
}
doSomething();
alert(global);// 1
alert(globalA);// 3
alert(inner);// undefined
</code></pre><h3 id="javascript作用域链"><a href="#javascript作用域链" class="headerlink" title="javascript作用域链"></a>javascript作用域链</h3><p>什么是作用域链?<br>在JavaScript中,函数也是对象,函数对象和其它对象一样,拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]],由ECMA-262标准第三版定义,该内部属性包含了函数被创建的作用域中对象的集合, 这个集合被称为函数的作用域链,它决定了哪些数据能被函数访问。</p>
<pre><code>var test = “aaa”;
function doSomething(){
alert(test);
var test = “bbb”; alert(test); //bbb
}
doSomething();
alert(test);
// aaa
</code></pre><h3 id="变量与函数声明提前"><a href="#变量与函数声明提前" class="headerlink" title="变量与函数声明提前"></a>变量与函数声明提前</h3><pre><code>function foo(){
  alert(test);
  var test = “bbb”;
  alert(test);
} foo();
</code></pre><p>执行顺序:<br>1.声明函数foo<br>2.调用函数foo<br>3.声明变量test<br>4.alert(test);<br>5.test变量赋值为bbb<br>6.alert(test);</p>
<h3 id="javascript中的this关键字"><a href="#javascript中的this关键字" class="headerlink" title="javascript中的this关键字"></a>javascript中的this关键字</h3><ul>
<li>this指向哪 ?<br>在Javascript中,this指向函数执行时的当前对象。 (In JavaScript, as in most object-oriented programming<br>languages, this is a special keyword that is used within methods to refer to the object on which a method is being invoked.)<br>——jQuery Fundamentals (Chapter 2), by Rebecca Murphey</li>
<li>this使用场景？<br>1.普通函数中:<br>  严格模式:undefined<br>  非严格模式:全局对象(window)<br>2.构造函数中:对象的实例<br>3.对象方法: 对象本身 </li>
</ul>
<h3 id="call-、apply、bind"><a href="#call-、apply、bind" class="headerlink" title="call 、apply、bind"></a>call 、apply、bind</h3><ul>
<li>使用方法:<br>  1.fn.call(context, arg1, arg2, …, argn);<br>  2.fn.apply(context, [arg1,arg2,…,argn]);<br>  3.function(){…}.bind(context)<br>通过这三个方法可以改变被调用函数中this指向的对象</li>
</ul>
<pre><code>if(!(“userName” in window)){
 var userName=“zhengzheng.xz”;
}
console.log(userName);
//undefined



var obj = {
   user: “zhengzheng.xz”
   getName:function(){
      return this.user;
   }
}
var getNameFn = obj.getName;
console.log(getNameFn());
//undefined
console.log(obj.getName());
//zhengzheng.xz
</code></pre><h3 id="javascript原型与原型链"><a href="#javascript原型与原型链" class="headerlink" title="javascript原型与原型链"></a>javascript原型与原型链</h3><ul>
<li>原型对象是什么？<br>在Javascript中,每定义一个对象(函数)时,对象中都会包含一些预定义的属性。其中函数对象的一个属性就是原型对象prototype。普通对象没有prototype属性,但有 <strong>proto</strong>属性</li>
</ul>
<pre><code>function f1(){};
console.log(typeof f1.prototype); //object
console.log(typeof Function.prototype) //Function,这个特殊
console.log(typeof Object.prototype) //object
console.log(typeof Function.prototype.prototype)//undefined
</code></pre><ul>
<li>原型对象有什么用？<br>面向对象开发、类的继承</li>
</ul>
<pre><code>function Person(name){
    this.name=name;
}
Person.prototype.getName=function(){
    return this.name;
}
var xu=new Person(&apos;jiaojiao.xz&apos;);
xu.getName(); //jiaojiao.xz
</code></pre><ul>
<li>构造函数<br>1.使用new关键字调用的函数<br>2.构造函数可以实例化一个对象<br>3.返回值,默认返回类的实例<br>4.特殊情况:<br>  没有返回值<br>  简单数据类型<br>  对象类型</li>
</ul>
<pre><code>function People(name,age){
   this.name=name;
   this.age=age;
} 
var people=new People(&apos;Byron&apos;,26);
</code></pre><h3 id="原型链是如何实现的？"><a href="#原型链是如何实现的？" class="headerlink" title="原型链是如何实现的？"></a>原型链是如何实现的？</h3><ol>
<li>每个函数都有一个prototype的对象属性</li>
<li>每个对象都有一个<strong>proto</strong>属性,该属性指向其父类的prototype对象</li>
</ol>
<h3 id="原型对象中的constructor"><a href="#原型对象中的constructor" class="headerlink" title="原型对象中的constructor"></a>原型对象中的constructor</h3><ul>
<li>每个原型对象prototype中都有一个constructor属性,默认指向函数本身。</li>
</ul>
<pre><code>Person.prototype.constructor===Person; //true
Function.prototype.constructor===Function; //true
Object.prototype.constructor===Object; //true
Object.prototype.constructor===Function; //true
</code></pre><p>练习一:</p>
<pre><code>function make(num){
  return function(){
return num; }
}
var arr = [make(0),make(1),make(2)]; alert(arr[0]()); // 0 alert(arr[1]()); // 1 alert(arr[2]()); // 2
</code></pre><p>练习二：</p>
<pre><code>var name = ‘global’;
function A(name){
  alert(name);
  this.name = name;
  var name = ‘1’;
}
A.prototype.name = ‘2’;
var a = new A(‘3’);
alert(a.name);
delete a.name;
alert(a.name);
// 3
// 3 // 2
</code></pre><p>练习三：</p>
<pre><code>function fun(n,o){
    console.log(o);
    return {
        fun:function(m){
            return fun(m, n)
        }  
    }
}
var a = fun(0);
a.fun(1); a.fun(2);
var b = fun(0).fun(1).fun(2).fun(3);
var c = fun(0).fun(1);
c.fun(2); c.fun(3);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;作用域的种类&quot;&gt;&lt;a href=&quot;#作用域的种类&quot; class=&quot;headerlink&quot; title=&quot;作用域的种类&quot;&gt;&lt;/a&gt;作用域的种类&lt;/h3&gt;&lt;p&gt;作用域由大到小: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序级&lt;/li&gt;
&lt;li&gt;文件级&lt;/li&gt;
&lt;li&gt;函数级&lt;/li&gt;
&lt;li&gt;块级&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;javascript作用域&quot;&gt;&lt;a href=&quot;#javascript作用域&quot; class=&quot;headerlink&quot; title=&quot;javascript作用域&quot;&gt;&lt;/a&gt;javascript作用域&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;全局作用域 &lt;/li&gt;
&lt;li&gt;函数作用域 &lt;/li&gt;
&lt;li&gt;块级作用域(ES6)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>css工作流</title>
    <link href="http://yoursite.com/2017/01/12/css%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>http://yoursite.com/2017/01/12/css工作流/</id>
    <published>2017-01-12T08:09:11.000Z</published>
    <updated>2017-04-01T02:01:42.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>css预处理器<br>“An preprocessor is a program that processes its input to produce output that is used as input to another program ”<br>处理特定格式源文件到目标css的处理程序</p>
</li>
<li><p>预处理器变革</p>
</li>
</ul>
<pre><code>body {
    left:&lt;%= left  %&gt;px;
    color:&lt;%= color|highlight: 10% %&gt;;
}

@base:#f938ab;
box-shadow(@style,@c)when(iscolor(@c)){
    -webkit-box-shadow:@style @c;
    box-shadow:       @style @c;
}
box{
    color:saturate(@base,5%);
    border-color:lighten(@base,30%);
    div{.box-shadow(0 0 5px,30%)}
}
</code></pre><a id="more"></a>
<h3 id="预处理器常用规范"><a href="#预处理器常用规范" class="headerlink" title="预处理器常用规范"></a>预处理器常用规范</h3><ul>
<li>变量</li>
<li>混合（Mixin） Extend</li>
<li>嵌套规则</li>
<li>运算</li>
<li>函数</li>
<li>Namespaves &amp; Accessors</li>
<li>Scope</li>
<li>注释</li>
</ul>
<p>W3C标准实现</p>
<pre><code>.m-layer{
    height:var(--height);
    width:var(--width);
    background-color:blue;
}
.m-layer-sm{
    --height:100px;
    --width:100px;
}
.m-layer-bg{
    --height:200px;
    --width:200px;
}

&lt;div class=&quot;m-layer m-layer-bg&quot;&gt;&lt;/div&gt;
</code></pre><h3 id="CSS后处理器"><a href="#CSS后处理器" class="headerlink" title="CSS后处理器"></a>CSS后处理器</h3><ul>
<li>css压缩 ClEAN-CSS</li>
<li>自动添加浏览器前缀 Autoprefixer</li>
<li>CSS更加美观排序 CSScomb</li>
<li>Rework 取代Styles后处理器发热</li>
<li>前后都行 PostCss</li>
</ul>
<pre><code>:root{
    --red:#d33;
}
a{
    &amp;:hover{
        color:color(var(--red) a(54%));
    }
}

a:hover{
    color:#dd3333;
    color:rgba(221,51,51,0.54);
}
</code></pre><p><img src="/images/170331-2.png" alt=""><br><img src="/images/170331-1.png" alt=""><br>抽象语法树（Abstract Syntax Tree,AST）作为程序的一种中间表示形式</p>
<h4 id="POSTCSS值得收藏的插件"><a href="#POSTCSS值得收藏的插件" class="headerlink" title="POSTCSS值得收藏的插件"></a>POSTCSS值得收藏的插件</h4><ul>
<li>POSTCSS-CUSTOM-PROPERTIES 运行时变量</li>
<li>POSTCSS-SIMPLE-VARS 与SCSS一致的变量实现</li>
<li>POSTCSS-MIXINS 实现类似SASS的@MIXIN的功能</li>
<li>POSTCSS-EXTEND 实现类似SASS的继承功能</li>
<li>POSTCSS-IMPORT 实现类似SASS的IMPORT</li>
<li>CSSNext 面向未来  CSS Grace 修复过去</li>
</ul>
<pre><code>var gulp = require(&apos;gulp&apos;);
var postcss = require(&apos;gulp-postcss&apos;);
var autoprefixer = require(&apos;autoprefixer&apos;);
var cssgrace  = require(&apos;cssgrace&apos;);
var cssnext  = require(&apos;cssnext&apos;);
gulp.task(&apos;css&apos;, function () {
  var processors = [
    autoprefixer({browsers: [&apos;last 3 version&apos;],
      cascade: false,
      remove: false
    }),
    cssnext(),
    cssgrace
  ];
  return gulp.src(&apos;./src/css/*.css&apos;)
    .pipe(postcss(processors))
    .pipe(gulp.dest(&apos;./dist&apos;));
});
gulp.task(&apos;watch&apos;, function(){
  gulp.watch(&apos;./src/css/*.css&apos;, [&apos;css&apos;]);
});
gulp.task(&apos;default&apos;, [&apos;watch&apos;, &apos;css&apos;]);
</code></pre><p><img src="/images/170331-3.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;css预处理器&lt;br&gt;“An preprocessor is a program that processes its input to produce output that is used as input to another program ”&lt;br&gt;处理特定格式源文件到目标css的处理程序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;预处理器变革&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;body {
    left:&amp;lt;%= left  %&amp;gt;px;
    color:&amp;lt;%= color|highlight: 10% %&amp;gt;;
}

@base:#f938ab;
box-shadow(@style,@c)when(iscolor(@c)){
    -webkit-box-shadow:@style @c;
    box-shadow:       @style @c;
}
box{
    color:saturate(@base,5%);
    border-color:lighten(@base,30%);
    div{.box-shadow(0 0 5px,30%)}
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="css工作流 css预处理器 css后处理器" scheme="http://yoursite.com/tags/css%E5%B7%A5%E4%BD%9C%E6%B5%81-css%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-css%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
  </entry>
  
</feed>
