[{"title":"Redux:Store","date":"2017-04-01T07:59:32.000Z","path":"2017/04/01/Redux-Store/","text":"Redux 应用里的 Actions 表示在应用里发生的事情，Reducers 会根据发生的事情去更新应用的状态。再来了解一下 Store。 Store 的主要任务是： 1.持有应用的状态。2.允许访问状态：getState()。3.允许更新状态：dispatch(action)。4.注册监听器：subscribe(listener)。5.用 subscribe(listener) 返回的东西，可以注销监听器。 注意在 Redux 应用里只有一个 Store。如果想分离数据处理逻辑，可以使用组合 Reducer 的方式。有了 Reducer ，很容易用它去创建一个 Store 。之前我们用 combineReducers() 把几个 Reducer 组合成了一个，现在我们可以去导入它，然后把它交给 createStore()。 import { createStore } from &apos;redux&apos; import todoApp from &apos;./reducers&apos; let store = createStore(todoApp) 也可以提供一个初始状态，作为 createStore() 的第二个参数： let store = createStore(todoApp, window.STATE_FROM_SERVER) 调度动作创建了 Store 以后，再去测试一下应用能不能正常运行： import { addTodo, toggleTodo, setVisibilityFilter, VisibilityFilters } from &apos;./actions&apos; // Log the initial state console.log(store.getState()) // Every time the state changes, log it // Note that subscribe() returns a function for unregistering the listener let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()) ) // Dispatch some actions store.dispatch(addTodo(&apos;Learn about actions&apos;)) store.dispatch(addTodo(&apos;Learn about reducers&apos;)) store.dispatch(addTodo(&apos;Learn about store&apos;)) store.dispatch(toggleTodo(0)) store.dispatch(toggleTodo(1)) store.dispatch(setVisibilityFilter(VisibilityFilters.SHOW_COMPLETED)) // Stop listening to state updates unsubscribe() 观察 Store 里的状态是怎么变化的： 在写界面之前，我们已经设置好了应用的一些行为。 Source Code index.js import { createStore } from &apos;redux&apos; import todoApp from &apos;./reducers&apos; let store = createStore(todoApp)","tags":[{"name":"Redux Store","slug":"Redux-Store","permalink":"http://yoursite.com/tags/Redux-Store/"}]},{"title":"Redux数据流","date":"2017-04-01T05:56:11.000Z","path":"2017/04/01/Redux数据流/","text":"Redux 应用里的数据流是单向的。数据的生命周期有四个阶段：1.调用 store.dispatch(action)一个动作就是一个纯对象，描述了发生的事情，比如： {type:&apos;LIKE_ARTICLE&apos;,articleId:42} {type:&apos;FETCH_USER_SUCCESS&apos;,response:{id:3,name:&apos;Mary}} {type:&apos;ADD_TODO&apos;,text:&apos;Read thr Redux docs.&apos;} 把动作想成是一些简要的新闻： “Mary liked article 42.” ， “‘Read the Redux docs.’ was added to the list of todos.”。在应用的任何地方你可以调用 store.dispatch(action)，包括组件，XHR 回调等等。2.Redux Store 会调用你给它的 reducerstore 会把两个参数传递给 reducer：当前的状态树，还有动作。比如在一个任务列表应用里。 3.Reducer 是纯函数，它只计算出下一个状态。给它同样的输入，任何时候它都会计算出同样的结果。Reducer 不能执行有副作用的动作，比如去调用 API，这些动作应该在调度动作之前完成。 // The current application state (list of todos and chosen filter) let previousState = { visibleTodoFilter: &apos;SHOW_ALL&apos;, todos: [ { text: &apos;Read the docs.&apos;, complete: false } ] } // The action being performed (adding a todo) let action = { type: &apos;ADD_TODO&apos;, text: &apos;Understand the flow.&apos; } // Your reducer returns the next application state let nextState = todoApp(previousState, action) 4.Root Reducer 可能会把多个 reducer 输出的东西组合成一个状态树。 Root Reducer 的结构完全取决于我们自己的设计。Redux 里面带个帮手函数：combineReducers()，你可以把 Root Reducer 分离成不同的 Reducer，每个 Reducer 都只管理属于它们自己的数据，然后用 combineReducers() 可以把这些分离出来的 Reducer 组合到一块儿，成为一个 Root Reducer。 比如你有两个 Reducers，一个是为了任务列表，一个是为了当前选择的过滤器： function todos(state = [], action) { // Somehow calculate it... return nextState } function visibleTodoFilter(state = &apos;SHOW_ALL&apos;, action) { // Somehow calculate it... return nextState } let todoApp = combineReducers({ todos, visibleTodoFilter }) 执行了动作以后，combineReducers 返回的 todoApp 会同时调用两个 Reducers： let nextTodos = todos(state.todos, action) let nextVisibleTodoFilter = visibleTodoFilter(state.visibleTodoFilter, action) 然后会把这两个分支的结果组合成一个状态树： return { todos: nextTodos, visibleTodoFilter: nextVisibleTodoFilter } 5.Redux store 会把 root reducer 返回的状态树保存起来。 这个新的状态树就是应用的下一个状态。所有 store.subscribe(listener) 注册的监听器会被执行。监听器可以使用 store.getState() 得到当前的状态。现在，UI 会根据新的状态被更新，如果把 React 与 Redux 放到一块儿用，这时候可以去调用 component.setState(newState) 。","tags":[{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"前端架构构建","date":"2017-03-30T01:05:37.000Z","path":"2017/03/30/前端持续集成/","text":"什么是集成 什么是统一代码仓库 什么是前端工程化 什么是自动化构建 更多的自动化 持续集成需求1.持续集成是通过平台串联各个开发环节，实现和沉淀工作自动化的方法。2.线上代码和代码仓库不同步，影响迭代和团队协作。3.静态资源发布依赖人工，浪费开发人力。4.缺少自动化测试，产品质量得不到保障。5.文案简单修改上线，需要技术介入。 统一代码仓库1.统一代码仓库通过分支管理合并主干svn。2.自动化构建工具，编译、部署、测试、监控、本机开发上线环境。FIS3/Webpack/jdists/package.json/chai/supertest/mocha/selenium-webdriver3.持续集成平台。Jenkins、Travis CI4.部署工具。rsync、shelljs、yargs5.运营同学有权限操作运营页面保存即可上线。 统一代码仓库多分支开发 合成步骤1.svn checkout svn地址 –username用户名2.svn branch 分支名（add/commit）3.svn merge 主干svn地址 分支svn地址4.Beyond Compare -&gt; svn resolved5.svn copy 主干svn地址 /tags/2017 前端工程化目标 自动化编译 前端模块化 定位静态资源 前端开发组件化 自动化部署测试配合版本库 自动化性能优化（前端架构开发下） 自动化编译 自动化编译流程 读入foo.es的文件内容，编译成js内容 分析js内容，找到资源定位标记’foo.scss’ 对foo.scss进行编译： 读入foo.scss的文件内容，编译成css内容 分析css内容，找到资源定位标记’url(foo.png)’ 对foo.png进行编译： 读入foo.png的内容 图片压缩 返回图片内容 根据foo.png的最终内容计算md5戳，替换url(foo.png)为url(/static/img/foo_2afob.png) 替换完毕所有资源定位标记，对css内容进行压缩 返回css内容 根据foo.css的最终内容计算md5戳，替换’foo.scss’为’/static/scss/foo_bae39.css’ 替换完毕所有资源定位标记，对js内容进行压缩 返回js内容 根据最终的js内容计算mds戳，得到foo.coffee的资源url为’/static/scripts/foo_3fc20.js’ 前端模块化1.前端模块化框架肩负着模块管理、资源加载两项重要的功能。这两项功能与工具、性能、业务、部署等工程环节都有着非常紧密的联系。因此，模块化框架的设计应该最高优先级考虑工程需要。2.commonjs API定义很多普通应用程序（主要指非浏览器的应用）使用的API,从而填补了这个空白。它的终极目标是提供一个类似 Python,Ruby和Java标准库。3.根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里定义的变量、函数、类，都有私有的，对其他文件不可见。4.CMD和AMD都是CommonJS的一种规范的实现定义，RequireJS和SeaJS是对应的实践。 AMD define([&apos;dep1&apos;,&apos;dep2&apos;],function(dep1,dep2){ // 内部只能使用执行的模块 return function(){}; }); CMD define(function(require,exports,module){ //此处如果需要加载某xx模块，可引入 var xx=require(&apos;xx&apos;); }) 优缺点：1.CMD依赖是就近声明，通过内部require方法进行声明。但是因为是异步模块，加载需要提前加载这些模块，所以模块真正使用前需要提取模块里面所有的依赖。2.不能直接压缩，require局部变量如果替换无法加载资源。3.CMD路径参数不能进行字符串运算。4.AMD的依赖是提前声明。这种优势的好处就是依赖无需通过静态分析，无论是加载器还是自动化工具都可以直接的获取到依赖。5.AMD依赖提前声明在代码书写上不是很友好。6.AMD模块内部与NodeJS的Modules有一定的差异。 依赖后置1.requirejs和seajs在加载上都有缺陷，就是模块的依赖要等到模块加载完成后，通过静态分析（seajs）或者deps参数（requirejs）来获取，这就为合并请求和按需加载带来了实现上的矛盾：要么放弃按需加载，把所有js合成一个文件。要么放弃请求合并，请求独立的模块文件，从而满足按需加载。2.AMD规范在执行callback的时候，要初始化所有依赖的模块，而CMD只有执行到require的时候才初始化模块。所以用AMD实现某种if-else逻辑分支家在不同的模块时候，就会比较麻烦了。 reqquire([&apos;page/index&apos;,&apos;page/detail&apos;],function(index,detail){ switch(location.hash){ case&apos;index&apos;: index(); break; } }}); 3.以上纯前端方式实现模块化框架不能同时满足 按需加载、请求合并和依赖管理 三个需求。 为什么用webpack1.webpack执行commonJs标准，解决了依赖配置和请求流量。2.对于webpack来讲万物都可以是模块，所有的文件都被合并到js中，最终在浏览器。3.兼容AMD和CMD4.js模块化不仅仅为了提高代码复用性，更是为了让资源文件更合理的进行缓存。 function(moudle,exportss._webpack_require_){ exports=module.exports=_webpack_require_(3)(); //imports //module exports.push([module.id,&quot;body{\\r\\n background-color:yellow;\\r\\n}\\r\\n&quot;,&quot;&quot;]); //exports }, new webpack.optimize.UglifyJsPlugin({ mangle:{ except:[&apos;$super&apos;,&apos;$&apos;,&apos;exports&apos;,&apos;require&apos;] } }) var path = require(&quot;path&quot;); var CommonsChunkPlugin = require(&quot;../../node_modules/webpack/lib/optimize/CommonsChunkPlugin&quot;); module.exports={ entry:{ m1:&apos;./m1.js&apos;, m2:&apos;./m2.js&apos; }, output:{ path:&quot;build&quot;, filename:&apos;[name].bundle.js&apos; }, plugins:[ new CommonsChunkPlugin(&apos;common.js&apos;); ] }; 资源定位1.配置超长时间的本地缓存–节省宽带，提高性能2.采用内容摘要作为缓存更新依据–精确的缓存控制3.静态资源CDN部署–优化网络请求4.资源发布路径实现非覆盖式发布–平滑升级 FIS3根据分析好的文件包，利用HOOK插件 分析下FIS生成的配置文件 webpack阿紫开发阶段打包，利用插件分析直接提取。FileLoader&amp;&amp;extract-text-webpack-plugin 配置publicpath分发到CDN 前端开发组件化1.每个前端模块都是一个小项目，配合mock.js可以进行本地的开发测试，package.json是标配产物。经过webpack的环境配置统一进行本地环境、上线环境的变异过程。2.由page组装widget，由widget组装webComponents(X-TAG)3.能够根据路由快速选择配置SPA或者直出。 web components1.Custom Elements2.HTML Imports3.HTML Templates4.Shadow DOM Custom Elements 提供一种方式让开发者可以自定义HTML元素，包括特定的组成，样式和行为。 class ButtonHelloElement extends HTMLButtonElement{ constructor(){ super() this.addEventListener(&apos;click&apos;,()=&gt;{ alert(&apos;hello world&apos;); }) } } customElements.define(&apos;button-hello&apos;,ButtonHelloElement,{extends:&apos;button&apos;}) &lt;button is=&quot;button-hello&quot;&gt;hello world&lt;/button&gt; HTML Imports 是一种在HTML中引用以及服用其他的HTML文档的方式。这个Import很漂亮，可以简单理解为我们常见的末班中的include之类的作用。 &lt;link rel=&quot;import&quot; href=&quot;/components/header.html&quot;&gt; const link=document.querySelector(&apos;link[rel=import]&apos;) const header=link.import; const pulse=header.querySelector(&apos;div.logo&apos;); //获取import的HTMl的document const d=document.currentScript.ownerDocument 用过handlebars的人都知道有这么一个东西： &lt;script id=&quot;template&quot; type=&quot;text/x-handlebars-template&quot;&gt;&lt;/script&gt; 那么HTML Templates是把这个东西官方标准化，提供了一个template 标签来存放以后需要但是暂时不渲染的HTML代码。 &lt;template id=&quot;template&quot;&gt;&lt;p&gt;Smile&lt;/p&gt;&lt;/template&gt; &lt;script&gt; let num=3; const fragment=document.getElementById(&apos;template&apos;).content.cloneNode(true); while(num --&gt;1 ){ fragment.firstChild.before(fragment.firstChild.cloneNode(true)); fragment.firstChild.textContent+=fragment.lastChild.textContent; } document.body.appendChild(fragment); &lt;/script&gt; Shadow DOM 最本质的需求是需要一个隔离组件代码作用域的东西，例如我组件代码的css不能影响其他组件之类的，而iframe又太重并且可能有各种奇怪问题。旨在提供一种更好的组织页面元素的方式，来为日趋复杂的页面应用提供强大支持，避免代码间的相互影响。 const div=document.getElementById(&apos;id&apos;) const shadowRoot=div.createShadowRoot() const span=document.creatElement(&apos;span&apos;) span.textContent=&apos;hello world&apos; shadowRoot.appendChild(span) &lt;x-foo&gt; &lt;&quot;shadow tree&quot;&gt; &lt;div&gt; &lt;span id=&quot;not-top&quot;&gt;...&lt;/span&gt; &lt;/div&gt; &lt;span id=&quot;top&quot;&gt;...&lt;/span&gt; &lt;/&gt; &lt;/x-foo&gt; x-foo::shadow &gt; span 可以匹配到#top元素 x-foo /deep/span 可以匹配到 #not-top和 #top元素 :host(.foo) 匹配&lt;x-foo&gt;元素 Web Components &lt;template id=&quot;&quot;&gt; &lt;style&gt; ::content li{ display:inline-block; padding:20px 10px; } &lt;/style&gt; &lt;content select=&quot;ul&quot;&gt;&lt;/content&gt; &lt;/template&gt; &lt;link rel=&quot;import&quot; href=&quot;components/header.html&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;test-header&gt; &lt;ul&gt; &lt;li&gt;Home&lt;/li&gt; &lt;li&gt;About&lt;/li&gt; &lt;/ul&gt; &lt;/test-header&gt; &lt;/body&gt; 自动化部署1.自动化运营平台2.自动化雪碧图3.自动化离线打包4.自动化控制缓存级别5.自动化处理inline6.自动化根据网速分发版本资源7.自动化运维平台","tags":[{"name":"前端架构构建  前端集成","slug":"前端架构构建-前端集成","permalink":"http://yoursite.com/tags/前端架构构建-前端集成/"}]},{"title":"http协议背后的事","date":"2017-03-29T07:27:02.000Z","path":"2017/03/29/http协议背后的事/","text":"当我们输入网址后发生了什么 HTTP协议详解 HTTP协议安全 后台服务与HTTP 反向代理与web服务 浏览器行为与HTTP协议处理流程：1.输入网址并回车2.解析域名3.浏览器发送http请求4.服务器处理请求5.服务器返回HTML响应6.浏览器处理HTML页面7.继续请求其他资源 什么是HTTP协议 HTTP是超文本传输协议，从www浏览器传输到本地浏览器的一种传输协议，网站是基于HTTP协议的，例如网站的图片、CSS、JS等都是基于HTTP协议进行传输的。 HTTP协议是由从客户机到服务器的请求(Reuqest)和从服务器到客户机的响应(response)进行约束和规范。 了解TCP/IP协议栈1.应用层：为用户提供所需要的各种服务，例如：HTTP、FTP、DNS、SMTP等。2.传输层：为应用层实体提供端到端通信功能，保证数据包的顺序传送及数据的完整性。该层定义了两个主要协议：传输控制协议(TCP)和用户数据报协议(UDP)。3.网络层：主要解决主机到主机的通信问题。IP协议是网际互联层最重要的协议。4.网络接口层：负责监视数据在主机和网络之间的交换。 在TCP/IP协议栈中得位置 目前应用版本HTTP1.1 HTTP默认端口号为80 HTTPS默认端口443 HTTP的工作过程 一次HTTP操作称为一个事务,其工作过程可分为四步:1.首先客户机与服务器需要建立连接。只要单击某个超级链接,HTTP的工作开始。2.建立连接后,客户机发送一个请求给服务器,请求方式的格式为:统一资源标识符(URL)、协议版本号,后边是MIME信息包括请求修饰符、客户机信息和可能的内容。3.服务器接到请求后,给予相应的响应信息,其格式为一个状态行,包括信息的协议版本号、一个成功或错误的代码,后边是MIME信息包括服务器信息、实体信息和可能的内容。4.客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上,然后客户机与服务器断开连接。如果在以上过程中的某一步出现错误,那么产生错误的信息将返回到客户端,有显示屏输出。对于用户来说,这些过程是由HTTP自己完成的,用户只要用鼠标点击,等待信息显示就可以了。 请求与响应 HTTP请求组成:请求行、消息报头、请求正文。 HTTP响应组成:状态行、消息报头、响应正文。 请求行组成:以一个方法符号开头,后面跟着请求的URI和协议的版本。 状态行组成:服务器HTTP协议的版本,服务器发回的响应状态代码和状态代码的文本描述。 (1) 请求报文(2) 响应报文 请求方法 GET: 请求获取Request-URI所标识的资源 POST: 在Request-URI所标识的资源后附加新的数据 HEAD: 请求获取由Request-URI所标识的资源的响应消息报头 PUT: 请求服务器存储一个资源,并用Request-URI作为其标识 DELETE: 请求服务器删除Request-URI所标识的资源 TRACE: 请求服务器回送收到的请求信息,主要用于测试或诊断 CONNECT: 保留将来使用 OPTIONS:请求查询服务器的性能,或者查询与资源相关的选项和需求 HTTP状态码状态代码有三位数字组成,第一个数字定义了响应的类别,且有五种可能取值: 1xx:指示信息–表示请求已接收,继续处理 2xx:成功–表示请求已被成功接收、理解、接受 3xx:重定向–要完成请求必须进行更进一步的操作 4xx:客户端错误–请求有语法错误或请求无法实现 5xx:服务器端错误–服务器未能实现合法的请求 常用的请求报头 Accept请求报头域用于指定客户端接受哪些类型的信息。eg:Accept:image/gif,Accept:text/ htmlAccept-Charset请求报头域用于指定客户端接受的字符集。Accept-Encoding:Accept-Encoding请求 报头域类似于Accept,但是它是用于指定可接受的内容编码。 Accept-Language请求报头域类似于Accept,但是它是用于指定一种自然语言。 Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时,如果收到服务器的响应代码为401(未授权),可以发送一个包含Authorization请求报头域的请求,要求服务 器对其进行验证。 Host请求报头域主要用于指定被请求资源的Internet主机和端又号,它通常从HTTP URL中提取出来 的,发送请求时,该报头域是必需的。 User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。 常用的响应报头 Location响应报头域用于重定向接受者到一个新的位置。Location 响应报头域常用在更换域名的时候。 Server响应报头域包含了服务器用来处理请求的软件信息。与User- Agent请求报头域是相对应的。 WWW-Authenticate响应报头域必须被包含在401(未授权的)响应 消息中,客户端收到401响应消息时候,并发送Authorization报头 域请求服务器对其进行验证时,服务端响应报头就包含该报头域。 实体报头请求和响应消息都可以传送一个实体。一个实体由实体报头域 和实体正文组成,但并不是说实体报头域和实体正文要在一起 发送,可以只发送实体报头域。实体报头定义了关于实体正文 (eg:有无实体正文)和请求所标识的资源的元信息。 常用的实体报头 Content-Encoding实体报头域被用作媒体类型的修饰符,它的值指示了已经被应用到实体正文 的附加内容的编码,因而要获得Content-Type报头域中所引用的媒体类型,必须采用相应的解 码机制。 Content-Language实体报头域描述了资源所用的自然语言。 Content-Length实体报头域用于指明实体正文的长度,以字节方式存储的十进制数字来表示。 Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。 Last-Modified实体报头域用于指示资源的最后修改日期和时间。 Expires实体报头域给出响应过期的日期和时间。 cookies 与 session Cookies是保存在客户端的小段文本,随客户端点每一个请求发送该url下的所有cookies到服务器端。 Session则保存在服务器端,通过唯一的值sessionID来区别每一 个用户。SessionID随每个连接请求发送到服务器,服务器根据 sessionID来识别客户端,再通过session 的key获取session值。 cookie应用与Cookie相关的HTTP扩展头1.Cookie:客户端将服务器设置的Cookie返回到服务器;2.Set-Cookie:服务器向客户端设置Cookie;服务器在响应消息中用Set-Cookie头将 Cookie的内容回送给客户端,客户端在新 的请求中将相同的内容携带在Cookie头中 发送给服务器。从而实现会话的保持。 session 使用 使用Cookie来实现 使用URL回显来实现 缓存机制 缓存会根据请求保存输出内容的副本,例如html页面,图片,文 件,当下一个请求来到的时候:如果是相同的URL,缓存直接使 用副本响应访问请求,而不是向源服务器再次发送请求。 缓存的优点: 减少相应延迟 减少网络带宽消耗 浏览器缓存机制-浏览器第一次请求 浏览器缓存机制-浏览器再次请求 Etag/if-None-Match策略 Etag:web服务器响应请求时,告诉浏览器当前资源在服务器的唯一标识(生成规则由服务器决定) If-None-Match:当资源过期时(使用Cache-Control标识的max- age),发现资源具有Etage声明,则再次向web服务器请求时带 上头If-None-Match (Etag的值)。web服务器收到请求后发现 有头If-None-Match 则与被请求资源的相应校验串进行比对,决 定返回200或304。 Last-Modified/if-Modified-Since策略 Last-Modified:标示这个响应资源的最后修改时间。web服务器在响应请求时,告诉浏览器资源的最后修改时间。 If-Modified-Since:当资源过期时(使用Cache-Control标识的max-age),发 现资源具有Last-Modified声明,则再次向web服务器请求时带上头 If- Modified-Since,表示请求时间。web服务器收到请求后发现有头If-Modified- Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新,说 明资源又被改动过,则响应整片资源内容(写在响应消息包体内),HTTP 200;若最后修改时间较旧,说明资源无新修改,则响应HTTP 304 (无需包 体,节省浏览),告知浏览器继续使用所保存的cache。 HTTP链路安全1.加密重要数据2.对非重要数据签名3.使用安全连接HTTPS协议 下一代标准：HTTP2 使用二进制格式传输,更高效、更紧凑。 对报头压缩,降低开销。 多路复用,一个网络连接实现并行请求。 服务器主动推送,减少请求的延迟 http与反向代理 什么是代理,什么又是反向代理? 为什么要使用反向代理? 都有哪些反向代理服务器? 反向代理的用途 加密和SSL加速 负载均衡 缓存静态内容 压缩 减速上传 安全 外网发布 反向代理做负载均衡 让nginx跑起来 准备环境:Linux服务器、gcc编译器、nginx源代码 获取nginx源码:http://nginx.org 编译安装nginx源码 配置规则","tags":[{"name":"http https","slug":"http-https","permalink":"http://yoursite.com/tags/http-https/"}]},{"title":"小程序面向个人开发者开放","date":"2017-03-28T12:12:26.000Z","path":"2017/03/28/小程序面向个人开发者开放/","text":"3月27日晚上10点，微信官方通过“微信公开课”和“微信公众平台”发布重磅消息称，小程序对个人开发者开放注册，并宣布小程序新增六大能力。 新增6大功能为：个人开发者开放、公众号自定义菜单跳小程序、公众号模版消息可打开相关小程序、模板消息跳小程序 、绑定时可发送模板消息、兼容线下二维码、App分享用小程序打开。 1.个人开发者可申请小程序 小程序开放个人开发者申请注册，个人用户可访问微信公众平台，扫码验证个人身份后即可完成小程序帐号申请并进行代码开发。 申请个人开发者的个人需要实名。现在，对小程序感兴趣，并且有开发能力者，可以在开放的类目范围内，通过开发小程序，把自己的“一个想法”变成“一件作品”，并为微信用户所使用，进一步发挥开发者的个人价值。 个人开发者可以做些什么？ Q：作为一个个人开发者，我可以申请注册几个小程序？可以开发什么类型的小程序？ A：每个个人可申请5个小程序（身份证+微信号合计5个），不占用组织类型帐号的名额。目前，个人开发者可以开发生活服务、工具、旅游、出行与交通、餐饮、商业服务、体育、快递业与邮政、教育等类别的小程序。后续，支持的类目会随平台规则而调整。 Q：和组织类型开发者相比，个人开发者在小程序的开发上有什么不同？ A：和组织类型开发者相比，个人类型开发者的开发流程更短：注册——验证身份——填写详细信息——开发——提交代码审核——审核通过后可发布。 Q：目前，小程序对于个人开发者开放了哪些能力？ A：小程序对个人开发者开放的API能力和组织类型的基本一致，如消息通知（客服消息、模板消息）、自定义二维码生成等能力，也支持同主体的公众号关联。 在开放能力上，我们希望有更多的突破，以帮助个人能在开发中更好地运用开发工具。因此，我们开放了更多的接口权限给到了个人开发者。目前，个人小程序不支持进行个人认证、支付和卡券功能。 请访问：微信公众平台mp.weixin.qq.com 2.公众号自定义菜单点击可打开相关小程序 公众号可将已关联的小程序页面放置到自定义菜单中，用户点击后可打开该小程序页面。公众号运营者可在公众平台进行设置，也可以通过自定义菜单接口进行设置。 详见开发文档：微信公众平台文档mp.weixin.qq.com/wiki -自定义菜单 3.公众号模版消息可打开相关小程序 公众号已关联的小程序页面可以配置到公众号的模版消息中，用户点击公众号下发的模版消息，可以打开对应的小程序页面。 详见开发文档：微信公众平台文档(mp.weixin.qq.com/wiki)-模版消息 4.公众号关联小程序时，可选择给粉丝下发通知 公众号关联小程序时，可选择给粉丝下发通知消息，粉丝点击该通知消息可以打开小程序。该消息不占用原有群发条数。 5.移动App可分享小程序页面 开发者可以把小程序绑定到微信开放平台。绑定后，同一微信开放平台帐号下的App可分享已绑定的小程序页面到微信内的会话或群聊。APP链接分享到微信，点开就是小程序。 详见开发文档：微信开放平台open.weixin.qq.com -资源中心-移动应用-分享与收藏功能 6.扫描普通链接二维码可打开小程序 商户如果在线下已铺设了普通链接二维码，可在公众平台的小程序管理后台进行配置，用户扫描该原有线下普通链接二维码可直接打开小程序。 微信官方称，摩拜单车扫描单车二维码直接进入小程序的能力，现在通用了。 总结：公众号和小程序新增三种连接方式：在支持公众号绑定相关小程序后，公众号和小程序有了三种新的连接跳转方式： ①公众号可以把自己关联的小程序放在自定义菜单中，用户点击可直达小程序。 ②公众号模版消息可打开相关小程序。通过公众号，公众号运营者可以推送关联的小程序页面了。 ③公众号绑定相关小程序时，可选择给粉丝下发通知。公众号运营者可以通知粉丝，“我绑定了这个小程序”，粉丝点击消息就可以打开小程序。（此消息不占用原有群发条数）","tags":[{"name":"小程序开发","slug":"小程序开发","permalink":"http://yoursite.com/tags/小程序开发/"}]},{"title":"javascript函数式编程","date":"2017-03-28T07:52:35.000Z","path":"2017/03/28/javascript函数式编程/","text":"函数式编程思维 函数式编程常用核心概念 当下函数式编程最热的库 函数式编程基础理论1.函数式编程（Functional Programming）相对计算机历史而言是一个古老的概念，甚至早于第一台计算机的诞生。函数式编程的基础模型来源于 ℷ (lambda x=x&gt;x*2)演算， 而 ℷ 演算并非设计于在计算机上执行，它是一套用于研究函数定义、函数应用和递归的形式系统。2.函数式编程不是用函数来编程，也不是传统的面向过程编程。是将复杂的函数符合成简单的函数（计算理论、递归论、ℷ 演算）。运算过程尽量写成一系列嵌套的函数调用。3.javascript是披着 C 外衣的lisp。4.真正的火热是随着React的高阶函数而逐步升温。 函数：函数是一等公民，指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。 不可变量：在函数编程中，我们通常理解的变量在函数式编程中也被函数代替了。在函数编程中变量仅仅代表某个表达式。这里所说的’变量’是不能被修改的。 所有的变量只能被赋值一次初值。 map &amp; reduce 他们是最常用的函数式编程的方法。 专业术语 纯函数 函数的柯里化 函数组合 Point Free 声明式与命令式代码 惰性求值 1.纯函数：对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。 var arr=[1,2,3,4,5]; // Array.slice是纯函数，因为它没有副作用，对于固定的输入，输出总是固定的 xs.slice(0,3); xs.slice(0,3); xs.slice(0,3); xs.slice(0,3); 优缺点： import_from &apos;lodash&apos;; var sin=_.memorize(x=&gt;Math.sin(x)); //第一次计算的时候会稍微慢一点 var a=sin(1); //第二次有了缓存，速度极快 var b=sin(1); 纯函数不仅可以有效降低系统的复杂度，还有很多很棒的特性，必如可缓存性； //不纯的 var min=18; var checkage = age =&gt; age &gt;18; 在不纯的版本中，checkage不仅取决于age还有外部依赖的变量min。纯的checkage把关键数字18硬编码在函数内部，扩展性比较差，柯里化优雅的函数式解决。 2.函数的柯里化：传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 var checkage = min =&gt;(age =&gt; age &gt;min); var checkage18 =checkage(18); checkage18(20); 优缺点： import {curry} from &apos;lodash&apos;; var match=curry((reg,str)=&gt; str.match(reg)); var filter=curry((f,arr)=&gt; arr.filter(f)); var haveSpace = match(/\\s+/g); haveSpave(&quot;ffffff&quot;); haveSpace(&quot;a b&quot;); filter(haveSpace,[&quot;abcdefg&quot;,&quot;Hello World&quot;]); //=&gt;[&quot;Hello world&quot;]; 事实上柯里化是一种 “预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的”缓存”，是一种非常高效的编写函数的方法。 3.函数组合：纯函数以及如何把它柯里化写出的层叠代码h(g(f(x))),为了解决函数嵌套问题，我们需要用到”函数组合”。 //我们用柯里化改，让多个函数像拼积木一样 const compose = (f,g) =&gt; (x =&gt; f(g(x))); var first = arr =&gt; arr[0]; var reverse = arr =&gt; arr.reverse(); var last = compose(first,reverse); last([1,2,3,4,5]); 4.Point Free: 把一些对象自带的方法转化成纯函数，不要命名转瞬即逝的中间变量。 const f = str =&gt; str.toUpperCase().split(&apos;&apos;); 这个函数中，我们使用了str作为中间变量，但是这个中间变量除了让代码长以外毫无意义。 优缺点: var toUpperCasre = word =&gt; word.toUpperCase(); var split = x =&gt; (str =&gt; str.split(x)); var f = compose(split(&apos;&apos;),toUpperCase); f(&quot;abcd efgh&quot;); 这种风格能够帮助我们减少不必要的命名，让代码保持简洁和通用。 5.声明式与命令式代码 命令式代码：通过编写一条又一条指令让计算机执行一些动作，一般都会涉及到很多繁杂的细节。声明式代码：通过写表达式的方法来声明我们想干什么，而不是通过一步一步的指示。 //命令式 let CEOs=[]; for(var i=0;i&lt;companies.length;i++){ CEOs.push(comanies[i].CEO); } //声明式 let CEOs=companies.map(c =&gt; c.CEO); 优缺点：函数式编程的一个明显好处就是这种声明式的代码，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的，专注于编写业务代码。优化代码时，只需要集中在稳定坚固的函数内部。相反，不纯的函数式的代码会产生副作用或者依赖外部系统环境，使用他们的时候总要考虑这些副作用，在复杂的系统中，这对于程序员是极大的负担。 6.惰性求值、惰性函数 在指令式语言中以下代码会按顺序执行，由于每个函数都有可能改动或者依赖于外部状态，因此必须顺序执行。把concatenate 换成另外一个函数，这个函数中又条件判断语句，实际上只会需要两个参数中的其中一个，那么就没有必要执行计算另外一个参数的函数了。 var s1=somewhatlongOperation1(); var s2=somewhatlongOperation2(); var s3=concatenate(s1,s2); function somewhatlongOperation1(){somewhatlongOperation1} 更加专业术语 高阶函数 尾调用优化 闭包 容器、Functor 错误处理、Either IO Monad 1.高阶函数：函数当参数，把传入的函数做一个封装，然后返回这个封装函数，达到更高程度的抽象。 //命令式 var add = function(a,b){ return a+b; }; function math(func,array){ return func(array[0],array[1]); } math(add,[1,2]); //3 2.尾调用优化：函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归需要保存大量的调用记录，很容易发生栈溢出错误，如果使用尾递归优化， 将递归变为循环，那么只需要保存一个调用记录，这样就不会发生栈溢出错误了。 //不是尾递归，无法优化 function factorial(n){ if(n===1)return 1; return n * factorial(n-1); } function factorial(n,total){ if(n===1) return total; return factorial(n-1,n*total); } //es6强制使用尾递归 细数尾递归 实例一： function sum(n){ if(n===1)return 1; return n + sum(n-1); } sum(5) (5 + sum(4)) (5 + (4 + sum(3))) (5 + (4 + (3 + sum(2)))) (5 + (4 + (3 + (2 + sum(1))))) (5 + (4 + (3 + (2 + 1)))) (5 + (4 + (3 + 3))) (5 + (4 + 6)) (5 + 10) 15 普通递归时，内存需要记录调用的堆栈所处的深度和位置信息。在最底层计算返回值，再根据记录信息，跳回上一层级计算，然后再跳回更高一层，依次运行，直到最外层调用函数。在cpu计算和内存会消耗很多，而且当深度过大时，会出现堆栈溢出。 实例二： function sum(x,total){ if(x === 1){ return x + total; } return sum(x-1,x + total); } sum(5,0) sum(4,5) sum(3,9) sum(2,12) sum(1,14) 15 整个计算过程是线性的，调用一次 sum(x,total)后，会进入下一个栈，相关的数据信息跟随进入，不再放在堆栈上保存。当计算完最后的值之后，直接返回到最上层的sum(5,0)。这能有效的防止堆栈溢出。在ECMAScript6,我们将迎来尾递归优化，通过尾递归优化，javascript代码在解释成机器码的时候，将会向while看起，也就是说，同事拥有数学表达式能力和while的效能。 3.闭包 如下例子，虽然外层的makePowerFn函数执行完毕，栈上的调用帧被释放，但是堆上的作用域并不被释放，因此power依旧可以被powerFn函数访问，这样就形成了闭包。 function makePowerFn(power){ function powerFn(base){ return Math.pow(base,power); } return powerFn; } var square = makePowerFn(2); square(3); //9 4.容器、Functor（函子） $(…)返回的对象并不是一个原生的DOM对象，而是对于原生对象的一种封装，这在某种意义上就是一个”容器”（但它并不函数式）。 Functor(函子)遵守一些特定规则的容器类型。 Functor是一个对于函数调用的抽象，我们赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口map给容器外的函数，map一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由的选择何时何地如何操作这个函数，以至于拥有惰性求值、错误处理、异步调用等等非常棒的特性。 var Container = fuunction(x){ this._value = x; } Container.of = x =&gt; new Container(x); //Container.of(&apos;abcd&apos;); Container.prototype.map = function(f){ return Container.of(f(this._value)); } Container.of(3) .map(x =&gt; x+1) // =&gt;Container(4) .map(x =&gt; &apos;Result is&apos; + x); // =&gt; Container(&apos;Result is 4&apos;); --- var Maybe = function(x){ this._value = x; } Maybe.of = function(x){ return new Maybe(x); } Maybe.prototype.map=function(f){ return this.isNothing()? Maybe.of(null) : Maybe.of(f(this._value)); } Maybe.prototype.isNothing = function(){ return (this._value === null || this._value === undefined); } //新的容器我们称为 Maybe(原型来自于 Haskell) 5.错误处理、Either 我们的容器能做的事情太少，try/catch/throw 并不是”纯”的，因为它从外部接管了我们的函数，并且在这个函数出错时抛弃了它的返回值。 Promise 是可以调用 catch来集中处理错误的。 事实上Either并不只是用来做错误处理的，它表示了逻辑或，范畴学里的coproduc。 var left = function(x){ this._value = x; } var Right = function(x){ this._value = x; } Left.of = function(x){ return new Left(x); } Right.of=function(x){ return new Rgith(x); } --- //这里不同 Left.prototype.map = function(f){ return this; } Rgiht.prototype.map = function(f){ return Right.of(f(this._value)); } left和Right 唯一的区别在于 map方法的实现，Right.map的行为和之前提到的map函数一样。但是left.map就很不同了，它不会对容器做任何事情，只是很简单地把这个容器拿进来又扔出去。这个特性意味着，left可以用来传递一个错误消息。 var getAge = user =&gt; user.age ? Right.of(user.age):Left.of(&quot;ERROR&quot;); getAge({name:&apos;stark&apos;,age:&apos;21&apos;}).map(age =&gt; &apos;Age is&apos;+ age); // =&gt; Right(&apos;Age is 21&apos;) get Age({name:&apos;stark}).map(age =&gt; &apos;Age is&apos; +age); //=&gt; Left(&apos;ERROR&apos;) left 可以让调用链中任意一环的错误立刻返回到调用链的尾部，这给我们错误处理带来了很大的方便，再也不用一层一层的try/catch。 6.IO 真正的程序总要去接触不纯的世界。如下例子就依赖于window。 function readlocalStorage(){ return window.localStorage; } IO跟前面几个Functor不同的地方在于，它的_value是一个函数。它把不纯的操作(比如IO、网络请求、DOM)包裹到一个函数内，从而延迟这个操作的执行。所以我们认为，IO包含的是被包裹的操作的返回值。 IO其实也算是惰性求值。 IO负责了调用链积累了很多不纯的操作，带来的复杂性和不可维护性。 impport _from &apos;lodash&apos;; var compose = _.flowRight; var IO = function(f){ this._value = f; } IO.of = x =&gt; new IO(_ =&gt; x); IO.prototype.map = function(f){ return new IO(compose(f,this._value)); } 流行的几大函数式编程库 RxJS cycleJS lodashJS underscoreJS ramdajs 1.Rxjs从诞生依赖一直都不温不火，但它函数响应式编程(Functional Reactive Programming ,FRP)的理念非常先进，虽然或许对于大部分应用环境，外部输入事件并不是太频繁，并不需要引入一个如此庞大的FRP体系，但我们也可以了解一下它又哪些优秀的特性。 在 Rxjs中，所有的外部输入（用户输入、网络请求等等）都被视作一种【事件流】： 用户点击了按钮 –&gt; 网络请求成功 –&gt; 用户键盘输入 –&gt; 某个定时事件发生 –&gt; 这种事件流特别适合实例游戏，上上下下上上下下 举个例子，下面这段代码会监听点击事件，每两次点击事件产生一次事件相应： var clicks = Rx.Observable .fromEvent(document,&apos;click&apos;) .bufferCount(2) .subscribe(x =&gt; console.log(x)); //打印出两次点击事件 2.Cycle.js 是一个基于Rxjs的框架，它是一个彻彻底底的 FRP 理念的框架，和 React一样支持virtual DOM 、JSX语法，但现在似乎还没有看到大型的应用经验。 本质的讲，它就是在 Rxjs的基础上加入了对 virtual DOM、容器和组件的支持，比如下面就是一个简单的【开关】按钮： function main(sources){ const sinks={ DOM : sources.DOM.select(&apos;input&apos;).events(&apos;click&apos;) .map(ev =&gt; ev.target.checked) .startWith(false) .map(toggled =&gt; &lt;div&gt; &lt;input type=&quot;checkbox&quot; /&gt; Toggle me &lt;p&gt;{toggled ? &apos;ON&apos; ： &apos;off&apos;}&lt;/p&gt; &lt;/div&gt; ) }; return sinks; } const drivers={ DOM:makeDOMDriver(&apos;#app&apos;) }; run(main,drivers); 3.Underscore 是一个 javascript工具库，它提供了一整套函数式编程实用功能，但是没有扩展任何 javascript内置对象。 它解决了这个问题：”如果我面对一个空白的html页面，并希望立即开始工作，我需要什么？”它你不了jquery没有实现的功能，同时又是backbone必不可少的部分。 underscore提供了100多个函数，包括常用的：map、filter、invoke 当然还有更专业的辅助函数，如：函数绑定、javascript模板功能、创建快速索引、强类型相等测试等等。 4.lodash是一个具有一致接口、模块化、高性能等特性的javascript工具库，是unserscorejs的 fork,最初目标也是”一致的跨浏览器行为，并改善性能。” lodash采用延迟计算，意味着我们的链式方法在显式或者隐式的value()调用之前是不会执行的，因此lodash可以进行 shortcut(捷径)fusion(融合)这样的优化，通过合并链式大大降低迭代的次数，从而大大提升其执行性能。 就如同jquery在全部函数前加全局的$一样，lodash使用全局的 _来提供对工具的快速访问。 var abc = function(a,b,c){ return [a,b,c]; }; var currid = _.curry(abc); curried(1)(2)(3); ------ function square(n){ return n*n; } var addSquare = _.flowRight(square,_.add); addSquare(1,2); // =&gt; 9 5.Ramdajs: 是一个非常优秀的js工具库，跟同类比更函数式主要体现在以下几个原则。 ramda里面的提供的函数全部都是curry的，意味着函数没有默认参数可选参数从而减轻认知函数的难度。 ramda 推崇pointfree简单的说就是使用简单函数组合实现一个复杂功能，而不是单独写一个函数操作临时变量。 ramda有个非常好用的参数占位符 R._ 大大减轻了函数在 pointfree过程中参数位置的问题。 相比underscore/lodash感觉更干净很多。 函数式编程实际应用场景 易调试、热部署、并发 单元测试 总结与补充 易调试、热部署、并发 函数式编程中得每个符号都是const的，于是没有什么函数会有副作用。 谁也不能在运行时修改任何东西，也没有函数可以修改在它的作用域之外修改什么值给其他函数继续使用。 这意味着决定函数执行结果的唯一因素就是他的返回值，而影响其返回值的唯一因素就是它的参数。 函数式变成不需要考虑”死锁”（deadlock）,因为它不仅改变量，所以根本不存在”锁”线程的问题。不必担心 一个线程的数据被另一个线程修改，所以可以发那个心把工作分摊到多个线程，部署”并发编程”（concurrency）。 函数式编程中所有状态就是传给函数的参数，而参数都是储存在栈上的。这一特性让软件的热部署变得十分简单。 只要比较一下正在运行的代码以及新的代码获得一个diff,然后用这个diff更新现有的代码，新代码的热部署就完成了。 单元测试 严格函数式编程的每一个函数都是对直接量或者表达式结果的引用，没有函数产生副作用。 因为从未在某个地方修改过值，也没有函数修改过在其作用域之外的量并被其他函数使用(如类成员或全局变量)。 这意味着函数求值的结果只是其返回值，而唯一影响其返回值的就是函数的参数。 这就是单元测试者的梦中仙境。对被测试程序中的每个函数，你只需在意其参数，而不必考虑函数调用顺序，不用谨慎地设置外部状态。 所有要做的就是传递代表了边际情况的参数。如果程序中的每个函数都通过了单元测试，你就对这个软件的质量有了相当的自信。 而命令式编程就不能这样乐观了，在java或 c++中只检查函数的返回值还不够–我们还必须验证这个函数可能修改了外部状态。 总结与补充函数式编程不应被视为灵丹妙药。相反的，它应被视为我们现有工具箱的一个很自然的补充—它带来的更高的可组合型，灵活性以及容错性。现代的javascript库已经开始尝试拥抱函数式编程的概念以获取这些优势。Redux作为一种 FLUX的变种实现，核心理念也是状态机和函数式编程。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"vue精炼秘籍","date":"2017-03-28T02:13:07.000Z","path":"2017/03/28/vue/","text":"Vuex理论介绍 Vuex核心概念 Vuex搭载vue-Resource&amp;vue-router Vue2+Webpack2+KOA2构建大型应用 Vuex理论基础1.Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 devtools。2.不开发大型单页应用尽量不要使用Vuex。3.多个视图依赖于同一状态。来自不同视图的行为需要变更同一状态。 state，驱动应用的数据源； view，以声明方式将state映射到视图； actions，响应在view上的用户输入导致的状态变化。vuex 的不同1.Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。2.你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 mutations。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 store Vue.use(Vuex) const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) store.commit(&apos;increment&apos;) console.log(store.state.count) // -&gt; 1 Vuex核心模块 State Getters Mutations Actions Modules 1.State 单一状态树，用一个对象就包含了全部的应用层级状态。 mapState 当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。 对象展开符号……mapState({}) import { mapState } from &apos;vuex&apos; export default { computed: mapState({ count: state =&gt; state.count, countAlias: ‘count&apos;, countPlusLocalState (state) { return state.count + this.localCount } } //…mapState({count})扩展函数符 } 2.Getters 从 store 中的 state 中派生出一些状态 mapGetters 辅助函数仅仅是将 store 中的 getters 映射到局部计算属性 getters（可以认为是 store 的计算属性） const store = new Vuex.Store({ state: { todos: [ { id: 1, text: &apos;...&apos;, done: true }, { id: 2, text: &apos;...&apos;, done: false } ] }, getters: { doneTodos: state =&gt; { return state.todos.filter(todo =&gt; todo.done) } } }) computed: { doneTodosCount () { return this.$store.getters.doneTodosCount } } computed: { ...mapGetters([ &apos;doneTodosCount&apos; ]) } 3.Mutations 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation（不能直接调用句柄，必须通过触发） mutations就是vue methods 每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler) 使用常量替代 Mutation 事件类型 mutation 必须是同步函数 // mutation-types.js export const SOME_MUTATION = ‘SOME_MUTATION&apos; // store.js import { SOME_MUTATION } from &apos;./mutation-types&apos; const store = new Vuex.Store({ state: { ... }, mutations: { [SOME_MUTATION] (state) { // mutate state } } }) //Mutations (调用) import { mapMutations } from ‘vuex&apos; import { SOME_MUTATION } from &apos;./mutation-types&apos; export default { methods: { test(){ this.$store.commit(SOME_MUTATION) }, ...mapMutations([ &apos;SOME_MUTATION&apos; // 映射 this.increment() 为 this.$store.commit(&apos;SOME_MUTATION&apos;) ]) } } 4.Actions Action 提交的是 mutation Action 可以包含任意异步操作 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用 view store.dispatch(‘increment’) action commit(‘someMutation’) actions: { async actionA ({ commit }) { commit(&apos;gotData&apos;, await getData()) }, async actionB ({ dispatch, commit }) { await dispatch(&apos;actionA&apos;) // 等待 actionA 完成 commit(&apos;gotOtherData&apos;, await getOtherData()) } } //Actions（调用） import { mapActions } from &apos;vuex&apos; export default { methods: { test(){ store.dispatch(‘actionB&apos;); }, ...mapActions([ ‘actionB&apos; // 映射 this.increment() //this.$store.dispatch(‘actionB’) ]) } } 5.Modules Vuex 运行我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割。 store 创建之后，你可以使用 store.registerModule 方法注册模块： const moduleA = { state: { ... }, mutations: { ... }, actions: { ... }, getters: { ... } } const moduleB = { state: { ... }, mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB } }) store.state.a // -&gt; moduleA 的状态 store.state.b // -&gt; moduleB 的状态 store.registerModule(&apos;myModule&apos;, { // ... }) 6.Plugins Vuex 的 store 接受 plugins 选项，这个选项暴露出每次 mutation 的钩子。Vuex 插件就是一个函数，它接收 sotre 作为唯一参数。 在插件中不允许直接修改状态——类似于组件，只能通过提交 mutation 来触发变化。 自定义的状态快照。 const myPlugin = store =&gt; { // 当 store 初始化后调用 store.subscribe((mutation, state) =&gt; { // 每次 mutation 之后调用 // mutation 的格式为 { type, payload } }) } const store = new Vuex.Store({ plugins: [myPlugin] }) 其他补充 Vuex的思维处理表单 测试Actions需要增加一个mocking服务层，测试文件中用 mock 服务回应 API 调用。为了便于解决 mock 依赖，可以用 Webpack 和 inject-loader 打包测试文件。 Hot Module Replacement API，Vuex 支持在开发过程中热重载 mutation、modules、actions、和getters。 测试Actions演示 import { expect } from &apos;chai&apos; const actionsInjector = require(&apos;inject!./actions&apos;) // 使用 mocks 创建模块 const actions = actionsInjector({ &apos;../api/shop&apos;: { getProducts (cb) { setTimeout(() =&gt; { cb([ /* mocked response */ ]) }, 100) } } }) 测试代码 describe(&apos;actions&apos;, () =&gt; { it(&apos;getAllProducts&apos;, done =&gt; { testAction(actions.getAllProducts, [], {}, [ { type: &apos;REQUEST_PRODUCTS&apos; }, { type: &apos;RECEIVE_PRODUCTS&apos;, payload: { } } ], done) }) }) vuex-router-sync1.视图层 &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; 2.结合 Vuex import { sync } from &apos;vuex-router-sync&apos; import store from &apos;./vuex/store&apos; import router from &apos;./router&apos; sync(store, router) this.$store.state.route.path // current path (string) this.$store.state.route.params // current params (object) this.$store.state.route.query // current query (object)","tags":[{"name":"vuejs   vue","slug":"vuejs-vue","permalink":"http://yoursite.com/tags/vuejs-vue/"}]},{"title":"CSS3核心高级技巧","date":"2017-03-21T03:32:46.000Z","path":"2017/03/21/CSS3核心高级技巧/","text":"早期的双飞翼布局+CSS HACK 基于移动端的PX与REM转换兼容方案 弹性盒模型与Reset的选择 自制的ICON-FONT与常用字体排版 CSS代码检测与团队项目规范 CSS绘制特殊图形 高级技巧 CSS高效动画 WorkFlow与分层（详细讲解） 双飞翼布局+CSS HACK position float 负边距 等高 盒子模型 清除浮动 IE6经典bug IE6怪异解析之padding与border算入宽高原因：未加文档声明造成非盒模型解析解决方法：加入文档声明&lt;!doctype html&gt; IE6在块元素、左右浮动、设定maring时造成margin双倍（双边距）解决方法：display:inline 以下三种其实是同一种bug，其实也不算是个bug，举个例子：父标签高度20，子标签11，垂直居中，20-11=9，9要分给文字的上面与下面，怎么分？IE6就会与其它的不同，所以，尽量避免。1）字体大小为奇数之边框高度少1px解决方法：字体大小设置为偶数或line-height为偶数2）line-height，文本垂直居中差1px解决方法：padding-top代替line-height居中，或line-height加1或减13）与父标签的宽度的奇偶不同的居中造成1px的偏离解决方法：如果父标签是奇数宽度，则子标签也用奇数宽度;如果是父标签偶数宽度，则子标签也用偶数宽度 内部盒模型超出父级时，父级被撑大解决方法：父标签使用overflow:hidden line-height默认行高bug解决方法：line-height设值 行标签之间会有一小段空白解决方法：float或结构并排(可读性差，不建议) 标签高度无法小于19px解决方法：overflow:hidden; 左浮元素 margin-bottom 失效解决方法：显示设置高度 or 父标签设置 padding-bottom代替子标签的margin-bottom 再放个标签让父标签浮动，子标签margin-bototm，即（margin-bottom与float不同时作用于一个标签） img于块元素中，底边多处空白解决方法：父级设置overflow:hidden;或img{display:block;或 img:-5px; li之间会有间距解决方法：float:left; 块元素中有文字及右浮动的元素，行元素换行解决方法：将行元素于块元素内的文字前 position下的left,bottom错位解决方法：为父级（relative层）设置宽高或者添加 *zoom:1 子级中有设置position,则父级overflow失效解决方法：为父级设置position:relative 基于移动端的PX与REM转换兼容方案 different size different DPR 目前的设计稿一般式640 750 1125 ，一般要先均分成100份，（简荣芳vh,vm）750/10=75px; div宽是240px120px css的书写改为3.2rem 1.6rem。配合响应式修改html根的大小。 字体不建议使用rem,data-dpr属性动态设置字体大小。屏幕变大放更多文字，或者屏幕更大放更多的字。 神奇的padding/margin-top等比例缩放间距。 弹性盒模型与Reset的选择 flex模型 *的杀伤力太大 reset.css重置 Normalize.css修复 Neat.css融合 html{box-sizing:border-box;} :before,X:after{box-sizing:inherit;} ICON-FONT与常用字体排版 no-images时代，不超过纯色为2的图像 宋体非宋体 黑体非黑体 windows下的宋体叫中易宋体 SimSun,Mac是华文宋体STSong。Windows下的黑体叫中易黑体SimHei,Mac华文黑体STHeiti。 不要只写中文字体名，保证西文字体在中文字体前面。Mac-linux-windows 切忌不要直接使用设计师psd的设计font-family，关键时刻再去启动font-face(Typo.css,Entry.css,Type.css) font-family : sans-serif;系统默认，字体多个单词组成加引号。 CSS代码检测团队项目规范1.不要使用多个class选择元素，如a.foo.boo,这在ie6及以下不能正确解析2.移除空的css规则，如a{}3.正确使用显示属性，如display:inline不要和width,height,float,margin,padding同时使用display:inline-block不要和float同时使用等4.避免过多的浮动，当浮动次数超过十次时，会显示警告5.避免使用过多的字号，当字号声明超过十种时，显示警告6.避免使用过多的web字体，当使用超过五次时，显示警告7.避免使用id作为样式选择器8.标题元素只定义一次9.使用width:100%时要小心10.属性值为0时不要写单位11.各浏览器专属的css属性要有规范，例如.foo{-moz-border-radius:5px;border-radius:5px}12.避免使用看起来像正则表达式的css3选择器13.遵守合模型规则 CSS绘制高级技巧 border &amp;&amp; border-radius 造就万千可能 linear-gradient();radial-gradient();渐变轴：每个色标的推进以圆心为中心同心圆扩散。","tags":[{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"React Flux架构","date":"2017-03-20T02:53:50.000Z","path":"2017/03/20/React-Flux/","text":"Flux架构介绍 React性能调优 Redux介绍与实战 GraphQL and Relay Flux架构介绍 React :本身只涉及UI层，如果搭建大型应用，必须搭配一个前端框架。 Flux :是一种架构思想，专门解决软件的结构问题。它跟MVC 架构是同一类东西，但是更加简单和清晰。 View : 视图层 Action（动作）: 视图层发出的消息（比如mouseClick） Dispatcher（派发器）: 用来接收Actions、执行回调函数 Store（数据层）: 用来存放应用的状态，一旦发生变动，就提醒Views要更新页面 1.用户访问 View2.View 发出用户的 Action3.Dispatcher 收到 Action，要求 Store 进行相应的更新4.Store 更新后，发出一个”change”事件5.View 收到”change”事件后，更新页面 React性能调优this.state.list.get(&quot;items&quot;).map(function(label) { return &lt;div&gt;&lt;CheckboxWithLabel onChange={this.onChange} &gt;&lt;/CheckboxWithLabel&gt;&lt;/div&gt; }); onChange:function(){ this.setState({label:123}) } shouldComponentUpdate: function(nextProps, nextState) { return nextProps.label !== this.props.label; } mixins: [React.addons.PureRenderMixin], constructor(props) { super(props); this.shouldComponentUpdate = React.addons.PureRenderMixin.shouldComponentUpdate.bind(this); } 子组件的更新触发父组件。父组件更新全部子组件要Diff,一旦更改了state类型，上面全部办法歇菜。 Redux介绍与实战 Flux存在多种实现（至少15种）Redux还算不错 redux.min.js、react-redux.js、redux-thunk.min.js、keyMirror.js、immutable.min.js、reqwest.js（fectch）、ReduxThunk.js 管理应用的 State: 通过 store.getState() 可以获取 State 通过 store.dispatch(action) 来触发 Stete 更新 通过 store.subscribe(listener) 来注册 state 变化监听器 通过 createStore(reducer, [initialState]) 创建 Provider(ReactRedux)注入store Actions JavaScript 普通对象 通过constants取到 对应 Actions Reducer 返回规律，更具体的是返回状态( Redux.combineReducers返回唯一的 Reducer)。 Store(Redux.createStore(rootReducer,Redux.applyMiddleware(thunkMiddleware)))具体实施的载体 components具体React的组件但是不涉及状态 components-&gt;APP容器 react-redux 提供 connect 的方法 链接React组件和Redux类 Redux架构异步的Reducer import configureStore from &apos;./store/configureStore.es&apos;; import App from &apos;./containers/App.es&apos;; const Provider = ReactRedux.Provider; const store = configureStore(); //通过store.getState()可以获取state //通过store.dispatch(action)来处罚state更新 //通过store.subscribe(listener)来注册state变化监听器 //通过createStore(reducer,[initialState])创建 ReactDOM.render( &lt;Provider store={store}&gt; &lt;App/&gt; &lt;/Provider&gt;, document.getElementById(&apos;JS-container&apos;) )","tags":[{"name":"react flux","slug":"react-flux","permalink":"http://yoursite.com/tags/react-flux/"}]},{"title":"javascript语言精髓","date":"2017-02-11T01:36:06.000Z","path":"2017/02/11/javascript语言精髓/","text":"闭包、作用域、原型链if(!(“userName” in window)){ var userName=“zhengzheng.xz”; } console.log(userName); var obj = { user: “zhengzheng.xz” getName:function(){ return user; } } var getNameFn = obj.getName; console.log(getNameFn()); console.log(obj.getName()); 作用域的种类 作用域有大到小: 1.程序级 2.件级 3.函数级 4.块级 javascript作用域 全局作用域 : 1.函数作用域 2.块级作用域(ES6) var global = 1; function doSomething(){ var inner = 2; globalA = 3; } doSomething(); alert(global);// 1 alert(globalA);// 3 alert(inner);// undefined javascript作用于链 什么是作用域链?在JavaScript中,函数也是对象,函数对象和其它对象一样,拥有可以通过代码访问的属性和一系仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]],由ECMA-262标准第三版定义,该内部属性包含了函数被创建的作用域中对象的集合, 这个集合被称为函数的作用域链,它决定了哪些数据能被函数访问。 var test = “aaa”; function doSomething(){ alert(test); var test = “bbb”; alert(test); //bbb } doSomething(); alert(test); // aaa 变量与函数声明提前function foo(){ alert(test); var test = “bbb”; alert(test); } foo(); 执行顺序: 声明函数foo 调用函数foo 声明变 test alert(test); test变量赋值为bbb alert(test); javascript中的this关键字 this指向哪 ?在Javascript中,this指向函数执行时的当前对象。 (In JavaScript, as in most object-oriented programminglanguages, this is a special keyword that is used within methods to refer to the object on which a method is being invoked.)——jQuery Fundamentals (Chapter 2), by Rebecca Murphey this使用场景1.普通函数中: 严格模式:undefined 非严格模式:全局对象(window)2.构造函数中:对象的实例3.对象方法: 对象本身 call 、apply、bind*使用方法: 1.fn.call(context, arg1, arg2, …, argn); 2.fn.apply(context, [arg1,arg2,…,argn]); 3.function(){…}.bind(context)通过这三个方法可以改变被调用函数中this指向的对象 if(!(“userName” in window)){ var userName=“zhengzheng.xz”; } console.log(userName); //undefined var obj = { user: “zhengzheng.xz” getName:function(){ return this.user; } } var getNameFn = obj.getName; console.log(getNameFn()); //undefined console.log(obj.getName()); //zhengzheng.xz javascript原型与原型链 原型对象是什么？在Javascript中,每定义一个对象(函数)时,对象中都会包含一些预定义的属性。其中函数对象的一个属性就是原型对象prototype。普通对象没有prototype属性,但有 proto属性 function f1(){}; console.log(typeof f1.prototype); //object console.log(typeof Function.prototype) //Function,这个特殊 console.log(typeof Object.prototype) //object console.log(typeof Function.prototype.prototype)//undefined 原型对象有什么用？面向对象开发、类的继承 function Person(name){ this.name=name; } Person.prototype.getName=function(){ return this.name; } var xu=new Person(&apos;jiaojiao.xz&apos;); xu.getName(); //jiaojiao.xz 构造函数1.使用new关键字调用的函数2.构造函数可以实例化一个对象3.返回值,默认返回类的实例4.特殊情况: 没有返回值 简单数据类型 对象类型 function People(name,age){ this.name=name; this.age=age; } var people=new People(&apos;Byron&apos;,26); 原型链是如何实现的？总结 每个函数都有一个prototype的对象属性 每个对象都有一个proto属性,该属性指向其父类的prototype对象 原型对象中的constructor 每个原型对象prototype中都有一个constructor属性,默认指向函数本身。 Person.prototype.constructor===Person; //true Function.prototype.constructor===Function; //true Object.prototype.constructor===Object; //true Object.prototype.constructor===Function; //true 练习一: function make(num){ return function(){ return num; } } var arr = [make(0),make(1),make(2)]; alert(arr[0]()); // 0 alert(arr[1]()); // 1 alert(arr[2]()); // 2 练习二： var name = ‘global’; function A(name){ alert(name); this.name = name; var name = ‘1’; } A.prototype.name = ‘2’; var a = new A(‘3’); alert(a.name); delete a.name; alert(a.name); // 3 // 3 // 2 练习三： function fun(n,o){ console.log(o); return { fun:function(m){ return fun(m, n) } } } var a = fun(0); a.fun(1); a.fun(2); var b = fun(0).fun(1).fun(2).fun(3); var c = fun(0).fun(1); c.fun(2); c.fun(3);","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"css工作流","date":"2017-01-12T08:09:11.000Z","path":"2017/01/12/css工作流/","text":"css预处理器“An preprocessor is a program that processes its input to produce output that is used as input to another program ”处理特定格式源文件到目标css的处理程序 预处理器变革 body { left:&lt;%= left %&gt;px; color:&lt;%= color|highlight: 10% %&gt;; } @base:#f938ab; box-shadow(@style,@c)when(iscolor(@c)){ -webkit-box-shadow:@style @c; box-shadow: @style @c; } box{ color:saturate(@base,5%); border-color:lighten(@base,30%); div{.box-shadow(0 0 5px,30%)} } 预处理器常用规范 变量 混合（Mixin） Extend 嵌套规则 运算 函数 Namespaves &amp; Accessors Scope 注释 W3C标准实现 .m-layer{ height:var(--height); width:var(--width); background-color:blue; } .m-layer-sm{ --height:100px; --width:100px; } .m-layer-bg{ --height:200px; --width:200px; } &lt;div class=&quot;m-layer m-layer-bg&quot;&gt;&lt;/div&gt; CSS后处理器 css压缩 ClEAN-CSS 自动添加浏览器前缀 Autoprefixer CSS更加美观排序 CSScomb Rework 取代Styles后处理器发热 前后都行 PostCss :root{ --red:#d33; } a{ &amp;:hover{ color:color(var(--red) a(54%)); } } a:hover{ color:#dd3333; color:rgba(221,51,51,0.54); } 抽象语法树（Abstract Syntax Tree,AST）作为程序的一种中间表示形式 POSTCSS值得收藏的插件 POSTCSS-CUSTOM-PROPERTIES 运行时变量 POSTCSS-SIMPLE-VARS 与SCSS一致的变量实现 POSTCSS-MIXINS 实现类似SASS的@MIXIN的功能 POSTCSS-EXTEND 实现类似SASS的继承功能 POSTCSS-IMPORT 实现类似SASS的IMPORT CSSNext 面向未来 CSS Grace 修复过去 var gulp = require(&apos;gulp&apos;); var postcss = require(&apos;gulp-postcss&apos;); var autoprefixer = require(&apos;autoprefixer&apos;); var cssgrace = require(&apos;cssgrace&apos;); var cssnext = require(&apos;cssnext&apos;); gulp.task(&apos;css&apos;, function () { var processors = [ autoprefixer({browsers: [&apos;last 3 version&apos;], cascade: false, remove: false }), cssnext(), cssgrace ]; return gulp.src(&apos;./src/css/*.css&apos;) .pipe(postcss(processors)) .pipe(gulp.dest(&apos;./dist&apos;)); }); gulp.task(&apos;watch&apos;, function(){ gulp.watch(&apos;./src/css/*.css&apos;, [&apos;css&apos;]); }); gulp.task(&apos;default&apos;, [&apos;watch&apos;, &apos;css&apos;]);","tags":[{"name":"css工作流 css预处理器 css后处理器","slug":"css工作流-css预处理器-css后处理器","permalink":"http://yoursite.com/tags/css工作流-css预处理器-css后处理器/"}]}]