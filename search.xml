<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[小程序面向个人开发者开放]]></title>
      <url>http://yoursite.com/2017/03/28/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%9D%A2%E5%90%91%E4%B8%AA%E4%BA%BA%E5%BC%80%E5%8F%91%E8%80%85%E5%BC%80%E6%94%BE/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>3月27日晚上10点，微信官方通过“微信公开课”和“微信公众平台”发布重磅消息称，小程序对个人开发者开放注册，并宣布小程序新增六大能力。</li>
</ul>
</blockquote>
<p>   新增6大功能为：个人开发者开放、公众号自定义菜单跳小程序、公众号模版消息可打开相关小程序、模板消息跳小程序 、绑定时可发送模板消息、兼容线下二维码、App分享用小程序打开。</p>
<p>1.<strong>个人开发者可申请小程序</strong></p>
<p>   小程序开放个人开发者申请注册，个人用户可访问微信公众平台，扫码验证个人身份后即可完成小程序帐号申请并进行代码开发。</p>
<p>   申请个人开发者的个人需要实名。现在，对小程序感兴趣，并且有开发能力者，可以在开放的类目范围内，通过开发小程序，把自己的“一个想法”变成“一件作品”，并为微信用户所使用，进一步发挥开发者的个人价值。</p>
<blockquote>
<ul>
<li><p>个人开发者可以做些什么？</p>
</li>
<li><p>Q：作为一个个人开发者，我可以申请注册几个小程序？可以开发什么类型的小程序？</p>
</li>
<li><p>A：每个个人可申请5个小程序（身份证+微信号合计5个），不占用组织类型帐号的名额。目前，个人开发者可以开发生活服务、工具、旅游、出行与交通、餐饮、商业服务、体育、快递业与邮政、教育等类别的小程序。后续，支持的类目会随平台规则而调整。</p>
</li>
<li><p>Q：和组织类型开发者相比，个人开发者在小程序的开发上有什么不同？</p>
</li>
<li><p>A：和组织类型开发者相比，个人类型开发者的开发流程更短：注册——验证身份——填写详细信息——开发——提交代码审核——审核通过后可发布。</p>
</li>
<li><p>Q：目前，小程序对于个人开发者开放了哪些能力？</p>
</li>
<li><p>A：小程序对个人开发者开放的API能力和组织类型的基本一致，如消息通知（客服消息、模板消息）、自定义二维码生成等能力，也支持同主体的公众号关联。</p>
</li>
<li><p>在开放能力上，我们希望有更多的突破，以帮助个人能在开发中更好地运用开发工具。因此，我们开放了更多的接口权限给到了个人开发者。目前，个人小程序不支持进行个人认证、支付和卡券功能。</p>
</li>
</ul>
</blockquote>
<p>请访问：微信公众平台<a href="https://mp.weixin.qq.com/" target="_blank" rel="external">wx</a></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/Sl2B4aOmG2MdomPTjz8wt5AhZ9eJvcD1tM4L4YnHKDibxRicaWwK0pmxSqT4YGKDdGY2k4XMdHtnSVyOxPb9Hyzg/640?wx_fmt=jpeg" alt=""></p>
<p>2.<strong>公众号自定义菜单点击可打开相关小程序</strong></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Sl2B4aOmG2MdomPTjz8wt5AhZ9eJvcD1V9w0XyibD2zmNYSEAECoz89USoxEWZoia2g9YFicEkWwPibVv41uic2HrAA/640?wx_fmt=png" alt=""></p>
<p>公众号可将已关联的小程序页面放置到自定义菜单中，用户点击后可打开该小程序页面。公众号运营者可在公众平台进行设置，也可以通过自定义菜单接口进行设置。</p>
<p>详见开发文档：微信公众平台文档<a href="https://mp.weixin.qq.com/wiki" target="_blank" rel="external"></a>-自定义菜单</p>
<p>3.<strong>公众号模版消息可打开相关小程序</strong></p>
<p>公众号已关联的小程序页面可以配置到公众号的模版消息中，用户点击公众号下发的模版消息，可以打开对应的小程序页面。</p>
<p>详见开发文档：微信公众平台文档(mp.weixin.qq.com/wiki)-模版消息</p>
<p>4.<strong>公众号关联小程序时，可选择给粉丝下发通知</strong></p>
<p><img src="https://mmbiz.qlogo.cn/mmbiz_png/Sl2B4aOmG2MdomPTjz8wt5AhZ9eJvcD1ZqTbVmKAmSibaCZppvxrYl293fhmSasBl68dKYhGtsLGtAiaN2CE37RA/0?wx_fmt=png" alt=""></p>
<p>公众号关联小程序时，可选择给粉丝下发通知消息，粉丝点击该通知消息可以打开小程序。该消息不占用原有群发条数。</p>
<p>5.<strong>移动App可分享小程序页面</strong></p>
<p>开发者可以把小程序绑定到微信开放平台。绑定后，同一微信开放平台帐号下的App可分享已绑定的小程序页面到微信内的会话或群聊。APP链接分享到微信，点开就是小程序。</p>
<p>详见开发文档：微信开放平台<a href="https://open.weixin.qq.com" target="_blank" rel="external"></a>-资源中心-移动应用-分享与收藏功能</p>
<p>6.<strong>扫描普通链接二维码可打开小程序</strong></p>
<p>商户如果在线下已铺设了普通链接二维码，可在公众平台的小程序管理后台进行配置，用户扫描该原有线下普通链接二维码可直接打开小程序。</p>
<p>微信官方称，摩拜单车扫描单车二维码直接进入小程序的能力，现在通用了。</p>
<h2 id="总结：公众号和小程序新增三种连接方式："><a href="#总结：公众号和小程序新增三种连接方式：" class="headerlink" title="总结：公众号和小程序新增三种连接方式："></a>总结：公众号和小程序新增三种连接方式：</h2><p>在支持公众号绑定相关小程序后，公众号和小程序有了三种新的连接跳转方式：</p>
<p>①公众号可以把自己关联的小程序放在自定义菜单中，用户点击可直达小程序。</p>
<p>②公众号模版消息可打开相关小程序。通过公众号，公众号运营者可以推送关联的小程序页面了。</p>
<p>③公众号绑定相关小程序时，可选择给粉丝下发通知。公众号运营者可以通知粉丝，“我绑定了这个小程序”，粉丝点击消息就可以打开小程序。（此消息不占用原有群发条数）</p>
]]></content>
      
        
        <tags>
            
            <tag> 小程序开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript函数式编程]]></title>
      <url>http://yoursite.com/2017/03/28/javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<ul>
<li>函数式编程思维</li>
<li>函数式编程常用核心概念</li>
<li>当下函数式编程最热的库</li>
</ul>
<h2 id="函数式编程基础理论"><a href="#函数式编程基础理论" class="headerlink" title="函数式编程基础理论"></a>函数式编程基础理论</h2><p>1.函数式编程（Functional Programming）相对计算机历史而言是一个古老的概念，甚至早于第一台计算机的诞生。函数式编程的基础模型来源于 ℷ (lambda x=x&gt;x*2)演算，<br>     而 ℷ 演算并非设计于在计算机上执行，它是一套用于研究函数定义、函数应用和递归的形式系统。<br>2.函数式编程不是用函数来编程，也不是传统的面向过程编程。是将复杂的函数符合成简单的函数（计算理论、递归论、ℷ 演算）。运算过程尽量写成一系列嵌套的函数调用。<br>3.javascript是披着 C 外衣的lisp。<br>4.真正的火热是随着React的高阶函数而逐步升温。</p>
<blockquote>
<ul>
<li><strong>函数</strong>：函数是一等公民，指的是<strong>函数与其他数据类型一样</strong>，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</li>
<li><strong>不可变量</strong>：在函数编程中，我们通常理解的变量在函数式编程中也被函数代替了。<strong>在函数编程中变量仅仅代表某个表达式</strong>。这里所说的’变量’是不能被修改的。<br>  所有的变量只能被赋值一次初值。</li>
<li>map &amp; reduce 他们是最常用的函数式编程的方法。</li>
</ul>
</blockquote>
<h2 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h2><ul>
<li>纯函数</li>
<li>函数的柯里化</li>
<li>函数组合</li>
<li>Point Free</li>
<li>声明式与命令式代码</li>
<li>惰性求值</li>
</ul>
<p>1.纯函数：对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。</p>
<pre><code>var arr=[1,2,3,4,5];
// Array.slice是纯函数，因为它没有副作用，对于固定的输入，输出总是固定的
xs.slice(0,3);
xs.slice(0,3);
xs.slice(0,3);
xs.slice(0,3);
</code></pre><p>优缺点：</p>
<pre><code>import_from &apos;lodash&apos;;
var sin=_.memorize(x=&gt;Math.sin(x));
//第一次计算的时候会稍微慢一点 var a=sin(1);
//第二次有了缓存，速度极快  var b=sin(1);
</code></pre><p>纯函数不仅可以有效降低系统的复杂度，还有很多很棒的特性，必如<strong>可缓存性</strong>；</p>
<pre><code>//不纯的
var min=18;
var checkage = age =&gt; age &gt;18;
</code></pre><p>在不纯的版本中，checkage不仅取决于age还有外部依赖的变量min。纯的checkage把关键数字18硬编码在函数内部，扩展性比较差，柯里化优雅的函数式解决。</p>
<p>2.函数的柯里化：传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
<pre><code>var checkage = min =&gt;(age =&gt; age &gt;min);
var checkage18 =checkage(18);
checkage18(20); 
</code></pre><p>优缺点：</p>
<pre><code>import {curry} from &apos;lodash&apos;;
var match=curry((reg,str)=&gt; str.match(reg));
var filter=curry((f,arr)=&gt; arr.filter(f));
var haveSpace = match(/\s+/g);
haveSpave(&quot;ffffff&quot;);
haveSpace(&quot;a b&quot;);

filter(haveSpace,[&quot;abcdefg&quot;,&quot;Hello World&quot;]);
//=&gt;[&quot;Hello world&quot;];
</code></pre><p><strong>事实上柯里化是一种 “预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的”缓存”，是一种非常高效的编写函数的方法。</strong></p>
<p>3.函数组合：纯函数以及如何把它柯里化写出的层叠代码h(g(f(x))),为了解决函数嵌套问题，我们需要用到”函数组合”。</p>
<pre><code>//我们用柯里化改，让多个函数像拼积木一样
const compose = (f,g) =&gt; (x =&gt; f(g(x)));
var first = arr =&gt; arr[0];
var reverse = arr =&gt; arr.reverse();
var last = compose(first,reverse);
last([1,2,3,4,5]);
</code></pre><p>4.Point Free: 把一些对象自带的方法转化成纯函数，不要命名转瞬即逝的中间变量。</p>
<pre><code>const f = str =&gt; str.toUpperCase().split(&apos;&apos;);
</code></pre><p>这个函数中，我们使用了str作为中间变量，但是这个中间变量除了让代码长以外毫无意义。</p>
<p>优缺点: </p>
<pre><code>var toUpperCasre = word =&gt; word.toUpperCase();
var split = x =&gt; (str =&gt; str.split(x));
var f = compose(split(&apos;&apos;),toUpperCase);
f(&quot;abcd efgh&quot;);
</code></pre><p>这种风格能够帮助我们减少不必要的命名，让代码保持简洁和通用。</p>
<p>5.声明式与命令式代码</p>
<p>命令式代码：通过编写一条又一条指令让计算机执行一些动作，一般都会涉及到很多繁杂的细节。<br>声明式代码：通过写表达式的方法来声明我们想干什么，而不是通过一步一步的指示。</p>
<pre><code>//命令式
let CEOs=[];
for(var i=0;i&lt;companies.length;i++){
    CEOs.push(comanies[i].CEO);
}
//声明式
let CEOs=companies.map(c =&gt; c.CEO);
</code></pre><p>优缺点：函数式编程的一个明显好处就是这种声明式的代码，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的，专注于编写业务代码。<br>优化代码时，只需要集中在稳定坚固的函数内部。相反，不纯的函数式的代码会产生副作用或者依赖外部系统环境，使用他们的时候总要考虑这些副作用，<br>在复杂的系统中，这对于程序员是极大的负担。</p>
<p>6.惰性求值、惰性函数</p>
<p>在指令式语言中以下代码会按顺序执行，由于每个函数都有可能改动或者依赖于外部状态，因此必须顺序执行。<br>把concatenate 换成另外一个函数，这个函数中又条件判断语句，实际上只会需要两个参数中的其中一个，<br>那么就没有必要执行计算另外一个参数的函数了。</p>
<pre><code>var s1=somewhatlongOperation1();
var s2=somewhatlongOperation2();
var s3=concatenate(s1,s2);
function somewhatlongOperation1(){somewhatlongOperation1}
</code></pre><h2 id="更加专业术语"><a href="#更加专业术语" class="headerlink" title="更加专业术语"></a>更加专业术语</h2><ul>
<li>高阶函数</li>
<li>尾调用优化</li>
<li>闭包</li>
<li>容器、Functor</li>
<li>错误处理、Either</li>
<li>IO</li>
<li>Monad</li>
</ul>
<p>1.高阶函数：函数当参数，把传入的函数做一个封装，然后返回这个封装函数，达到更高程度的抽象。</p>
<pre><code>//命令式
var add = function(a,b){
    return a+b;
};
function math(func,array){
    return func(array[0],array[1]);
}
math(add,[1,2]); //3
</code></pre><p>2.尾调用优化：函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。<br>   函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归需要保存大量的调用记录，很容易发生栈溢出错误，如果使用尾递归优化，<br>   将递归变为循环，那么只需要保存一个调用记录，这样就不会发生栈溢出错误了。</p>
<pre><code>//不是尾递归，无法优化
function factorial(n){
    if(n===1)return 1;
    return n * factorial(n-1);
}
function factorial(n,total){
    if(n===1) return total;
    return factorial(n-1,n*total);
} //es6强制使用尾递归
</code></pre><p>细数尾递归</p>
<p>实例一：</p>
<pre><code>function sum(n){
    if(n===1)return 1;
    return n + sum(n-1);
}

sum(5)
(5 + sum(4))
(5 + (4 + sum(3)))
(5 + (4 + (3 + sum(2))))
(5 + (4 + (3 + (2 + sum(1)))))
(5 + (4 + (3 + (2 + 1))))
(5 + (4 + (3 + 3)))
(5 + (4 + 6))
(5 + 10)
15
</code></pre><p>普通递归时，内存需要记录调用的堆栈所处的深度和位置信息。<br>在最底层计算返回值，再根据记录信息，跳回上一层级计算，然后再跳回更高一层，依次运行，直到最外层调用函数。<br>在cpu计算和内存会消耗很多，而且当深度过大时，会出现堆栈溢出。</p>
<p>实例二：   </p>
<pre><code>function sum(x,total){
    if(x === 1){
        return x + total;
    }
    return sum(x-1,x + total); 
}

sum(5,0)
sum(4,5)
sum(3,9)
sum(2,12)
sum(1,14)
15
</code></pre><p>整个计算过程是线性的，调用一次 sum(x,total)后，会进入下一个栈，相关的数据信息跟随进入，不再放在堆栈上保存。<br>当计算完最后的值之后，直接返回到最上层的sum(5,0)。这能有效的防止堆栈溢出。<br>在ECMAScript6,我们将迎来尾递归优化，通过尾递归优化，javascript代码在解释成机器码的时候，将会向while看起，也就是说，同事拥有数学表达式能力和while的效能。</p>
<p>3.闭包</p>
<p>如下例子，虽然外层的makePowerFn函数执行完毕，栈上的调用帧被释放，但是堆上的作用域并不被释放，因此power依旧可以被powerFn函数访问，这样就形成了闭包。</p>
<pre><code>function makePowerFn(power){
    function powerFn(base){
        return Math.pow(base,power);
    }
    return powerFn;
}
var square = makePowerFn(2);
square(3); //9
</code></pre><p>4.容器、Functor（函子）</p>
<blockquote>
<ul>
<li>$(…)返回的对象并不是一个原生的DOM对象，而是对于原生对象的一种封装，这在某种意义上就是一个”容器”（但它并不函数式）。</li>
<li>Functor(函子)遵守一些特定规则的容器类型。</li>
<li>Functor是一个对于函数调用的抽象，我们赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口map给容器外的函数，map一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由的选择何时何地如何操作这个函数，以至于拥有惰性求值、错误处理、异步调用等等非常棒的特性。</li>
</ul>
</blockquote>
<pre><code>var Container = fuunction(x){
    this._value = x;
}
Container.of = x =&gt; new Container(x);
//Container.of(&apos;abcd&apos;);
Container.prototype.map = function(f){
    return Container.of(f(this._value));
}
Container.of(3)
    .map(x =&gt; x+1) // =&gt;Container(4)
    .map(x =&gt; &apos;Result is&apos; + x);  // =&gt; Container(&apos;Result is 4&apos;);

---

var Maybe = function(x){
    this._value = x;
}
Maybe.of = function(x){
    return new Maybe(x);
}
Maybe.prototype.map=function(f){
    return this.isNothing()? Maybe.of(null) : Maybe.of(f(this._value));
}
Maybe.prototype.isNothing = function(){
    return (this._value === null || this._value === undefined);
}
//新的容器我们称为 Maybe(原型来自于 Haskell)
</code></pre><p>5.错误处理、Either</p>
<blockquote>
<ul>
<li>我们的容器能做的事情太少，try/catch/throw 并不是”纯”的，因为它从外部接管了我们的函数，并且在这个函数出错时抛弃了它的返回值。</li>
<li>Promise 是可以调用 catch来集中处理错误的。</li>
<li>事实上Either并不只是用来做错误处理的，它表示了逻辑或，范畴学里的coproduc。</li>
</ul>
</blockquote>
<pre><code>var left = function(x){
    this._value = x;
}
var Right = function(x){
     this._value = x;
}

Left.of = function(x){
    return new Left(x);
}
Right.of=function(x){
    return new Rgith(x);
}

---
//这里不同
Left.prototype.map = function(f){
    return this;
}
Rgiht.prototype.map = function(f){
    return Right.of(f(this._value));
}
</code></pre><p>left和Right 唯一的区别在于 map方法的实现，Right.map的行为和之前提到的map函数一样。<br>但是left.map就很不同了，它不会对容器做任何事情，只是很简单地把这个容器拿进来又扔出去。<br>这个特性意味着，left可以用来传递一个错误消息。</p>
<pre><code>var getAge = user =&gt; user.age ? Right.of(user.age):Left.of(&quot;ERROR&quot;);

getAge({name:&apos;stark&apos;,age:&apos;21&apos;}).map(age =&gt; &apos;Age is&apos;+ age);
// =&gt; Right(&apos;Age is 21&apos;)
get Age({name:&apos;stark}).map(age =&gt; &apos;Age is&apos; +age);
//=&gt; Left(&apos;ERROR&apos;)
</code></pre><p>left 可以让调用链中任意一环的错误立刻返回到调用链的尾部，这给我们错误处理带来了很大的方便，再也不用一层一层的try/catch。</p>
<p>6.IO</p>
<p>真正的程序总要去接触不纯的世界。如下例子就依赖于window。</p>
<pre><code>function readlocalStorage(){
    return window.localStorage;
}
</code></pre><blockquote>
<ul>
<li>IO跟前面几个Functor不同的地方在于，它的_value是一个函数。它把不纯的操作(比如IO、网络请求、DOM)包裹到一个函数内，从而延迟这个操作的执行。所以我们认为，<strong>IO包含的是被包裹的操作的返回值</strong>。</li>
<li>IO其实也算是惰性求值。</li>
<li>IO负责了调用链积累了很多不纯的操作，带来的复杂性和不可维护性。</li>
</ul>
</blockquote>
<pre><code>impport _from &apos;lodash&apos;;
var compose = _.flowRight;

var IO = function(f){
    this._value = f;
}

IO.of = x =&gt; new IO(_ =&gt; x);

IO.prototype.map = function(f){
    return new IO(compose(f,this._value));
}
</code></pre><h2 id="流行的几大函数式编程库"><a href="#流行的几大函数式编程库" class="headerlink" title="流行的几大函数式编程库"></a>流行的几大函数式编程库</h2><ul>
<li>RxJS</li>
<li>cycleJS</li>
<li>lodashJS</li>
<li>underscoreJS</li>
<li>ramdajs</li>
</ul>
<p>1.Rxjs从诞生依赖一直都不温不火，但它函数响应式编程(Functional Reactive Programming ,FRP)的理念非常先进，虽然或许对于大部分应用环境，外部输入事件并不是太频繁，并不需要引入一个如此庞大的FRP体系，但我们也可以了解一下它又哪些优秀的特性。<br>  <strong>  在 Rxjs中，所有的外部输入（用户输入、网络请求等等）都被视作一种【事件流】：</strong><br>  用户点击了按钮 –&gt; 网络请求成功 –&gt; 用户键盘输入 –&gt; 某个定时事件发生 –&gt; 这种事件流特别适合实例游戏，上上下下上上下下<br>  举个例子，下面这段代码会监听点击事件，每两次点击事件产生一次事件相应：</p>
<pre><code>var clicks = Rx.Observable
    .fromEvent(document,&apos;click&apos;)
    .bufferCount(2)
    .subscribe(x =&gt; console.log(x)); //打印出两次点击事件
</code></pre><p>2.Cycle.js 是一个基于Rxjs的框架，它是一个彻彻底底的 FRP 理念的框架，和 React一样支持virtual DOM 、JSX语法，但现在似乎还没有看到大型的应用经验。<br>     本质的讲，它就是在 Rxjs的基础上加入了对 virtual DOM、容器和组件的支持，比如下面就是一个简单的【开关】按钮：   </p>
<pre><code>function main(sources){
   const sinks={
       DOM : sources.DOM.select(&apos;input&apos;).events(&apos;click&apos;)
       .map(ev =&gt; ev.target.checked)
       .startWith(false)
       .map(toggled =&gt;
           &lt;div&gt;
               &lt;input type=&quot;checkbox&quot; /&gt; Toggle me
               &lt;p&gt;{toggled ? &apos;ON&apos; ： &apos;off&apos;}&lt;/p&gt;
           &lt;/div&gt;
       )
   };
   return sinks;
}

const drivers={
   DOM:makeDOMDriver(&apos;#app&apos;)
};

run(main,drivers);    
</code></pre><p>3.Underscore 是一个 javascript工具库，它提供了一整套函数式编程实用功能，但是没有扩展任何 javascript内置对象。</p>
<blockquote>
<ul>
<li><p>它解决了这个问题：”如果我面对一个空白的html页面，并希望立即开始工作，我需要什么？”它你不了jquery没有实现的功能，同时又是backbone必不可少的部分。</p>
</li>
<li><p>underscore提供了100多个函数，包括常用的：map、filter、invoke 当然还有更专业的辅助函数，如：函数绑定、javascript模板功能、创建快速索引、强类型相等测试等等。</p>
</li>
</ul>
</blockquote>
<p>4.lodash是一个具有一致接口、模块化、高性能等特性的javascript工具库，是unserscorejs的 fork,最初目标也是”一致的跨浏览器行为，并改善性能。”</p>
<blockquote>
<ul>
<li><p>lodash采用延迟计算，意味着我们的链式方法在显式或者隐式的value()调用之前是不会执行的，因此lodash可以进行 shortcut(捷径)fusion(融合)这样的优化，通过合并链式大大降低迭代的次数，从而大大提升其执行性能。</p>
</li>
<li><p>就如同jquery在全部函数前加全局的$一样，lodash使用全局的 _来提供对工具的快速访问。     </p>
</li>
</ul>
</blockquote>
<pre><code>var abc = function(a,b,c){
   return [a,b,c];
};
var currid = _.curry(abc);
curried(1)(2)(3);

------
function square(n){
   return n*n;
} 
var addSquare = _.flowRight(square,_.add);
addSquare(1,2);
// =&gt; 9
</code></pre><p>5.Ramdajs: 是一个非常优秀的js工具库，跟同类比更函数式主要体现在以下几个原则。</p>
<blockquote>
<ul>
<li>ramda里面的提供的函数全部都是curry的，意味着函数没有默认参数可选参数从而减轻认知函数的难度。</li>
<li>ramda 推崇pointfree简单的说就是使用简单函数组合实现一个复杂功能，而不是单独写一个函数操作临时变量。</li>
<li>ramda有个非常好用的参数占位符 R._ 大大减轻了函数在 pointfree过程中参数位置的问题。</li>
<li>相比underscore/lodash感觉更干净很多。</li>
</ul>
</blockquote>
<h2 id="函数式编程实际应用场景"><a href="#函数式编程实际应用场景" class="headerlink" title="函数式编程实际应用场景"></a>函数式编程实际应用场景</h2><ul>
<li>易调试、热部署、并发</li>
<li>单元测试</li>
<li>总结与补充</li>
</ul>
<h3 id="易调试、热部署、并发"><a href="#易调试、热部署、并发" class="headerlink" title="易调试、热部署、并发"></a>易调试、热部署、并发</h3><blockquote>
<ul>
<li><p>函数式编程中得每个符号都是const的，于是没有什么函数会有副作用。<br> 谁也不能在运行时修改任何东西，也没有函数可以修改在它的作用域之外修改什么值给其他函数继续使用。<br> 这意味着<strong>决定函数执行结果的唯一因素就是他的返回值，而影响其返回值的唯一因素就是它的参数。</strong></p>
</li>
<li><p>函数式变成不需要考虑”死锁”（deadlock）,因为它不仅改变量，所以根本不存在”锁”线程的问题。不必担心<br>  一个线程的数据被另一个线程修改，所以可以发那个心把工作分摊到多个线程，部署”并发编程”（concurrency）。</p>
</li>
<li><p>函数式编程中所有状态就是传给函数的参数，而参数都是储存在栈上的。这一特性让软件的热部署变得十分简单。<br>  只要比较一下正在运行的代码以及新的代码获得一个diff,然后用这个diff更新现有的代码，新代码的热部署就完成了。    </p>
</li>
</ul>
</blockquote>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><blockquote>
<ul>
<li><p>严格函数式编程的每一个函数都是对直接量或者表达式结果的引用，没有函数产生副作用。<br>  因为从未在某个地方修改过值，也没有函数修改过在其作用域之外的量并被其他函数使用(如类成员或全局变量)。<br>  这意味着函数求值的结果只是其返回值，而唯一影响其返回值的就是函数的参数。</p>
</li>
<li><p>这就是单元测试者的梦中仙境。对被测试程序中的每个函数，你只需在意其参数，而不必考虑函数调用顺序，不用谨慎地设置外部状态。<br>  所有要做的就是传递代表了边际情况的参数。如果程序中的每个函数都通过了单元测试，你就对这个软件的质量有了相当的自信。<br>  而命令式编程就不能这样乐观了，在java或 c++中只检查函数的返回值还不够–我们还必须验证这个函数可能修改了外部状态。</p>
</li>
</ul>
</blockquote>
<h2 id="总结与补充"><a href="#总结与补充" class="headerlink" title="总结与补充"></a>总结与补充</h2><p>函数式编程不应被视为灵丹妙药。相反的，它应被视为我们现有工具箱的一个很自然的补充—它带来的更高的可组合型，灵活性以及容错性。现代的javascript库已经开始尝试拥抱函数式编程的概念以获取这些优势。Redux作为一种 FLUX的变种实现，核心理念也是<br>状态机和函数式编程。</p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <url>http://yoursite.com/404.html</url>
      <content type="html"><![CDATA[<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>404</title>
</head>

<body>
<script type="text/javascript" src="http://www.qq.com/404/search_children.js" charset="utf-8" homepageurl="http://willxue.top" homepagename="我的博客"></script>
</body>

</html>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>http://yoursite.com/search/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[archives]]></title>
      <url>http://yoursite.com/archives/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[categories]]></title>
      <url>http://yoursite.com/categories/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[相册]]></title>
      <url>http://yoursite.com/photo/index.html</url>
      <content type="html"><![CDATA[<p><link type="text/css" href="/fancybox/jquery.fancybox.css" rel="stylesheet"></p>
<div class="instagram"><section class="archives album"><ul class="img-box-ul"></ul></section></div>

<script src="/js/photo.js"></script>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>http://yoursite.com/photo/output.json</url>
      <content type="html"><![CDATA[["61e1e24b5cf4a4f36fa8859e1dc35fb6.jpg","676501d6acd329b841ba4652f1a13bea.jpg","8cc6bf74cf842243e7779b1846f13d2d.jpg","a08c947d50eeb9bc7427a87ad58ef099.jpg","f39b5710f2086af425a1bace9e5b4321.jpg","u=66250564,3253305393&fm=23&gp=0.jpg"]]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>http://yoursite.com/photo/tool.js</url>
      <content type="html"><![CDATA["use strict";
const fs = require("fs");
const path = "../../photos";

fs.readdir(path, function (err, files) {
    if (err) {
        return;
    }
    let arr = [];
    (function iterator(index) {
        if (index == files.length) {
            fs.writeFile("output.json", JSON.stringify(arr, null, "\t"));
            return;
        }

        fs.stat(path + "/" + files[index], function (err, stats) {
            if (err) {
                return;
            }
            if (stats.isFile()) {
                arr.push(files[index]);
            }
            iterator(index + 1);
        })
    }(0));
});]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>http://yoursite.com/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
