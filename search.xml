<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[http协议背后的事]]></title>
      <url>http://yoursite.com/2017/03/29/http%E5%8D%8F%E8%AE%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8B/</url>
      <content type="html"><![CDATA[<ul>
<li>当我们输入网址后发生了什么</li>
<li>HTTP协议详解</li>
<li>HTTP协议安全</li>
<li>后台服务与HTTP</li>
<li>反向代理与web服务</li>
</ul>
<a id="more"></a>
<h3 id="浏览器行为与HTTP协议"><a href="#浏览器行为与HTTP协议" class="headerlink" title="浏览器行为与HTTP协议"></a>浏览器行为与HTTP协议</h3><ul>
<li>处理流程：<br>1.输入网址并回车<br>2.解析域名<br>3.浏览器发送http请求<br>4.服务器处理请求<br>5.服务器返回HTML响应<br>6.浏览器处理HTML页面<br>7.继续请求其他资源</li>
</ul>
<h3 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h3><ul>
<li>HTTP是超文本传输协议，从www浏览器传输到本地浏览器的一种传输协议，网站是基于HTTP协议的，例如网站的图片、CSS、JS等都是基于HTTP协议进行传输的。</li>
<li>HTTP协议是由从客户机到服务器的请求(Reuqest)和从服务器到客户机的响应(response)进行约束和规范。</li>
</ul>
<h3 id="了解TCP-IP协议栈"><a href="#了解TCP-IP协议栈" class="headerlink" title="了解TCP/IP协议栈"></a>了解TCP/IP协议栈</h3><p>1.应用层：为用户提供所需要的各种服务，例如：HTTP、FTP、DNS、SMTP等。<br>2.传输层：为应用层实体提供端到端通信功能，保证数据包的顺序传送及数据的完整性。该层定义了两个主要协议：<strong>传输控制协议(TCP)和用户数据报协议(UDP)</strong>。<br>3.网络层：主要解决主机到主机的通信问题。IP协议是网际互联层最重要的协议。<br>4.网络接口层：负责监视数据在主机和网络之间的交换。</p>
<h3 id="在TCP-IP协议栈中得位置"><a href="#在TCP-IP协议栈中得位置" class="headerlink" title="在TCP/IP协议栈中得位置"></a>在TCP/IP协议栈中得位置</h3><ul>
<li>目前应用版本HTTP1.1</li>
<li>HTTP默认端口号为80</li>
<li>HTTPS默认端口443<br><img src="/images/http1.png" alt=""></li>
</ul>
<h3 id="HTTP的工作过程"><a href="#HTTP的工作过程" class="headerlink" title="HTTP的工作过程"></a>HTTP的工作过程</h3><ul>
<li>一次HTTP操作称为一个事务,其工作过程可分为四步:<br>1.首先客户机与服务器需要建立连接。只要单击某个超级链接,HTTP的工作开始。<br>2.建立连接后,客户机发送一个请求给服务器,请求方式的格式为:统一资源标识符(URL)、协议版本号,后边是MIME信息包括请求修饰符、客户机信息和可能的内容。<br>3.服务器接到请求后,给予相应的响应信息,其格式为一个状态行,包括信息的协议版本号、一个成功或错误的代码,后边是MIME信息包括服务器信息、实体信息和可能的内容。<br>4.客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上,然后客户机与服务器断开连接。<br>如果在以上过程中的某一步出现错误,那么产生错误的信息将返回到客户端,有显示屏输出。对于用户来说,这些过程是由HTTP自己完成的,用户只要用鼠标点击,等待信息显示就可以了。</li>
</ul>
<h3 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h3><ul>
<li>HTTP请求组成:请求行、消息报头、请求正文。</li>
<li>HTTP响应组成:状态行、消息报头、响应正文。</li>
<li>请求行组成:以一个方法符号开头,后面跟着请求的URI和协议的版本。</li>
<li>状态行组成:服务器HTTP协议的版本,服务器发回的响应状态代码和状态代码的文本描述。</li>
</ul>
<p>(1) <strong>请求报文</strong><br><img src="/images/request.png" alt=""><br>(2) <strong>响应报文</strong><br><img src="/images/response.png" alt=""></p>
<h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><ul>
<li>GET: 请求获取Request-URI所标识的资源</li>
<li>POST: 在Request-URI所标识的资源后附加新的数据</li>
<li>HEAD: 请求获取由Request-URI所标识的资源的响应消息报头 </li>
<li>PUT: 请求服务器存储一个资源,并用Request-URI作为其标识 </li>
<li>DELETE: 请求服务器删除Request-URI所标识的资源</li>
<li>TRACE: 请求服务器回送收到的请求信息,主要用于测试或诊断</li>
<li>CONNECT: 保留将来使用 OPTIONS:请求查询服务器的性能,或者查询与资源相关的选项和需求</li>
</ul>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>状态代码有三位数字组成,第一个数字定义了响应的类别,且有五种可能取值: </p>
<ul>
<li>1xx:指示信息–表示请求已接收,继续处理 </li>
<li>2xx:成功–表示请求已被成功接收、理解、接受 </li>
<li>3xx:重定向–要完成请求必须进行更进一步的操作 </li>
<li>4xx:客户端错误–请求有语法错误或请求无法实现 </li>
<li>5xx:服务器端错误–服务器未能实现合法的请求</li>
</ul>
<h3 id="常用的请求报头"><a href="#常用的请求报头" class="headerlink" title="常用的请求报头"></a>常用的请求报头</h3><ul>
<li>Accept请求报头域用于指定客户端接受哪些类型的信息。eg:Accept:image/gif,Accept:text/ htmlAccept-Charset请求报头域用于指定客户端接受的字符集。Accept-Encoding:Accept-Encoding请求 报头域类似于Accept,但是它是用于指定可接受的内容编码。</li>
<li>Accept-Language请求报头域类似于Accept,但是它是用于指定一种自然语言。</li>
<li>Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时,如果收到服务器的响应代码为401(未授权),可以发送一个包含Authorization请求报头域的请求,要求服务 器对其进行验证。</li>
<li>Host请求报头域主要用于指定被请求资源的Internet主机和端又号,它通常从HTTP URL中提取出来 的,发送请求时,该报头域是必需的。</li>
<li>User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。</li>
</ul>
<h3 id="常用的响应报头"><a href="#常用的响应报头" class="headerlink" title="常用的响应报头"></a>常用的响应报头</h3><ul>
<li>Location响应报头域用于重定向接受者到一个新的位置。Location 响应报头域常用在更换域名的时候。</li>
<li>Server响应报头域包含了服务器用来处理请求的软件信息。与User- Agent请求报头域是相对应的。</li>
<li>WWW-Authenticate响应报头域必须被包含在401(未授权的)响应 消息中,客户端收到401响应消息时候,并发送Authorization报头 域请求服务器对其进行验证时,服务端响应报头就包含该报头域。</li>
</ul>
<h3 id="实体报头"><a href="#实体报头" class="headerlink" title="实体报头"></a>实体报头</h3><p>请求和响应消息都可以传送一个实体。一个实体由实体报头域 和实体正文组成,但并不是说实体报头域和实体正文要在一起 发送,可以只发送实体报头域。实体报头定义了关于实体正文 (eg:有无实体正文)和请求所标识的资源的元信息。</p>
<h3 id="常用的实体报头"><a href="#常用的实体报头" class="headerlink" title="常用的实体报头"></a>常用的实体报头</h3><ul>
<li>Content-Encoding实体报头域被用作媒体类型的修饰符,它的值指示了已经被应用到实体正文 的附加内容的编码,因而要获得Content-Type报头域中所引用的媒体类型,必须采用相应的解 码机制。</li>
<li>Content-Language实体报头域描述了资源所用的自然语言。 </li>
<li>Content-Length实体报头域用于指明实体正文的长度,以字节方式存储的十进制数字来表示。</li>
<li>Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。</li>
<li>Last-Modified实体报头域用于指示资源的最后修改日期和时间。 </li>
<li>Expires实体报头域给出响应过期的日期和时间。</li>
</ul>
<h3 id="cookies-与-session"><a href="#cookies-与-session" class="headerlink" title="cookies 与 session"></a>cookies 与 session</h3><ul>
<li>Cookies是保存在客户端的小段文本,随客户端点每一个请求发送该url下的所有cookies到服务器端。</li>
<li>Session则保存在服务器端,通过唯一的值sessionID来区别每一 个用户。SessionID随每个连接请求发送到服务器,服务器根据 sessionID来识别客户端,再通过session 的key获取session值。</li>
</ul>
<h3 id="cookie应用"><a href="#cookie应用" class="headerlink" title="cookie应用"></a>cookie应用</h3><p>与Cookie相关的HTTP扩展头<br>1.Cookie:客户端将服务器设置的Cookie返回到服务器;<br>2.Set-Cookie:服务器向客户端设置Cookie;<br>服务器在响应消息中用Set-Cookie头将 Cookie的内容回送给客户端,客户端在新 的请求中将相同的内容携带在Cookie头中 发送给服务器。从而实现会话的保持。</p>
<h3 id="session-使用"><a href="#session-使用" class="headerlink" title="session 使用"></a>session 使用</h3><ul>
<li>使用Cookie来实现 </li>
<li>使用URL回显来实现</li>
</ul>
<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><ul>
<li>缓存会根据请求保存输出内容的副本,例如html页面,图片,文 件,当下一个请求来到的时候:如果是相同的URL,缓存直接使 用副本响应访问请求,而不是向源服务器再次发送请求。</li>
<li>缓存的优点:<ol>
<li>减少相应延迟</li>
<li>减少网络带宽消耗</li>
</ol>
</li>
</ul>
<h3 id="浏览器缓存机制-浏览器第一次请求"><a href="#浏览器缓存机制-浏览器第一次请求" class="headerlink" title="浏览器缓存机制-浏览器第一次请求"></a>浏览器缓存机制-浏览器第一次请求</h3><p><img src="/images/request1.png" alt=""></p>
<h3 id="浏览器缓存机制-浏览器再次请求"><a href="#浏览器缓存机制-浏览器再次请求" class="headerlink" title="浏览器缓存机制-浏览器再次请求"></a>浏览器缓存机制-浏览器再次请求</h3><p><img src="/images/request2.png" alt=""></p>
<h3 id="Etag-if-None-Match策略"><a href="#Etag-if-None-Match策略" class="headerlink" title="Etag/if-None-Match策略"></a>Etag/if-None-Match策略</h3><ul>
<li>Etag:web服务器响应请求时,告诉浏览器当前资源在服务器的唯一标识(生成规则由服务器决定)</li>
<li>If-None-Match:当资源过期时(使用Cache-Control标识的max- age),发现资源具有Etage声明,则再次向web服务器请求时带 上头If-None-Match (Etag的值)。web服务器收到请求后发现 有头If-None-Match 则与被请求资源的相应校验串进行比对,决 定返回200或304。</li>
</ul>
<h3 id="Last-Modified-if-Modified-Since策略"><a href="#Last-Modified-if-Modified-Since策略" class="headerlink" title="Last-Modified/if-Modified-Since策略"></a>Last-Modified/if-Modified-Since策略</h3><ul>
<li>Last-Modified:标示这个响应资源的最后修改时间。web服务器在响应请求时,告诉浏览器资源的最后修改时间。</li>
<li>If-Modified-Since:当资源过期时(使用Cache-Control标识的max-age),发 现资源具有Last-Modified声明,则再次向web服务器请求时带上头 If- Modified-Since,表示请求时间。web服务器收到请求后发现有头If-Modified- Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新,说 明资源又被改动过,则响应整片资源内容(写在响应消息包体内),HTTP 200;若最后修改时间较旧,说明资源无新修改,则响应HTTP 304 (无需包 体,节省浏览),告知浏览器继续使用所保存的cache。</li>
</ul>
<h3 id="HTTP链路安全"><a href="#HTTP链路安全" class="headerlink" title="HTTP链路安全"></a>HTTP链路安全</h3><p>1.加密重要数据<br>2.对非重要数据签名<br>3.使用安全连接HTTPS协议</p>
<h3 id="下一代标准：HTTP2"><a href="#下一代标准：HTTP2" class="headerlink" title="下一代标准：HTTP2"></a>下一代标准：HTTP2</h3><ul>
<li>使用二进制格式传输,更高效、更紧凑。</li>
<li>对报头压缩,降低开销。</li>
<li>多路复用,一个网络连接实现并行请求。</li>
<li>服务器主动推送,减少请求的延迟</li>
</ul>
<h3 id="http与反向代理"><a href="#http与反向代理" class="headerlink" title="http与反向代理"></a>http与反向代理</h3><ul>
<li>什么是代理,什么又是反向代理?</li>
<li>为什么要使用反向代理? </li>
<li>都有哪些反向代理服务器?</li>
</ul>
<h3 id="反向代理的用途"><a href="#反向代理的用途" class="headerlink" title="反向代理的用途"></a>反向代理的用途</h3><ul>
<li>加密和SSL加速 </li>
<li>负载均衡 </li>
<li>缓存静态内容 </li>
<li>压缩</li>
<li>减速上传 </li>
<li>安全</li>
<li>外网发布</li>
</ul>
<h4 id="反向代理做负载均衡"><a href="#反向代理做负载均衡" class="headerlink" title="反向代理做负载均衡"></a>反向代理做负载均衡</h4><p><img src="/images/daili.png" alt=""></p>
<h4 id="让nginx跑起来"><a href="#让nginx跑起来" class="headerlink" title="让nginx跑起来"></a>让nginx跑起来</h4><ul>
<li>准备环境:Linux服务器、gcc编译器、nginx源代码 </li>
<li>获取nginx源码:<a href="http://nginx.org" target="_blank" rel="external">http://nginx.org</a> </li>
<li>编译安装nginx源码</li>
<li>配置规则</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[小程序面向个人开发者开放]]></title>
      <url>http://yoursite.com/2017/03/28/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%9D%A2%E5%90%91%E4%B8%AA%E4%BA%BA%E5%BC%80%E5%8F%91%E8%80%85%E5%BC%80%E6%94%BE/</url>
      <content type="html"><![CDATA[<blockquote>
<ul>
<li>3月27日晚上10点，微信官方通过“微信公开课”和“微信公众平台”发布重磅消息称，小程序对个人开发者开放注册，并宣布小程序新增六大能力。</li>
</ul>
</blockquote>
<p>   新增6大功能为：个人开发者开放、公众号自定义菜单跳小程序、公众号模版消息可打开相关小程序、模板消息跳小程序 、绑定时可发送模板消息、兼容线下二维码、App分享用小程序打开。</p>
<p>1.<strong>个人开发者可申请小程序</strong></p>
<p>   小程序开放个人开发者申请注册，个人用户可访问微信公众平台，扫码验证个人身份后即可完成小程序帐号申请并进行代码开发。</p>
<p>   申请个人开发者的个人需要实名。现在，对小程序感兴趣，并且有开发能力者，可以在开放的类目范围内，通过开发小程序，把自己的“一个想法”变成“一件作品”，并为微信用户所使用，进一步发挥开发者的个人价值。</p>
<a id="more"></a>    
<blockquote>
<ul>
<li><p>个人开发者可以做些什么？</p>
</li>
<li><p>Q：作为一个个人开发者，我可以申请注册几个小程序？可以开发什么类型的小程序？</p>
</li>
<li><p>A：每个个人可申请5个小程序（身份证+微信号合计5个），不占用组织类型帐号的名额。目前，个人开发者可以开发生活服务、工具、旅游、出行与交通、餐饮、商业服务、体育、快递业与邮政、教育等类别的小程序。后续，支持的类目会随平台规则而调整。</p>
</li>
<li><p>Q：和组织类型开发者相比，个人开发者在小程序的开发上有什么不同？</p>
</li>
<li><p>A：和组织类型开发者相比，个人类型开发者的开发流程更短：注册——验证身份——填写详细信息——开发——提交代码审核——审核通过后可发布。</p>
</li>
<li><p>Q：目前，小程序对于个人开发者开放了哪些能力？</p>
</li>
<li><p>A：小程序对个人开发者开放的API能力和组织类型的基本一致，如消息通知（客服消息、模板消息）、自定义二维码生成等能力，也支持同主体的公众号关联。</p>
</li>
<li><p>在开放能力上，我们希望有更多的突破，以帮助个人能在开发中更好地运用开发工具。因此，我们开放了更多的接口权限给到了个人开发者。目前，个人小程序不支持进行个人认证、支付和卡券功能。</p>
</li>
</ul>
</blockquote>
<p>请访问：<a href="mp.weixin.qq.com">微信公众平台mp.weixin.qq.com</a></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/Sl2B4aOmG2MdomPTjz8wt5AhZ9eJvcD1tM4L4YnHKDibxRicaWwK0pmxSqT4YGKDdGY2k4XMdHtnSVyOxPb9Hyzg/640?wx_fmt=jpeg" alt=""></p>
<p>2.<strong>公众号自定义菜单点击可打开相关小程序</strong></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/Sl2B4aOmG2MdomPTjz8wt5AhZ9eJvcD1V9w0XyibD2zmNYSEAECoz89USoxEWZoia2g9YFicEkWwPibVv41uic2HrAA/640?wx_fmt=png" alt=""></p>
<p>公众号可将已关联的小程序页面放置到自定义菜单中，用户点击后可打开该小程序页面。公众号运营者可在公众平台进行设置，也可以通过自定义菜单接口进行设置。</p>
<p>详见开发文档：<a href="mp.weixin.qq.com/wiki">微信公众平台文档mp.weixin.qq.com/wiki -自定义菜单</a></p>
<p>3.<strong>公众号模版消息可打开相关小程序</strong></p>
<p>公众号已关联的小程序页面可以配置到公众号的模版消息中，用户点击公众号下发的模版消息，可以打开对应的小程序页面。</p>
<p>详见开发文档：微信公众平台文档(mp.weixin.qq.com/wiki)-模版消息</p>
<p>4.<strong>公众号关联小程序时，可选择给粉丝下发通知</strong></p>
<p><img src="https://mmbiz.qlogo.cn/mmbiz_png/Sl2B4aOmG2MdomPTjz8wt5AhZ9eJvcD1ZqTbVmKAmSibaCZppvxrYl293fhmSasBl68dKYhGtsLGtAiaN2CE37RA/0?wx_fmt=png" alt=""></p>
<p>公众号关联小程序时，可选择给粉丝下发通知消息，粉丝点击该通知消息可以打开小程序。该消息不占用原有群发条数。</p>
<p>5.<strong>移动App可分享小程序页面</strong></p>
<p>开发者可以把小程序绑定到微信开放平台。绑定后，同一微信开放平台帐号下的App可分享已绑定的小程序页面到微信内的会话或群聊。APP链接分享到微信，点开就是小程序。</p>
<p>详见开发文档：<a href="open.weixin.qq.com">微信开放平台open.weixin.qq.com -资源中心-移动应用-分享与收藏功能</a></p>
<p>6.<strong>扫描普通链接二维码可打开小程序</strong></p>
<p>商户如果在线下已铺设了普通链接二维码，可在公众平台的小程序管理后台进行配置，用户扫描该原有线下普通链接二维码可直接打开小程序。</p>
<p>微信官方称，摩拜单车扫描单车二维码直接进入小程序的能力，现在通用了。</p>
<h2 id="总结：公众号和小程序新增三种连接方式："><a href="#总结：公众号和小程序新增三种连接方式：" class="headerlink" title="总结：公众号和小程序新增三种连接方式："></a>总结：公众号和小程序新增三种连接方式：</h2><p>在支持公众号绑定相关小程序后，公众号和小程序有了三种新的连接跳转方式：</p>
<p>①公众号可以把自己关联的小程序放在自定义菜单中，用户点击可直达小程序。</p>
<p>②公众号模版消息可打开相关小程序。通过公众号，公众号运营者可以推送关联的小程序页面了。</p>
<p>③公众号绑定相关小程序时，可选择给粉丝下发通知。公众号运营者可以通知粉丝，“我绑定了这个小程序”，粉丝点击消息就可以打开小程序。（此消息不占用原有群发条数）</p>
]]></content>
      
        
        <tags>
            
            <tag> 小程序开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript函数式编程]]></title>
      <url>http://yoursite.com/2017/03/28/javascript%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<ul>
<li>函数式编程思维</li>
<li>函数式编程常用核心概念</li>
<li>当下函数式编程最热的库</li>
</ul>
<h2 id="函数式编程基础理论"><a href="#函数式编程基础理论" class="headerlink" title="函数式编程基础理论"></a>函数式编程基础理论</h2><p>1.函数式编程（Functional Programming）相对计算机历史而言是一个古老的概念，甚至早于第一台计算机的诞生。函数式编程的基础模型来源于 ℷ (lambda x=x&gt;x*2)演算，<br>     而 ℷ 演算并非设计于在计算机上执行，它是一套用于研究函数定义、函数应用和递归的形式系统。<br>2.函数式编程不是用函数来编程，也不是传统的面向过程编程。是将复杂的函数符合成简单的函数（计算理论、递归论、ℷ 演算）。运算过程尽量写成一系列嵌套的函数调用。<br>3.javascript是披着 C 外衣的lisp。<br>4.真正的火热是随着React的高阶函数而逐步升温。</p>
<a id="more"></a>
<blockquote>
<ul>
<li><strong>函数</strong>：函数是一等公民，指的是<strong>函数与其他数据类型一样</strong>，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</li>
<li><strong>不可变量</strong>：在函数编程中，我们通常理解的变量在函数式编程中也被函数代替了。<strong>在函数编程中变量仅仅代表某个表达式</strong>。这里所说的’变量’是不能被修改的。<br>  所有的变量只能被赋值一次初值。</li>
<li>map &amp; reduce 他们是最常用的函数式编程的方法。</li>
</ul>
</blockquote>
<h2 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h2><ul>
<li>纯函数</li>
<li>函数的柯里化</li>
<li>函数组合</li>
<li>Point Free</li>
<li>声明式与命令式代码</li>
<li>惰性求值</li>
</ul>
<p>1.纯函数：对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。</p>
<pre><code>var arr=[1,2,3,4,5];
// Array.slice是纯函数，因为它没有副作用，对于固定的输入，输出总是固定的
xs.slice(0,3);
xs.slice(0,3);
xs.slice(0,3);
xs.slice(0,3);
</code></pre><p>优缺点：</p>
<pre><code>import_from &apos;lodash&apos;;
var sin=_.memorize(x=&gt;Math.sin(x));
//第一次计算的时候会稍微慢一点 var a=sin(1);
//第二次有了缓存，速度极快  var b=sin(1);
</code></pre><p>纯函数不仅可以有效降低系统的复杂度，还有很多很棒的特性，必如<strong>可缓存性</strong>；</p>
<pre><code>//不纯的
var min=18;
var checkage = age =&gt; age &gt;18;
</code></pre><p>在不纯的版本中，checkage不仅取决于age还有外部依赖的变量min。纯的checkage把关键数字18硬编码在函数内部，扩展性比较差，柯里化优雅的函数式解决。</p>
<p>2.函数的柯里化：传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
<pre><code>var checkage = min =&gt;(age =&gt; age &gt;min);
var checkage18 =checkage(18);
checkage18(20); 
</code></pre><p>优缺点：</p>
<pre><code>import {curry} from &apos;lodash&apos;;
var match=curry((reg,str)=&gt; str.match(reg));
var filter=curry((f,arr)=&gt; arr.filter(f));
var haveSpace = match(/\s+/g);
haveSpave(&quot;ffffff&quot;);
haveSpace(&quot;a b&quot;);

filter(haveSpace,[&quot;abcdefg&quot;,&quot;Hello World&quot;]);
//=&gt;[&quot;Hello world&quot;];
</code></pre><p><strong>事实上柯里化是一种 “预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的”缓存”，是一种非常高效的编写函数的方法。</strong></p>
<p>3.函数组合：纯函数以及如何把它柯里化写出的层叠代码h(g(f(x))),为了解决函数嵌套问题，我们需要用到”函数组合”。</p>
<pre><code>//我们用柯里化改，让多个函数像拼积木一样
const compose = (f,g) =&gt; (x =&gt; f(g(x)));
var first = arr =&gt; arr[0];
var reverse = arr =&gt; arr.reverse();
var last = compose(first,reverse);
last([1,2,3,4,5]);
</code></pre><p>4.Point Free: 把一些对象自带的方法转化成纯函数，不要命名转瞬即逝的中间变量。</p>
<pre><code>const f = str =&gt; str.toUpperCase().split(&apos;&apos;);
</code></pre><p>这个函数中，我们使用了str作为中间变量，但是这个中间变量除了让代码长以外毫无意义。</p>
<p>优缺点: </p>
<pre><code>var toUpperCasre = word =&gt; word.toUpperCase();
var split = x =&gt; (str =&gt; str.split(x));
var f = compose(split(&apos;&apos;),toUpperCase);
f(&quot;abcd efgh&quot;);
</code></pre><p>这种风格能够帮助我们减少不必要的命名，让代码保持简洁和通用。</p>
<p>5.声明式与命令式代码</p>
<p>命令式代码：通过编写一条又一条指令让计算机执行一些动作，一般都会涉及到很多繁杂的细节。<br>声明式代码：通过写表达式的方法来声明我们想干什么，而不是通过一步一步的指示。</p>
<pre><code>//命令式
let CEOs=[];
for(var i=0;i&lt;companies.length;i++){
    CEOs.push(comanies[i].CEO);
}
//声明式
let CEOs=companies.map(c =&gt; c.CEO);
</code></pre><p>优缺点：函数式编程的一个明显好处就是这种声明式的代码，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的，专注于编写业务代码。<br>优化代码时，只需要集中在稳定坚固的函数内部。相反，不纯的函数式的代码会产生副作用或者依赖外部系统环境，使用他们的时候总要考虑这些副作用，<br>在复杂的系统中，这对于程序员是极大的负担。</p>
<p>6.惰性求值、惰性函数</p>
<p>在指令式语言中以下代码会按顺序执行，由于每个函数都有可能改动或者依赖于外部状态，因此必须顺序执行。<br>把concatenate 换成另外一个函数，这个函数中又条件判断语句，实际上只会需要两个参数中的其中一个，<br>那么就没有必要执行计算另外一个参数的函数了。</p>
<pre><code>var s1=somewhatlongOperation1();
var s2=somewhatlongOperation2();
var s3=concatenate(s1,s2);
function somewhatlongOperation1(){somewhatlongOperation1}
</code></pre><h2 id="更加专业术语"><a href="#更加专业术语" class="headerlink" title="更加专业术语"></a>更加专业术语</h2><ul>
<li>高阶函数</li>
<li>尾调用优化</li>
<li>闭包</li>
<li>容器、Functor</li>
<li>错误处理、Either</li>
<li>IO</li>
<li>Monad</li>
</ul>
<p>1.高阶函数：函数当参数，把传入的函数做一个封装，然后返回这个封装函数，达到更高程度的抽象。</p>
<pre><code>//命令式
var add = function(a,b){
    return a+b;
};
function math(func,array){
    return func(array[0],array[1]);
}
math(add,[1,2]); //3
</code></pre><p>2.尾调用优化：函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。<br>   函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归需要保存大量的调用记录，很容易发生栈溢出错误，如果使用尾递归优化，<br>   将递归变为循环，那么只需要保存一个调用记录，这样就不会发生栈溢出错误了。</p>
<pre><code>//不是尾递归，无法优化
function factorial(n){
    if(n===1)return 1;
    return n * factorial(n-1);
}
function factorial(n,total){
    if(n===1) return total;
    return factorial(n-1,n*total);
} //es6强制使用尾递归
</code></pre><p>细数尾递归</p>
<p>实例一：</p>
<pre><code>function sum(n){
    if(n===1)return 1;
    return n + sum(n-1);
}

sum(5)
(5 + sum(4))
(5 + (4 + sum(3)))
(5 + (4 + (3 + sum(2))))
(5 + (4 + (3 + (2 + sum(1)))))
(5 + (4 + (3 + (2 + 1))))
(5 + (4 + (3 + 3)))
(5 + (4 + 6))
(5 + 10)
15
</code></pre><p>普通递归时，内存需要记录调用的堆栈所处的深度和位置信息。<br>在最底层计算返回值，再根据记录信息，跳回上一层级计算，然后再跳回更高一层，依次运行，直到最外层调用函数。<br>在cpu计算和内存会消耗很多，而且当深度过大时，会出现堆栈溢出。</p>
<p>实例二：   </p>
<pre><code>function sum(x,total){
    if(x === 1){
        return x + total;
    }
    return sum(x-1,x + total); 
}

sum(5,0)
sum(4,5)
sum(3,9)
sum(2,12)
sum(1,14)
15
</code></pre><p>整个计算过程是线性的，调用一次 sum(x,total)后，会进入下一个栈，相关的数据信息跟随进入，不再放在堆栈上保存。<br>当计算完最后的值之后，直接返回到最上层的sum(5,0)。这能有效的防止堆栈溢出。<br>在ECMAScript6,我们将迎来尾递归优化，通过尾递归优化，javascript代码在解释成机器码的时候，将会向while看起，也就是说，同事拥有数学表达式能力和while的效能。</p>
<p>3.闭包</p>
<p>如下例子，虽然外层的makePowerFn函数执行完毕，栈上的调用帧被释放，但是堆上的作用域并不被释放，因此power依旧可以被powerFn函数访问，这样就形成了闭包。</p>
<pre><code>function makePowerFn(power){
    function powerFn(base){
        return Math.pow(base,power);
    }
    return powerFn;
}
var square = makePowerFn(2);
square(3); //9
</code></pre><p>4.容器、Functor（函子）</p>
<blockquote>
<ul>
<li>$(…)返回的对象并不是一个原生的DOM对象，而是对于原生对象的一种封装，这在某种意义上就是一个”容器”（但它并不函数式）。</li>
<li>Functor(函子)遵守一些特定规则的容器类型。</li>
<li>Functor是一个对于函数调用的抽象，我们赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口map给容器外的函数，map一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由的选择何时何地如何操作这个函数，以至于拥有惰性求值、错误处理、异步调用等等非常棒的特性。</li>
</ul>
</blockquote>
<pre><code>var Container = fuunction(x){
    this._value = x;
}
Container.of = x =&gt; new Container(x);
//Container.of(&apos;abcd&apos;);
Container.prototype.map = function(f){
    return Container.of(f(this._value));
}
Container.of(3)
    .map(x =&gt; x+1) // =&gt;Container(4)
    .map(x =&gt; &apos;Result is&apos; + x);  // =&gt; Container(&apos;Result is 4&apos;);

---

var Maybe = function(x){
    this._value = x;
}
Maybe.of = function(x){
    return new Maybe(x);
}
Maybe.prototype.map=function(f){
    return this.isNothing()? Maybe.of(null) : Maybe.of(f(this._value));
}
Maybe.prototype.isNothing = function(){
    return (this._value === null || this._value === undefined);
}
//新的容器我们称为 Maybe(原型来自于 Haskell)
</code></pre><p>5.错误处理、Either</p>
<blockquote>
<ul>
<li>我们的容器能做的事情太少，try/catch/throw 并不是”纯”的，因为它从外部接管了我们的函数，并且在这个函数出错时抛弃了它的返回值。</li>
<li>Promise 是可以调用 catch来集中处理错误的。</li>
<li>事实上Either并不只是用来做错误处理的，它表示了逻辑或，范畴学里的coproduc。</li>
</ul>
</blockquote>
<pre><code>var left = function(x){
    this._value = x;
}
var Right = function(x){
     this._value = x;
}

Left.of = function(x){
    return new Left(x);
}
Right.of=function(x){
    return new Rgith(x);
}

---
//这里不同
Left.prototype.map = function(f){
    return this;
}
Rgiht.prototype.map = function(f){
    return Right.of(f(this._value));
}
</code></pre><p>left和Right 唯一的区别在于 map方法的实现，Right.map的行为和之前提到的map函数一样。<br>但是left.map就很不同了，它不会对容器做任何事情，只是很简单地把这个容器拿进来又扔出去。<br>这个特性意味着，left可以用来传递一个错误消息。</p>
<pre><code>var getAge = user =&gt; user.age ? Right.of(user.age):Left.of(&quot;ERROR&quot;);

getAge({name:&apos;stark&apos;,age:&apos;21&apos;}).map(age =&gt; &apos;Age is&apos;+ age);
// =&gt; Right(&apos;Age is 21&apos;)
get Age({name:&apos;stark}).map(age =&gt; &apos;Age is&apos; +age);
//=&gt; Left(&apos;ERROR&apos;)
</code></pre><p>left 可以让调用链中任意一环的错误立刻返回到调用链的尾部，这给我们错误处理带来了很大的方便，再也不用一层一层的try/catch。</p>
<p>6.IO</p>
<p>真正的程序总要去接触不纯的世界。如下例子就依赖于window。</p>
<pre><code>function readlocalStorage(){
    return window.localStorage;
}
</code></pre><blockquote>
<ul>
<li>IO跟前面几个Functor不同的地方在于，它的_value是一个函数。它把不纯的操作(比如IO、网络请求、DOM)包裹到一个函数内，从而延迟这个操作的执行。所以我们认为，<strong>IO包含的是被包裹的操作的返回值</strong>。</li>
<li>IO其实也算是惰性求值。</li>
<li>IO负责了调用链积累了很多不纯的操作，带来的复杂性和不可维护性。</li>
</ul>
</blockquote>
<pre><code>impport _from &apos;lodash&apos;;
var compose = _.flowRight;

var IO = function(f){
    this._value = f;
}

IO.of = x =&gt; new IO(_ =&gt; x);

IO.prototype.map = function(f){
    return new IO(compose(f,this._value));
}
</code></pre><h2 id="流行的几大函数式编程库"><a href="#流行的几大函数式编程库" class="headerlink" title="流行的几大函数式编程库"></a>流行的几大函数式编程库</h2><ul>
<li>RxJS</li>
<li>cycleJS</li>
<li>lodashJS</li>
<li>underscoreJS</li>
<li>ramdajs</li>
</ul>
<p>1.Rxjs从诞生依赖一直都不温不火，但它函数响应式编程(Functional Reactive Programming ,FRP)的理念非常先进，虽然或许对于大部分应用环境，外部输入事件并不是太频繁，并不需要引入一个如此庞大的FRP体系，但我们也可以了解一下它又哪些优秀的特性。<br>  <strong>  在 Rxjs中，所有的外部输入（用户输入、网络请求等等）都被视作一种【事件流】：</strong><br>  用户点击了按钮 –&gt; 网络请求成功 –&gt; 用户键盘输入 –&gt; 某个定时事件发生 –&gt; 这种事件流特别适合实例游戏，上上下下上上下下<br>  举个例子，下面这段代码会监听点击事件，每两次点击事件产生一次事件相应：</p>
<pre><code>var clicks = Rx.Observable
    .fromEvent(document,&apos;click&apos;)
    .bufferCount(2)
    .subscribe(x =&gt; console.log(x)); //打印出两次点击事件
</code></pre><p>2.Cycle.js 是一个基于Rxjs的框架，它是一个彻彻底底的 FRP 理念的框架，和 React一样支持virtual DOM 、JSX语法，但现在似乎还没有看到大型的应用经验。<br>     本质的讲，它就是在 Rxjs的基础上加入了对 virtual DOM、容器和组件的支持，比如下面就是一个简单的【开关】按钮：   </p>
<pre><code>function main(sources){
   const sinks={
       DOM : sources.DOM.select(&apos;input&apos;).events(&apos;click&apos;)
       .map(ev =&gt; ev.target.checked)
       .startWith(false)
       .map(toggled =&gt;
           &lt;div&gt;
               &lt;input type=&quot;checkbox&quot; /&gt; Toggle me
               &lt;p&gt;{toggled ? &apos;ON&apos; ： &apos;off&apos;}&lt;/p&gt;
           &lt;/div&gt;
       )
   };
   return sinks;
}

const drivers={
   DOM:makeDOMDriver(&apos;#app&apos;)
};

run(main,drivers);    
</code></pre><p>3.Underscore 是一个 javascript工具库，它提供了一整套函数式编程实用功能，但是没有扩展任何 javascript内置对象。</p>
<blockquote>
<ul>
<li><p>它解决了这个问题：”如果我面对一个空白的html页面，并希望立即开始工作，我需要什么？”它你不了jquery没有实现的功能，同时又是backbone必不可少的部分。</p>
</li>
<li><p>underscore提供了100多个函数，包括常用的：map、filter、invoke 当然还有更专业的辅助函数，如：函数绑定、javascript模板功能、创建快速索引、强类型相等测试等等。</p>
</li>
</ul>
</blockquote>
<p>4.lodash是一个具有一致接口、模块化、高性能等特性的javascript工具库，是unserscorejs的 fork,最初目标也是”一致的跨浏览器行为，并改善性能。”</p>
<blockquote>
<ul>
<li><p>lodash采用延迟计算，意味着我们的链式方法在显式或者隐式的value()调用之前是不会执行的，因此lodash可以进行 shortcut(捷径)fusion(融合)这样的优化，通过合并链式大大降低迭代的次数，从而大大提升其执行性能。</p>
</li>
<li><p>就如同jquery在全部函数前加全局的$一样，lodash使用全局的 _来提供对工具的快速访问。     </p>
</li>
</ul>
</blockquote>
<pre><code>var abc = function(a,b,c){
   return [a,b,c];
};
var currid = _.curry(abc);
curried(1)(2)(3);

------
function square(n){
   return n*n;
} 
var addSquare = _.flowRight(square,_.add);
addSquare(1,2);
// =&gt; 9
</code></pre><p>5.Ramdajs: 是一个非常优秀的js工具库，跟同类比更函数式主要体现在以下几个原则。</p>
<blockquote>
<ul>
<li>ramda里面的提供的函数全部都是curry的，意味着函数没有默认参数可选参数从而减轻认知函数的难度。</li>
<li>ramda 推崇pointfree简单的说就是使用简单函数组合实现一个复杂功能，而不是单独写一个函数操作临时变量。</li>
<li>ramda有个非常好用的参数占位符 R._ 大大减轻了函数在 pointfree过程中参数位置的问题。</li>
<li>相比underscore/lodash感觉更干净很多。</li>
</ul>
</blockquote>
<h2 id="函数式编程实际应用场景"><a href="#函数式编程实际应用场景" class="headerlink" title="函数式编程实际应用场景"></a>函数式编程实际应用场景</h2><ul>
<li>易调试、热部署、并发</li>
<li>单元测试</li>
<li>总结与补充</li>
</ul>
<h3 id="易调试、热部署、并发"><a href="#易调试、热部署、并发" class="headerlink" title="易调试、热部署、并发"></a>易调试、热部署、并发</h3><blockquote>
<ul>
<li><p>函数式编程中得每个符号都是const的，于是没有什么函数会有副作用。<br> 谁也不能在运行时修改任何东西，也没有函数可以修改在它的作用域之外修改什么值给其他函数继续使用。<br> 这意味着<strong>决定函数执行结果的唯一因素就是他的返回值，而影响其返回值的唯一因素就是它的参数。</strong></p>
</li>
<li><p>函数式变成不需要考虑”死锁”（deadlock）,因为它不仅改变量，所以根本不存在”锁”线程的问题。不必担心<br>  一个线程的数据被另一个线程修改，所以可以发那个心把工作分摊到多个线程，部署”并发编程”（concurrency）。</p>
</li>
<li><p>函数式编程中所有状态就是传给函数的参数，而参数都是储存在栈上的。这一特性让软件的热部署变得十分简单。<br>  只要比较一下正在运行的代码以及新的代码获得一个diff,然后用这个diff更新现有的代码，新代码的热部署就完成了。    </p>
</li>
</ul>
</blockquote>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><blockquote>
<ul>
<li><p>严格函数式编程的每一个函数都是对直接量或者表达式结果的引用，没有函数产生副作用。<br>  因为从未在某个地方修改过值，也没有函数修改过在其作用域之外的量并被其他函数使用(如类成员或全局变量)。<br>  这意味着函数求值的结果只是其返回值，而唯一影响其返回值的就是函数的参数。</p>
</li>
<li><p>这就是单元测试者的梦中仙境。对被测试程序中的每个函数，你只需在意其参数，而不必考虑函数调用顺序，不用谨慎地设置外部状态。<br>  所有要做的就是传递代表了边际情况的参数。如果程序中的每个函数都通过了单元测试，你就对这个软件的质量有了相当的自信。<br>  而命令式编程就不能这样乐观了，在java或 c++中只检查函数的返回值还不够–我们还必须验证这个函数可能修改了外部状态。</p>
</li>
</ul>
</blockquote>
<h2 id="总结与补充"><a href="#总结与补充" class="headerlink" title="总结与补充"></a>总结与补充</h2><p>函数式编程不应被视为灵丹妙药。相反的，它应被视为我们现有工具箱的一个很自然的补充—它带来的更高的可组合型，灵活性以及容错性。现代的javascript库已经开始尝试拥抱函数式编程的概念以获取这些优势。Redux作为一种 FLUX的变种实现，核心理念也是<br>状态机和函数式编程。</p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <url>http://yoursite.com/404.html</url>
      <content type="html"><![CDATA[<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>404</title>
</head>

<body>
<script type="text/javascript" src="http://www.qq.com/404/search_children.js" charset="utf-8" homepageurl="http://willxue.top" homepagename="我的博客"></script>
</body>

</html>]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>http://yoursite.com/search/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[archives]]></title>
      <url>http://yoursite.com/archives/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[categories]]></title>
      <url>http://yoursite.com/categories/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[相册]]></title>
      <url>http://yoursite.com/photo/index.html</url>
      <content type="html"><![CDATA[<p><link type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.css" rel="stylesheet"></p>
<p><div class="instagram"><section class="archives album"><ul class="img-box-ul"></ul></section></div></p>
<script src="/source-src/js/photo.js"></script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/source-src/js/main.js" type="text/javascript"></script>
]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>http://yoursite.com/photo/output.json</url>
      <content type="html"><![CDATA[["61e1e24b5cf4a4f36fa8859e1dc35fb6.jpg","676501d6acd329b841ba4652f1a13bea.jpg","8cc6bf74cf842243e7779b1846f13d2d.jpg","a08c947d50eeb9bc7427a87ad58ef099.jpg","f39b5710f2086af425a1bace9e5b4321.jpg","u=66250564,3253305393&fm=23&gp=0.jpg"]]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>http://yoursite.com/photo/tool.js</url>
      <content type="html"><![CDATA["use strict";
const fs = require("fs");
const path = "../../photos";

fs.readdir(path, function (err, files) {
    if (err) {
        return;
    }
    let arr = [];
    (function iterator(index) {
        if (index == files.length) {
            fs.writeFile("output.json", JSON.stringify(arr, null, "\t"));
            return;
        }

        fs.stat(path + "/" + files[index], function (err, stats) {
            if (err) {
                return;
            }
            if (stats.isFile()) {
                arr.push(files[index]);
            }
            iterator(index + 1);
        })
    }(0));
});]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>http://yoursite.com/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
